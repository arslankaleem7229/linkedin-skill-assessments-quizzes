{
  "quizz": {
    "id": "45741a22677a22afcb4659f0",
    "title": "C (Linguaggio di Programmazione)",
    "description": "Seeded from c-(programming-language)/c-(programming-language)-quiz-it.md",
    "createdById": "seed-user",
    "questions": [
      {
        "id": "8fa2852a3bc0f6e2b14b1cd8",
        "question": "Quale esempio di codice causer\u00e0 eventualmente l'esaurimento della memoria del computer?",
        "answer": ":",
        "explanation": "```c\nwhile(1)\n{\nchar *smallString = (char *) malloc(10);\n}\n```\n```c\nlong long number = 1;\nwhile(1)\nnumber *= 2;\n```\n```c\nwhile(1)\n{\nchar hugeString[1000000L];\nmemset(hugeString, 0, 1000000L);\n}\n```\n```c\nwhile(1)\n{\nlong *bigArray = (long *) malloc(sizeof(long) * 1000);\nmemset(bigArray, 1000000, 1000);\n(bigArray);\n}\n```",
        "hint": null,
        "correctAnswer": [
          ":"
        ],
        "options": [
          ":",
          ":",
          ":",
          ":"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "17ecc8db8d979cd01d58d55e",
        "question": "Quale sar\u00e0 l'output del codice seguente?\n```c\nint f1 (int a, int b)\n{\n    if (a > b)\n    {\n        printf(\"A \u00e8 maggiore di B\\n\");\n        return 1;\n    }\n    else\n    {\n        printf(\"B \u00e8 maggiore di A\");\n        return 0;\n    }\n}\nmain()\n{\n    if (f1(20,10) || f1(10,20))\n        printf(\"C \u00e8 divertente!\\n\");\n}\n```",
        "answer": ":",
        "explanation": "```\nA \u00e8 maggiore di B\nC \u00e8 divertente!\n```\n```\nA \u00e8 maggiore di B\nB \u00e8 maggiore di A\nC \u00e8 divertente!\n```\n```\nA \u00e8 maggiore di B\nB \u00e8 maggiore di A\n```",
        "hint": null,
        "correctAnswer": [
          ":"
        ],
        "options": [
          ":",
          ":",
          ":",
          "Nulla viene stampato sullo schermo"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "423f1cbcf88e5f09b827af7d",
        "question": "Come si chiama la chiamata di una funzione all'interno della stessa funzione?",
        "answer": "ricorsione",
        "explanation": "[Riferimento](https://www.cprogramming.com/tutorial/c/lesson16.html)",
        "hint": null,
        "correctAnswer": [
          "ricorsione"
        ],
        "options": [
          "ricorsione",
          "sottofunzione",
          "chiamata interna",
          "ciclo infinito"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "42ccfd43d8222d8bea50b854",
        "question": "Cosa dimostra la dichiarazione della variabile c2?\n```c\nmain(){\n    char c1 ='a';\n    char c2 = c1+10;\n}\n```",
        "answer": "aritmetica dei caratteri",
        "explanation": "[Riferimento](https://tutorialspoint.dev/language/c/character-arithmetic-c-c)",
        "hint": null,
        "correctAnswer": [
          "aritmetica dei caratteri"
        ],
        "options": [
          "aritmetica dei caratteri",
          "assegnazione non definita",
          "conversione di tipo",
          "dichiarazione non valida"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "4ab02ac0c5485d7d663f95e5",
        "question": "Di cosa \u00e8 un esempio questa dichiarazione?\n```c\nstruct s {\n    int i;\n    struct s *s1;\n    struct s *s2;\n};\n```",
        "answer": "un nodo",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "un nodo"
        ],
        "options": [
          "un nodo",
          "una lista collegata",
          "uno stack",
          "un albero binario"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "e22f930690755168323ffbab",
        "question": "I file di intestazione sono elencati utilizzando la direttiva di preelaborazione #include e possono avere uno dei seguenti formati: #include &lt;fileA&gt; o #include \"fileB\". Qual \u00e8 la differenza tra questi due formati?",
        "answer": "Il preprocessore cercher\u00e0 di localizzare fileA in un percorso di directory predeterminato. Cercher\u00e0 di localizzare fileB nella stessa directory del file sorgente insieme a un percorso di directory personalizzato.",
        "explanation": "[Riferimento](https://www.geeksforgeeks.org/difference-between-include-and-include-in-c-c-with-examples/#:~:text=The%20difference%20between%20the%20two,be%20included%20in%20the%20code.&text=%23include%20is%20for%20pre%2Ddefined%20header%20files.)",
        "hint": null,
        "correctAnswer": [
          "Il preprocessore cercher\u00e0 di localizzare fileA in un percorso di directory predeterminato. Cercher\u00e0 di localizzare fileB nella stessa directory del file sorgente insieme a un percorso di directory personalizzato."
        ],
        "options": [
          "Il preprocessore cercher\u00e0 di localizzare fileA nella stessa directory del file sorgente e fileB in un percorso di directory predeterminato.",
          "Il preprocessore cercher\u00e0 di localizzare fileA nella directory di sistema fissa. Cercher\u00e0 di localizzare fileB nel percorso di directory designato dall'opzione -I aggiunta alla riga di comando durante la compilazione del codice sorgente.",
          "Il file che utilizza la sintassi fileA deve essere un file di sistema, in numero illimitato; fileB deve essere un file utente con un massimo di uno per file sorgente.",
          "Il preprocessore cercher\u00e0 di localizzare fileA in un percorso di directory predeterminato. Cercher\u00e0 di localizzare fileB nella stessa directory del file sorgente insieme a un percorso di directory personalizzato."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "5d9263f39bafd04bcb0380e8",
        "question": "Utilizzando un ciclo for, come potresti scrivere un codice C per contare da 10 a 1 e visualizzare ogni numero sulla propria riga?",
        "answer": ":",
        "explanation": "```c\nfor (int i = 0; i>=0, i--){\nprintf(\"%d\\n\", i);\n}//fine del ciclo\n```\n```c\nint i;\nfor (i=1; i<=10; i++){\nprintf(\"%d\", i);\n}\n```\n```c\nint i = 10;\nwhile (i>0){\nprintf(\"%d\\n\", i);\ni--;\n}\n```\n```c\nint i;\nfor (i= 10; i>0; i--){\nprintf(\"%d\\n\", i);\n}// fine del ciclo\n```",
        "hint": null,
        "correctAnswer": [
          ":"
        ],
        "options": [
          ":",
          ":",
          ":",
          ":"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "aa9a7499cb1b8c2349eaf285",
        "question": "Quale non \u00e8 una delle parole riservate in C standard?",
        "answer": "typeof",
        "explanation": "[Riferimento](https://www.ibm.com/docs/en/adfz/developer-for-zos/14.2.0?topic=programs-c-reserved-keywords)",
        "hint": null,
        "correctAnswer": [
          "typeof"
        ],
        "options": [
          "volatile",
          "typeof",
          "register",
          "typedef"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "242d28713520c4a14abc7645",
        "question": "Cosa restituisce il programma mostrato di seguito?\n```c\nint main(){\n    int a=1, b=2, c=3, d=4;\n    int x = a;\n    if (a>b)\n    if (b<c) x=b;\n    else x=c;\n    return(x);\n}\n```",
        "answer": "1",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "1"
        ],
        "options": [
          "1",
          "3",
          "2",
          "0"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "4b4a4e90ee684380c4258b9f",
        "question": "Utilizzando la dichiarazione Union di seguito, quanti byte di spazio di memoria occuperanno i dati di questo tipo?\n```c\nunion Cars {\n    char make[20];\n    char model[30];\n    short year;\n} car;\n```",
        "answer": "30",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "30"
        ],
        "options": [
          "32",
          "54",
          "30",
          "52"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "c62ddc80093c600bd56ea2f9",
        "question": "In questo esempio di codice, cosa non \u00e8 un problema per il compilatore C?\n```c\nmain(){\n    constant int PI = 3.14;\n    printf(\"%f\\n\", pi);\n}\n```",
        "answer": "Il valore di PI deve essere impostato su 3.141593, non 3.14",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "Il valore di PI deve essere impostato su 3.141593, non 3.14"
        ],
        "options": [
          "Il valore di PI deve essere impostato su 3.141593, non 3.14",
          "La dichiarazione di PI deve dire const, non constant.",
          "Il tipo di dato di PI deve essere float, non int.",
          "L'istruzione printf deve usare PI, non pi."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "7b921d386e738e2ab7782cdb",
        "question": "Qual \u00e8 il programma pi\u00f9 piccolo da compilare ed eseguire senza errori?",
        "answer": "int main() {return 0;}",
        "explanation": "[Riferimento](https://www.beningo.com/150-the-wolrds-shortest-c-program/)",
        "hint": null,
        "correctAnswer": [
          "int main() {return 0;}"
        ],
        "options": [
          "main()",
          "int main() {return 0;}",
          "main() { }",
          "main() { ; }"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "85034e57d83491d104600701",
        "question": "Cosa \u00e8 facoltativo in una dichiarazione di funzione?",
        "answer": "nomi dei parametri",
        "explanation": "> **Spiegazione:**\n> In tutti gli standard C moderni, i nomi dei parametri in una dichiarazione di funzione sono facoltativi.\n> Tuttavia, il significato di un elenco di parametri vuoto (`int f();`) differisce per standard:\n>\n> - **Prima di C23:** Dichiara una funzione con un numero non specificato di parametri (non un prototipo).\n> - **In C23:** Equivalente a `int f(void);` \u2014 dichiara una funzione che non accetta parametri.\n>\n> [Riferimento](https://en.cppreference.com/w/c/language/function_declaration)",
        "hint": null,
        "correctAnswer": [
          "nomi dei parametri"
        ],
        "options": [
          "tipo di dato dei parametri",
          "tipo di ritorno della funzione",
          "nomi dei parametri",
          "numero di parametri"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "d992fd26caa54c7097fa461b",
        "question": "C tratta tutti i dispositivi, come il display e la tastiera, come file. Quale file si apre automaticamente quando un programma viene eseguito?",
        "answer": "stdout",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "stdout"
        ],
        "options": [
          "stdout",
          "stdio.h",
          "default.h",
          "string.h"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "0f6d8273900369acc3f9f69c",
        "question": "In quale segmento avviene l'allocazione dinamica della memoria?",
        "answer": "heap",
        "explanation": "[Riferimento](http://www.it.uc3m.es/pbasanta/asng/course_notes/dynamic_memory_heap_en.html#:~:text=The%20dynamic%20memory%20that%20is,reads%20a%20set%20of%20words.)",
        "hint": null,
        "correctAnswer": [
          "heap"
        ],
        "options": [
          "Segmento BSS",
          "stack",
          "heap",
          "segmento dati"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "893aca3edb8d462ed2e269f1",
        "question": "Quale funzione utilizzi per deallocare la memoria?",
        "answer": "free()",
        "explanation": "[Riferimento](https://devdocs.io/c/memory/free)\n[Riferimento](https://www.tutorialspoint.com/c_standard_library/c_function_free.htm)",
        "hint": null,
        "correctAnswer": [
          "free()"
        ],
        "options": [
          "dalloc()",
          "dealloc()",
          "release()",
          "free()"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "0821825455fa3aad31278d13",
        "question": "Nel linguaggio C quali sono i blocchi di base che vengono costruiti insieme per scrivere un programma?",
        "answer": "token",
        "explanation": "[Riferimento](https://fresh2refresh.com/c-programming/c-tokens-identifiers-keywords/#:~:text=C%20tokens%20are%20the%20basic,are%20known%20as%20C%20tokens.)",
        "hint": null,
        "correctAnswer": [
          "token"
        ],
        "options": [
          "parole chiave",
          "identificatori",
          "token",
          "funzioni"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "a41625ca45b4d749bda41a29",
        "question": "Quando viene allocata la memoria per una variabile?",
        "answer": "durante la dichiarazione della variabile",
        "explanation": "[Riferimento](https://www.codingame.com/playgrounds/14589/how-to-play-with-pointers-in-c/dynamic-memory-allocation#:~:text=When%20a%20variable%20is%20declared,allocation%20or%20dynamic%20memory%20allocation.)",
        "hint": null,
        "correctAnswer": [
          "durante la dichiarazione della variabile"
        ],
        "options": [
          "durante l'assegnazione della variabile",
          "durante l'inizializzazione della variabile",
          "durante la dichiarazione della variabile",
          "durante la definizione della variabile"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "069552c9331d6b51c7491ec3",
        "question": "C utilizza il metodo di chiamata per valore per passare argomenti alle funzioni. Come puoi invocare il metodo di chiamata per riferimento?",
        "answer": "utilizzando i puntatori",
        "explanation": "[Riferimento](https://www.javatpoint.com/call-by-value-and-call-by-reference-in-c)",
        "hint": null,
        "correctAnswer": [
          "utilizzando i puntatori"
        ],
        "options": [
          "utilizzando i puntatori",
          "dichiarando le funzioni separatamente dalla loro definizione",
          "utilizzando funzioni ricorsive",
          "utilizzando variabili globali"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "bdcaab29aee09a09fe0abe72",
        "question": "Un'unione ti permette di memorizzare diversi `___` nello stesso `___`.",
        "answer": "Tipi di dati; Spazio di memoria",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "Tipi di dati; Spazio di memoria"
        ],
        "options": [
          "Oggetti; Struttura",
          "Variabili; Dichiarazione",
          "Tipi di dati; Spazio di memoria",
          "Array; File di intestazione"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "85864b7d7bbbf3507482953d",
        "question": "Qual \u00e8 l'output di questo programma?\n```c\nmain() {\n    char c1='a' , c2='A';\n    int i=c2-c1;\n    printf(\"%d\", i);\n}\n```",
        "answer": "-32",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "-32"
        ],
        "options": [
          "32",
          "Errore di runtime",
          "-32",
          "0"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "4b9ba1db1967fbf86bf51ba9",
        "question": "Qual \u00e8 la differenza tra le funzioni scanf() e sscanf()?",
        "answer": "La funzione scanf() legge dati formattati dalla tastiera; La funzione sscanf() legge input formattato da una stringa.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "La funzione scanf() legge dati formattati dalla tastiera; La funzione sscanf() legge input formattato da una stringa."
        ],
        "options": [
          "La funzione scanf() legge dati formattati come stringa; La funzione sscanf() legge input di stringa dallo schermo.",
          "La funzione scanf() legge dati formattati dalla tastiera; La funzione sscanf() legge input formattato da una stringa.",
          "La funzione scanf() legge dati di stringa dalla tastiera; La funzione sscanf() legge dati di stringa da una stringa.",
          "La funzione scanf() legge dati formattati da un file; La funzione sscanf() legge input da una stringa selezionata"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "546b4a2e87e35d05e8d93352",
        "question": "Quale non \u00e8 un comando valido con questa dichiarazione?\n```c\nchar *string[20] = { \"one\", \"two\", \"three\"};\n```",
        "answer": "`printf(\"%s\", string[1][2]);`",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "`printf(\"%s\", string[1][2]);`"
        ],
        "options": [
          "`printf(\"%c\", string[1][2]);`",
          "`printf(\"%s\", string[1][2]);`",
          "`printf(\"%s\", string[1]);`",
          "`printf(string[1]);`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "859482bab413ff9dc4ef1a01",
        "question": "A cosa \u00e8 equivalente l'espressione player->name?",
        "answer": "`(*player).name`",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "`(*player).name`"
        ],
        "options": [
          "`player.name`",
          "`(*player).name`",
          "`*player.name`",
          "`player.*name`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "7d2d1b6b95d5d919f48af06f",
        "question": "Quale programma compiler\u00e0 ed eseguir\u00e0 senza errori?",
        "answer": ":",
        "explanation": "```c\nmain() {\nfor(i=0; i<10; i++) ;\n}\n```\n```c\nmain() {\nint i=0;\nfor(; i<10; i++) ;\n}\n```\n```c\nmain() {\nint i;\nfor(i=0; i<j; i++) ;\n}\n```\n```c\nmain() {\nint i;\nfor (i= 10; i<10; i++)\n}\n```",
        "hint": null,
        "correctAnswer": [
          ":"
        ],
        "options": [
          ":",
          ":",
          ":",
          ":"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "cb8dc6fd6d3b22e72641c3df",
        "question": "Cosa restituisce questa chiamata di funzione?\n```c\n1 main() { float x = f1(10, 5); }\n2 float f1(int a, int b) { return (a/b); }\n```",
        "answer": "un errore del compilatore",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "un errore del compilatore"
        ],
        "options": [
          "2",
          "2.000000",
          "un errore di runtime",
          "un errore del compilatore"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "e7b6ddd7f51f8a43aa2bc6a1",
        "question": "Cosa crea questo programma?\n```c\n#include <stdio.h>\nint main() {\n    int *p = NULL;\n    return 0;\n}\n```",
        "answer": "un puntatore NULL",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "un puntatore NULL"
        ],
        "options": [
          "un errore di runtime",
          "un puntatore NULL",
          "un errore di compilazione",
          "un puntatore void"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "dfe9ac2b6fcb9fb39130c1f9",
        "question": "Qual \u00e8 un modo alternativo per scrivere l'espressione (\\*x).y?",
        "answer": "x->y",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "x->y"
        ],
        "options": [
          "Non esiste un equivalente.",
          "x->y",
          "\\*x->y",
          "y->x"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "bbd62bbde4259115cb83f21d",
        "question": "Gli errori di compilazione sono errori statici che possono essere trovati nel codice.",
        "answer": "nelle dichiarazioni e definizioni",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "nelle dichiarazioni e definizioni"
        ],
        "options": [
          "nelle dichiarazioni e definizioni",
          "nelle funzioni e espressioni",
          "nella sintassi e semantica",
          "negli oggetti e istruzioni"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "80e2b817a82b712f3d460e97",
        "question": "L'input e output (I/O) di file in C si basa pesantemente sul modo in cui viene fatto `___`?",
        "answer": "in Unix",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "in Unix"
        ],
        "options": [
          "in Unix",
          "in C++",
          "in C#",
          "in DOS"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "8aec3c841ea0cf4b9a6d3d67",
        "question": "Cosa restituisce la funzione strcmp(str1, str2);?",
        "answer": "0 se str1 e str2 sono uguali, un numero negativo se str1 \u00e8 minore di str2, un numero positivo se str1 \u00e8 maggiore di str2",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "0 se str1 e str2 sono uguali, un numero negativo se str1 \u00e8 minore di str2, un numero positivo se str1 \u00e8 maggiore di str2"
        ],
        "options": [
          "0 se str1 e str2 sono uguali, un numero negativo se str1 \u00e8 minore di str2, un numero positivo se str1 \u00e8 maggiore di str2",
          "true (1) se str1 e str2 sono uguali, false (0) se str1 e str2 non sono uguali",
          "true (1) se str1 e str2 sono uguali, NULL se str1 e str2 non sono uguali",
          "0 se str1 e str2 sono uguali, un numero negativo se str2 \u00e8 minore di str1, un numero positivo se str2 \u00e8 maggiore di str1"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "f923dd3829fac4d3712ec2c3",
        "question": "Qual \u00e8 l'output di questo programma?\n```c\nint a=10, b=20;\nint f1(a) { return(a*b); }\nmain() {\nprintf(\"%d\", f1(5));\n}\n```",
        "answer": "100",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "100"
        ],
        "options": [
          "100",
          "200",
          "5",
          "50"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "2a8efff9a901fc87d3885732",
        "question": "Quale _non_ \u00e8 un modo corretto per dichiarare una variabile stringa?",
        "answer": "`char string = \"Hello World\";`",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "`char string = \"Hello World\";`"
        ],
        "options": [
          "`char *string = \"Hello World\";`",
          "`char string = \"Hello World\";`",
          "`char string[20] = {'H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd'};`",
          "`char string[] = \"Hello World\";`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "f18a0da0b24bc79e614a792a",
        "question": "Quale scelta \u00e8 una guardia di inclusione per il file di intestazione mylib.h?",
        "answer": ":",
        "explanation": "```c\n#ifdef MYLIB_H\n#undef MYLIB_H\n// contenuto di mylib.h\n#endif /* MYLIB_H */\n```\n```c\n#ifndef MYLIB_H\n#define MYLIB_H\n// contenuto di mylib.h\n#endif /* MYLIB_H */\n```\n```c\n#define MYLIB_H\n#include \"mylib.h\"\n#undef MYLIB_H\n```\n```c\n#ifdef MYLIB_H\n#define MYLIB_H\n// contenuto di mylib.h\n#endif /* MYLIB_H */\n```",
        "hint": null,
        "correctAnswer": [
          ":"
        ],
        "options": [
          ":",
          ":",
          ":",
          ":"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "d2b1efe2635f0d6352dd6898",
        "question": "Quante volte viene eseguito il codice all'interno del ciclo while in questo programma?\n```c\nmain(){\n int x=1;\n while(x++<100){\n    x*=x;\n    if(x<10) continue;\n    if(x>50) break;\n }\n}\n```",
        "answer": "3",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "3"
        ],
        "options": [
          "100",
          "3",
          "5",
          "50"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "422da5b4fe220b20531d1b23",
        "question": "L'input e output (I/O) di file in C viene effettuato tramite cosa?",
        "answer": "chiamate di funzione",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "chiamate di funzione"
        ],
        "options": [
          "componenti guidati dalla sintassi",
          "interfacce native",
          "oggetti di sistema",
          "chiamate di funzione"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "1350a7ba0613f0163d08604b",
        "question": "Le direttive sono tradotte dal?",
        "answer": "Pre-processore",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "Pre-processore"
        ],
        "options": [
          "Pre-processore",
          "Compilatore",
          "Linker",
          "Editor"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "a9ceb7ad3b49dc7d8c1bfac2",
        "question": "Le principali strutture di ciclo nella programmazione C sono il ciclo for, il ciclo while e quale altro ciclo?",
        "answer": "do...while",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "do...while"
        ],
        "options": [
          "do...while",
          "for...in",
          "repeat...until",
          "do...until"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "a579528bc3773a7ea130aca4",
        "question": "Per impostazione predefinita, le funzioni C sono di che tipo di funzioni?",
        "answer": "globali",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "globali"
        ],
        "options": [
          "globali",
          "statiche",
          "di libreria",
          "di sistema"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "0f87e8a4aac08a9f3d64ae0a",
        "question": "Hai scritto una funzione che vuoi includere come membro della struttura 'a'. Come viene definito tale membro di struttura?",
        "answer": "B",
        "explanation": "```c\nstruct a {\nvoid *f1;\n};\n```\n```c\nstruct a {\nvoid (*f1)();\n};\n```\n```c\nstruct a {\n*(void *f1)();\n};\n```\n```c\nstruct a {\nvoid *f1();\n};\n```",
        "hint": null,
        "correctAnswer": [
          "B"
        ],
        "options": [
          "A",
          "B",
          "C",
          "D"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "fbe20fbc9a26e80f36a6c311",
        "question": "Una struttura dati Stack consente tutte le operazioni sui dati in una sola estremit\u00e0, rendendola che tipo di implementazione?",
        "answer": "LIFO",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "LIFO"
        ],
        "options": [
          "FIFO",
          "LIFO",
          "LILO",
          "LOLI"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "7e90666fda70977e533328b6",
        "question": "Cosa visualizza questo programma?\n```c\nmain(){\n    char *p = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    int i;\n    for (i=0;i<5;i++) *p++; *p++;\n    printf(\"%c\",*p++);\n}\n```",
        "answer": "G",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "G"
        ],
        "options": [
          "K",
          "M",
          "H",
          "G"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "7e2c02f3340aefa459dc981e",
        "question": "Descrivi la relazione tra lvalue e rvalue.",
        "answer": "Un lvalue pu\u00f2 apparire sul lato sinistro o destro di un'assegnazione; un rvalue pu\u00f2 apparire solo sul lato destro.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "Un lvalue pu\u00f2 apparire sul lato sinistro o destro di un'assegnazione; un rvalue pu\u00f2 apparire solo sul lato destro."
        ],
        "options": [
          "Un lvalue pu\u00f2 apparire solo sul lato sinistro di un'assegnazione; un rvalue pu\u00f2 apparire solo sul lato destro.",
          "Un lvalue pu\u00f2 apparire solo sul lato sinistro di un'assegnazione; un rvalue pu\u00f2 apparire sia sul lato sinistro che destro.",
          "Un lvalue e un rvalue possono apparire sia sul lato sinistro che destro di un'assegnazione.",
          "Un lvalue pu\u00f2 apparire sul lato sinistro o destro di un'assegnazione; un rvalue pu\u00f2 apparire solo sul lato destro."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "926eafc5d26fab60882a5385",
        "question": "Quale operatore viene utilizzato per accedere all'indirizzo di una variabile?",
        "answer": "`&`",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "`&`"
        ],
        "options": [
          "`%`",
          "`**`",
          "`*`",
          "`&`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "fcc781c7f606311e01437c85",
        "question": "Quale funzione add restituisce correttamente il valore aggiornato del risultato?",
        "answer": "A",
        "explanation": "```c\nvoid add (int a, int b, int *result)\n{\n*result = a+b;\n}\nmain()\n{\nint a = 10;\nint b = 20;\nint result = 0;\nadd(a,b,&result);\n}\n```\n```c\nvoid add (int a, int b, int result)\n{\nresult = a+b;\n}\nmain()\n{\nint a = 10;\nint b = 20;\nint result = 0;\nadd(a,b,result);\n}\n```\n```c\nvoid add (int a, int b, int *result)\n{\nresult = a+b;\n}\nmain()\n{\nint a = 10;\nint b = 20;\nint result = 0;\nadd(a,b,result);\n}\n```\n```c\nvoid add (int *a, int *b, int *result)\n{\nresult = a+b;\n}\nmain()\n{\nint a = 10;\nint b = 20;\nint result = 0;\nadd(*a,*b,*result);\n}\n```",
        "hint": null,
        "correctAnswer": [
          "A"
        ],
        "options": [
          "A",
          "B",
          "C",
          "D"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "ecc939558698e7b4e1481f54",
        "question": "Considera i numeri della serie di Fibonacci inferiori a 100: 0,1,1,2,3,5,8,13,21,34,55,89. Quale pezzo di codice produce la sequenza?",
        "answer": "C",
        "explanation": "```c\nvoid fibonacci(int a, int b)\n{\nint c = a+b;\nif(a>100)\nreturn;\nprintf(\"%d\", a);\nfibonacci(a,b);\n}\nint main()\n{\nfibonacci(0,1);\n}\n```\n```c\nvoid fibonacci(int a, int b)\n{\nint c = a+b;\nif(a>100)\nreturn;\nprintf(\"%d\", b);\nfibonacci(a,c);\n}\nint main()\n{\nfibonacci(0,1);\n}\n```\n```c\nvoid fibonacci(int a, int b)\n{\nint c = a+b;\nif(a>100)\nreturn;\nprintf(\"%d\", a);\nfibonacci(b,c);\n}\nint main()\n{\nfibonacci(0,1);\n}\n```\n```c\nvoid fibonacci(int a, int b)\n{\nint c = a+b;\nif(a>100)\nreturn;\nprintf(\"%d\", c);\nfibonacci(b,c);\n}\nint main()\n{\nfibonacci(0,1);\n}\n```",
        "hint": null,
        "correctAnswer": [
          "C"
        ],
        "options": [
          "A",
          "B",
          "C",
          "D"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "0532ff40461695773b4e15c0",
        "question": "Quale _non_ \u00e8 uno specificatore di classe di memorizzazione?",
        "answer": "`intern`",
        "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/language/storage_duration)",
        "hint": null,
        "correctAnswer": [
          "`intern`"
        ],
        "options": [
          "`intern`",
          "`extern`",
          "`register`",
          "`static`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "b8dc1a526205c42b4d589d16",
        "question": "Quale riga di codice, dopo l'esecuzione, risulta in `i` con il valore di 1?",
        "answer": "`for(i=1; i==10; i++);`",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "`for(i=1; i==10; i++);`"
        ],
        "options": [
          "`for(i=1; i<=1; i++);`",
          "`for(i=1; i=10; i++);`",
          "`for(i=1; i==10; i++);`",
          "`for(i=10; i>=1; i--);`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "49630d269db6d6ffaf99e635",
        "question": "Qual \u00e8 il valore della variabile c alla fine di questo programma?\n```\n1 main() {\n2   int a, b, c;\n3   a=10; b=50;\n4   c=a * b % a;\n5 }\n```",
        "answer": "0",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "0"
        ],
        "options": [
          "50",
          "5",
          "0",
          "500"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "49f2f0e6b8996f9bbade1e77",
        "question": "Quale _non_ \u00e8 uno dei tipi di dati di base in C?",
        "answer": "array",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "array"
        ],
        "options": [
          "long double",
          "unsigned char",
          "array",
          "float"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "e485a9b4fa16c0f7716579c6",
        "question": "Qual \u00e8 l'operatore di accesso ai membri per una struttura?",
        "answer": ".",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "."
        ],
        "options": [
          ",",
          "[]",
          ".",
          ":"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "820b296cffc337191a6c8344",
        "question": "Quale tipo di dato standard fornisce la dimensione di memorizzazione pi\u00f9 piccola e pu\u00f2 essere utilizzato nei calcoli?",
        "answer": "char",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "char"
        ],
        "options": [
          "char",
          "float",
          "int",
          "short"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "2e182820b42ab7093c8d4a1c",
        "question": "Cosa fa la funzione ctype tolower()?",
        "answer": "Converte una lettera maiuscola dell'alfabeto in minuscola.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "Converte una lettera maiuscola dell'alfabeto in minuscola."
        ],
        "options": [
          "Restituisce TRUE per le lettere minuscole dell'alfabeto.",
          "Assicura che l'output di testo utilizzi solo valori ASCII (da 0 a 127).",
          "Restituisce FALSE per le lettere minuscole dell'alfabeto.",
          "Converte una lettera maiuscola dell'alfabeto in minuscola."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "76d295d232e2cdcdcbe7dfe0",
        "question": "Il puntatore void _vptr_ \u00e8 assegnato all'indirizzo della variabile float _g_. Qual \u00e8 un modo valido per dereferenziare _vptr_ per assegnare il suo valore puntato a una variabile float chiamata _f_ pi\u00f9 avanti nel programma?\n```c\nfloat g;\nvoid *vptr=&g;\n```",
        "answer": "`f=*(float *)vptr;`",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "`f=*(float *)vptr;`"
        ],
        "options": [
          "`f=(float *)vptr;`",
          "`f=*(float *)vptr;`",
          "`f=*(float)vptr;`",
          "`f=(float)*vptr;`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "46f2bbfdf62a7ace3593d3cb",
        "question": "Le funzioni di allocazione dinamica della memoria sono definite in quale file di intestazione di sistema?",
        "answer": "stdlib.h",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "stdlib.h"
        ],
        "options": [
          "stdio.h",
          "stdlib.h",
          "limits.h",
          "stddef.h"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "473c1c0f78492e8586584ab8",
        "question": "Una funzione \u00e8 un insieme di **\\_**.",
        "answer": "istruzioni",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "istruzioni"
        ],
        "options": [
          "dichiarazioni",
          "istruzioni",
          "variabili",
          "oggetti"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "7308739734dc6df51d6893f7",
        "question": "In che modo le funzioni statiche differiscono dalle funzioni globali?",
        "answer": "Le funzioni statiche possono essere accessibili solo nel file in cui sono dichiarate.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "Le funzioni statiche possono essere accessibili solo nel file in cui sono dichiarate."
        ],
        "options": [
          "Le funzioni statiche devono essere dichiarate prima di essere definite.",
          "Le funzioni statiche devono essere dichiarate in un file di intestazione separato.",
          "Le funzioni statiche restituiscono sempre lo stesso valore.",
          "Le funzioni statiche possono essere accessibili solo nel file in cui sono dichiarate."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "ec017cb9f0fbe793e26bfc29",
        "question": "Quale esempio di codice crea la stringa \"Hello Mars\" nel buffer di memorizzazione `hello`.",
        "answer": ":",
        "explanation": "```c\nchar hello[25];\nstrcpy(hello, \"Hello \");\nstrcpy(hello, \"Mars\");\n```\n```c\nchar hello[25];\nchar *p;\nstrcpy(hello, \"Hello World\");\np = hello;\np +=6;\nstrcpy(p, \"Mars\");\n```\n```c\nchar *hello;\nstrcpy(hello, \"Hello World\");\nhello+=6;\nstrcpy(hello, \"Mars\");\n```\n```c\nchar hello[25];\nstrcpy(hello, \"Hello World\");\nstrcpy(*hello[6], \"Mars\");\n```",
        "hint": null,
        "correctAnswer": [
          ":"
        ],
        "options": [
          ":",
          ":",
          ":",
          ":"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "bac4a4cf2f2ad47153bfd834",
        "question": "Se utilizzi la funzione fopen() con la modalit\u00e0 \"a\", cosa succede se il file nominato non esiste?",
        "answer": "Il file viene creato e aperto per la scrittura.",
        "explanation": "[Riferimento](https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm)",
        "hint": null,
        "correctAnswer": [
          "Il file viene creato e aperto per la scrittura."
        ],
        "options": [
          "Il file viene creato e aperto per la lettura.",
          "Il file viene creato e aperto per la scrittura.",
          "La funzione fopen() restituisce un NULL indicando che l'operazione \u00e8 fallita.",
          "Il file viene creato e aperto sia per la scrittura che per la lettura"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "2b321e328f00386e132b31bf",
        "question": "Cosa restituisce questa funzione?\n```c\nint fl(int a, int b) { return(a>b?a:b); }\n```",
        "answer": "il valore pi\u00f9 grande dei due parametri passati",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "il valore pi\u00f9 grande dei due parametri passati"
        ],
        "options": [
          "errore del compilatore",
          "il valore pi\u00f9 piccolo dei due parametri passati",
          "errore di runtime",
          "il valore pi\u00f9 grande dei due parametri passati"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "a1618aac09e62e7979819d70",
        "question": "Quale opzione \u00e8 un nome di funzione valido?",
        "answer": "draw_star()",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "draw_star()"
        ],
        "options": [
          "draw_star()",
          "5times()",
          "upper-limit()",
          "auto()"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "337fd92fe4e8ca1b4c9728d1",
        "question": "Quale non \u00e8 una definizione di tipo valida di una struttura che contiene coordinate x e y come interi e che pu\u00f2 essere utilizzata come mostrato per la variabile denominata point?\n```c\ncoord point;\npoint.x = 9;\npoint.y = 3;\n```",
        "answer": ":",
        "explanation": "```c\nstruct coord{\nint x;\nint y;\n};\ntypedef struct coord coord;\n```\n```c\ntypedef struct coord{\nint x;\nint y;\n};\n```\n```c\ntypedef struct coord{\nint x;\nint y;\n} coord;\n```\n```c\ntypedef struct{\nint x;\nint y;\n} coord;\n```",
        "hint": null,
        "correctAnswer": [
          ":"
        ],
        "options": [
          ":",
          ":",
          ":",
          ":"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "6a4835ac0b1ea9c95bf2c733",
        "question": "Qual \u00e8 l'output del programma seguente?\n```c\n#include <stdio.h>\n#if X == 3\n    #define Y 3\n#else\n    #define Y 5\n#endif\nint main()\n{\n    printf(\"%d\", Y);\n    return 0;\n}\n```",
        "answer": "5",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "5"
        ],
        "options": [
          "3",
          "5",
          "3 o 5 a seconda dell'input",
          "Errore di compilazione"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "06245167ca08876ae0791192",
        "question": "Cosa allocano le funzioni malloc() e calloc()?",
        "answer": "memoria dinamica",
        "explanation": "[Calloc](https://devdocs.io/c/memory/calloc)\n[Malloc](https://devdocs.io/c/memory/malloc)",
        "hint": null,
        "correctAnswer": [
          "memoria dinamica"
        ],
        "options": [
          "memoria riallocata",
          "memoria statica",
          "memoria dinamica",
          "memoria frammentata"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "1ea40c634f783ebf4223aded",
        "question": "Devi determinare se una variabile stringa \u00e8 una sottostringa di un'altra stringa. Quale funzione della libreria standard C utilizzi?",
        "answer": "strstr(str1, str2);",
        "explanation": "[Riferimento](https://devdocs.io/c/string/byte/strstr)",
        "hint": null,
        "correctAnswer": [
          "strstr(str1, str2);"
        ],
        "options": [
          "substr(str1, str2);",
          "strstr(str1, str2);",
          "substring(str1, str2);",
          "strspn(str1, str2);"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "5df038b284941f53d9b016a4",
        "question": "Trova l'output del programma.\n```c\n#include <stdio.h>\n#define L 10\nint main(){\n    int a =10;\n    switch (a,a<<2){\n        case L:printf(\"a==L\");     break;\n        case L*2 : printf(\"a = L* 2\\n\");     break;\n        case L*4 : printf(\"a = L* 4\\n\");    break;\n        default: printf(\"Errore\\n\");\n    }\n}\n```",
        "answer": "`a=L*4`",
        "explanation": "[Riferimento](https://www.geeksforgeeks.org/left-shift-right-shift-operators-c-cpp/)",
        "hint": null,
        "correctAnswer": [
          "`a=L*4`"
        ],
        "options": [
          "`a=L*2`",
          "`a=L`",
          "`Errore`",
          "`a=L*4`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "f2b847f83a42f957e465b2dc",
        "question": "Prevedi l'output del seguente codice quando le variabili **intere** x \u00e8 inizializzata a 10, y a 2 e z a 0.\n```c\nz = x + y * x + 10 / 2 * x;\nprintf(\"il valore \u00e8 =%d\",z);\n```",
        "answer": "80",
        "explanation": "[Riferimento](https://www.informit.com/articles/article.aspx?p=2062174&seqNum=4)",
        "hint": null,
        "correctAnswer": [
          "80"
        ],
        "options": [
          "80",
          "170",
          "31.5",
          "6"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "ff21d4e580756f468f782e39",
        "question": "Qual sar\u00e0 l'output del seguente frammento di codice?\n```c\n#include <stdio.h>\nvoid solve() {\n    int x = 2;\n    printf(\"%d\", (x << 1) + (x >> 1));\n}\nint main() {\n    solve();\n\treturn 0;\n}\n```",
        "answer": "5",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "5"
        ],
        "options": [
          "5",
          "4",
          "2",
          "1"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "325ce1af6389875d2ef1f142",
        "question": "Qual \u00e8 l'output di questo programma?\n```c\nint a=20, b=10;\nint f1(a) {\n    return(a*b);\n}\nmain() {\n    printf(\"%d\", f1(5));\n}\n```",
        "answer": "50",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "50"
        ],
        "options": [
          "100",
          "200",
          "5",
          "50"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "9a2ac012d7060adc68b63311",
        "question": "Cos'\u00e8 il carattere /0?",
        "answer": "Carattere NULL",
        "explanation": "[Riferimento](<https://www.youth4work.com/Talent/C-Language/Forum/117150-what-is-the-use-of-a-0-character-in-c-language#:~:text=by%20using%20of%20null%20character(%27%5C0%27)%20it%20terminates%20the%20string%20untill%20the%20null%20character%20hit...%20which%20means%20comes%20out%20of%20the%20loop...%20In%20strings%20by%20default%20takes%20the%20null%20charater>)",
        "hint": null,
        "correctAnswer": [
          "Carattere NULL"
        ],
        "options": [
          "Stringa",
          "Carattere NULL",
          "ZERO",
          "Variabile"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "82de6f7b244a1df97f14db67",
        "question": "Qual \u00e8 l'output corretto per il seguente codice?\n```c\n#include&lt;stdio.h&gt;\n#include&lt;conio.h&gt;\nmain()\n{\n     int a=10, b=20;\n     clrscr();\n     printf(\"Prima dello scambio a=%d b=%d\",a,b);\n     a=a+b;\n     b=a-b;\n     a=a-b;\n     printf(\"nDopo lo scambio a=%d b=%d\",a,b);\n     getch();\n}\n```",
        "answer": "Prima a=10 b=20 , Dopo a=20 b=10",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "Prima a=10 b=20 , Dopo a=20 b=10"
        ],
        "options": [
          "Prima a=10 b=20 , Dopo a=10 b=10",
          "Prima a=10 b=10 , Dopo a=20 b=10",
          "Prima a=10 b=20 , Dopo a=20 b=20",
          "Prima a=10 b=20 , Dopo a=20 b=10"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "314b5843a3dd602a7c2cf037",
        "question": "Quale \u00e8 l'opzione errata che spiega la direttiva # pragma?",
        "answer": "#pragma startup non ci permette di specificare le funzioni chiamate all'avvio del programma.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "#pragma startup non ci permette di specificare le funzioni chiamate all'avvio del programma."
        ],
        "options": [
          "#pragma exit ci permette di specificare le funzioni chiamate all'uscita del programma.",
          "Questa \u00e8 una direttiva del preprocessore che pu\u00f2 essere utilizzata per attivare o disattivare determinate funzionalit\u00e0.",
          "#pragma startup non ci permette di specificare le funzioni chiamate all'avvio del programma.",
          "\u00c8 di due tipi #pragma startup, #pragma exit e pragma warn."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "3dd04572ecd40d127b96ecaf",
        "question": "Qual sar\u00e0 l'output del seguente frammento di codice?\n```c\n#include <stdio.h>\nunion School {\n    int age, rollNo;\n    double marks;\n};\nvoid solve() {\n    union School sc;\n    sc.age = 19;\n    sc.rollNo = 82;\n    sc.marks = 19.04;\n    printf(\"%d\", (int)sizeof(sc));\n}\nint main() {\n    solve();\n\treturn 0;\n}\n```",
        "answer": "8",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "8"
        ],
        "options": [
          "2",
          "4",
          "8",
          "10"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "7813262ecf5efec7dde8713b",
        "question": "Qual sar\u00e0 l'output del seguente frammento di codice?\n```c\n#include <stdio.h>\nstruct School {\n    int age, rollNo;\n};\nvoid solve() {\n    struct School sc;\n    sc.age = 19;\n    sc.rollNo = 82;\n    printf(\"%d %d\", sc.age, sc.rollNo);\n}\nint main() {\n    solve();\n\treturn 0;\n}\n```",
        "answer": "19 82",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "19 82"
        ],
        "options": [
          "19 82",
          "Errore di compilazione",
          "82 19",
          "Nessuna di queste"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "b6d431130dbefa986e2d9cde",
        "question": "Qual \u00e8 l'output del seguente frammento di codice?\n```c\nint main() {\n\tint sum = 2 + 4 / 2 + 6 * 2;\n\tprintf(\"%d\", sum);\n\treturn 0;\n}\n```",
        "answer": "16",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "16"
        ],
        "options": [
          "2",
          "15",
          "16",
          "18"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "9809324024d57abb2b51e393",
        "question": "Cosa significa la seguente dichiarazione?\n```\nint (*ptr)[10];\n```",
        "answer": "ptr \u00e8 un puntatore a un array di 10 interi",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "ptr \u00e8 un puntatore a un array di 10 interi"
        ],
        "options": [
          "ptr \u00e8 un array di puntatori a 10 interi",
          "ptr \u00e8 un puntatore a un array di 10 interi",
          "ptr \u00e8 un array di 10 interi",
          "ptr \u00e8 un puntatore a un array"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "b2ec0546c019d1696aa3bd92",
        "question": "Qual sar\u00e0 l'output del seguente frammento di codice?\n```c\n#include <stdio.h>\nvoid change(int,int);\nint main()\n{\n   int a=10,b=20;\n   change(a,b); //chiamata di una funzione passando i valori delle variabili.\n   printf(\"Valore di a \u00e8: %d\",a);\n   printf(\"\\n\");\n   printf(\"Valore di b \u00e8: %d\",b);\n   return 0;\n}\nvoid change(int x,int y)\n{\n   x=13;\n   y=17;\n}\n```",
        "answer": "10,20",
        "explanation": "**Spiegazione:** La funzione \"change\" cambier\u00e0 il valore di x e y solo all'interno del proprio ambito, quindi a e b non sono influenzati.",
        "hint": null,
        "correctAnswer": [
          "10,20"
        ],
        "options": [
          "10,20",
          "10,10",
          "20,20",
          "20,10"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "1f0a491c515c8cf0ebb9a6a4",
        "question": "Scegli vero o falso. Quando viene creata una variabile in C, viene assegnato un indirizzo di memoria alla variabile.",
        "answer": "Vero",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "Vero"
        ],
        "options": [
          "Vero",
          "Falso"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "2c8530737a6daaf38af4e0e6",
        "question": "Cosa stampa il seguente frammento di programma C?\n```c\n#include <stdio.h>\nint main()\n{\n    char c[] = \"GATE2011\";\n    char *p = c;\n    printf(\"%s\", p + p[3] -p[1]);\n    return 0;\n}\n```",
        "answer": "2011",
        "explanation": "**Spiegazione:** char c[ ] = \"GATE2011\"; poich\u00e9 char \\*p =c significa che p rappresenta l'indirizzo base della stringa \"GATE2011\" QUINDI p[3] \u00e8 'E' e p[1] \u00e8 'A'. Valore della sottoespressione p[3] \u2013 p[1] = valore ASCII di 'E' \u2013 valore ASCII di 'A' = 4. Quindi l'espressione p + p[3] \u2013 p[1] diventa ( p + 4) E (p+4) rappresenta l'indirizzo base della stringa \"2011\" printf(\"%s\", p + p[3] \u2013 p[1]) ; Quindi stamper\u00e0 2011",
        "hint": null,
        "correctAnswer": [
          "2011"
        ],
        "options": [
          "GATE 2011",
          "E2011",
          "2011",
          "01"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "4433375c8b2487009e265d3f",
        "question": "Qual \u00e8 l'output del seguente frammento di codice?\n```c\nint main() {\n\tint a = 5, b = 6, c;\n\tc = a++ + ++b;\n\tprintf(\"%d %d %d\", a, b, c);\n\treturn 0;\n}\n```",
        "answer": "6 7 12",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "6 7 12"
        ],
        "options": [
          "5 6 11",
          "6 7 12",
          "5 6 12",
          "6 6 12"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "9afc5f9616425623c225c7b5",
        "question": "Qual sar\u00e0 l'output del seguente segmento di programma C?\n```c\nchar inchar = 'A';\nswitch (inchar)\n{\ncase 'A' :\n\tprintf (\"scelta A \\n\") ;\ncase 'B' :\n\tprintf (\"scelta B \") ;\ncase 'C' :\ncase 'D' :\ncase 'E' :\ndefault:\n\tprintf (\"Nessuna scelta\") ;\n}\n```",
        "answer": "Scelta A",
        "explanation": "Scelta B Nessuna scelta",
        "hint": null,
        "correctAnswer": [
          "Scelta A"
        ],
        "options": [
          "Nessuna scelta",
          "Scelta A",
          "Scelta A",
          "Il programma non produce output perch\u00e9 \u00e8 errato"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "b28588b348c10e1dad136ebf",
        "question": "La variabile stringa str1 ha il valore di \"abc\" e la variabile stringa str2 ha il valore \"xyz\". Quali sono i valori di str1 e str2 dopo che questa istruzione \u00e8 stata eseguita?\n```c\nstrcpy(str1, str2);\n```",
        "answer": "str1: \"xyz\" ; str2: \"xyz\"",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "str1: \"xyz\" ; str2: \"xyz\""
        ],
        "options": [
          "str1: \"xyz\" ; str2: \"xyz\"",
          "str1: \"abc\" ; str2: \"xyz\"",
          "str1: \"xyz\" ; str2: \"abc\"",
          "str1: \"abc\" ; str2: \"abc\""
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "0d8f78201adbf751142c52a4",
        "question": "Quale non \u00e8 un comando valido con questa dichiarazione?\n```c\nchar *string[20] = { \"one\", \"two\", \"three\"};\n```",
        "answer": "`printf(\"%s\", string[1][2]);`",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "`printf(\"%s\", string[1][2]);`"
        ],
        "options": [
          "`printf(\"%c\", string[1][2]);`",
          "`printf(\"%s\", string[1][2]);`",
          "`printf(\"%s\", string[1]);`",
          "`printf(string[1]);`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "15778ba0713fcf25858b400c",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nint x = 5;\nint y = ++x + x++;\nprintf(\"%d %d\", x, y);\n```",
        "answer": "7 12",
        "explanation": "**Spiegazione:**\nPrima, ++x incrementa x a 6 e usa 6 nell'espressione. Poi x++ usa 6 e incrementa x a 7 dopo. Quindi y = 6 + 6 = 12, e x diventa 7.\n[Riferimento](https://en.cppreference.com/w/c/language/operator_precedence)",
        "hint": null,
        "correctAnswer": [
          "7 12"
        ],
        "options": [
          "6 11",
          "7 12",
          "7 11",
          "6 12"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "09639ac436e881d84752db10",
        "question": "Cosa indica la parola chiave `volatile` in C?",
        "answer": "La variabile pu\u00f2 essere modificata da fattori esterni",
        "explanation": "**Spiegazione:**\nLa parola chiave `volatile` dice al compilatore che il valore di una variabile pu\u00f2 essere modificato da fattori esterni (hardware, interrupt, altri thread), quindi il compilatore non dovrebbe ottimizzare via le letture/scritture su di essa.\n[Riferimento](https://en.cppreference.com/w/c/language/volatile)",
        "hint": null,
        "correctAnswer": [
          "La variabile pu\u00f2 essere modificata da fattori esterni"
        ],
        "options": [
          "La variabile non pu\u00f2 essere modificata",
          "La variabile pu\u00f2 essere modificata da fattori esterni",
          "La variabile \u00e8 memorizzata in ROM",
          "La variabile \u00e8 una costante"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "25d2e61f556a30253e83f7ea",
        "question": "Qual \u00e8 lo scopo della parola chiave `restrict` in C99?",
        "answer": "Per indicare che un puntatore \u00e8 l'unico modo per accedere a un oggetto",
        "explanation": "**Spiegazione:**\nLa parola chiave `restrict` \u00e8 un qualificatore di tipo che pu\u00f2 essere applicato ai puntatori. Dice al compilatore che per la durata del puntatore, solo esso o un valore derivato direttamente da esso sar\u00e0 utilizzato per accedere all'oggetto a cui punta. Ci\u00f2 consente determinate ottimizzazioni del compilatore.\n[Riferimento](https://en.cppreference.com/w/c/language/restrict)",
        "hint": null,
        "correctAnswer": [
          "Per indicare che un puntatore \u00e8 l'unico modo per accedere a un oggetto"
        ],
        "options": [
          "Per indicare che un puntatore \u00e8 l'unico modo per accedere a un oggetto",
          "Per limitare l'ambito di una variabile",
          "Per impedire la modifica di una variabile",
          "Per limitare l'accesso alla funzione"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "9cdce461084f153acaf6da19",
        "question": "Qual \u00e8 la differenza tra `malloc()` e `calloc()`?",
        "answer": "calloc inizializza la memoria allocata a zero, malloc no",
        "explanation": "**Spiegazione:**\n`calloc()` alloca memoria e inizializza tutti i byte a zero, mentre `malloc()` alloca memoria ma la lascia non inizializzata. `calloc()` accetta anche due argomenti (numero di elementi e dimensione di ciascun elemento) mentre `malloc()` ne accetta uno (dimensione totale in byte).\n[Riferimento](https://en.cppreference.com/w/c/memory/calloc)",
        "hint": null,
        "correctAnswer": [
          "calloc inizializza la memoria allocata a zero, malloc no"
        ],
        "options": [
          "malloc \u00e8 pi\u00f9 veloce di calloc",
          "calloc inizializza la memoria allocata a zero, malloc no",
          "malloc pu\u00f2 allocare pi\u00f9 memoria di calloc",
          "Non c'\u00e8 differenza"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "6547a2b8c22755a81931b118",
        "question": "Cos'\u00e8 un puntatore pendente?",
        "answer": "Un puntatore che punta a memoria liberata o eliminata",
        "explanation": "**Spiegazione:**\nUn puntatore pendente \u00e8 un puntatore che punta a memoria che \u00e8 stata liberata o eliminata. L'accesso a tale puntatore porta a un comportamento indefinito.\n[Riferimento](https://en.wikipedia.org/wiki/Dangling_pointer)",
        "hint": null,
        "correctAnswer": [
          "Un puntatore che punta a memoria liberata o eliminata"
        ],
        "options": [
          "Un puntatore che punta a NULL",
          "Un puntatore che punta a memoria liberata o eliminata",
          "Un puntatore che non \u00e8 stato inizializzato",
          "Un puntatore che punta a una costante"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "4e7893665928c1d596bd02b9",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nint arr[] = {1, 2, 3, 4, 5};\nprintf(\"%d\", *(arr + 3));\n```",
        "answer": "4",
        "explanation": "**Spiegazione:**\n`arr` \u00e8 un puntatore al primo elemento. `arr + 3` punta al 4\u00b0 elemento (indice 3). L'operatore `*` lo dereferenzia per ottenere il valore 4.\n[Riferimento](https://en.cppreference.com/w/c/language/operator_member_access)",
        "hint": null,
        "correctAnswer": [
          "4"
        ],
        "options": [
          "1",
          "2",
          "3",
          "4"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "929ec165ef9da4e5036779f8",
        "question": "Cosa fa la parola chiave `static` quando applicata a una funzione?",
        "answer": "Limita l'ambito della funzione al file corrente",
        "explanation": "**Spiegazione:**\nQuando `static` \u00e8 applicato a una funzione, limita il collegamento della funzione a collegamento interno, il che significa che pu\u00f2 essere chiamata solo dall'interno della stessa unit\u00e0 di traduzione (file sorgente).\n[Riferimento](https://en.cppreference.com/w/c/language/storage_duration)",
        "hint": null,
        "correctAnswer": [
          "Limita l'ambito della funzione al file corrente"
        ],
        "options": [
          "Limita l'ambito della funzione al file corrente",
          "Rende la funzione pi\u00f9 veloce",
          "Impedisce la chiamata della funzione",
          "Rende la funzione inline"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "87d56394628179ac8e24bb11",
        "question": "Qual \u00e8 la dimensione di un puntatore in un sistema a 64 bit?",
        "answer": "8 byte",
        "explanation": "**Spiegazione:**\nSu un sistema a 64 bit, i puntatori sono tipicamente 8 byte (64 bit) indipendentemente da cosa puntano. La dimensione \u00e8 determinata dall'architettura del sistema, non dal tipo puntato.\n[Riferimento](https://en.cppreference.com/w/c/language/pointer)",
        "hint": null,
        "correctAnswer": [
          "8 byte"
        ],
        "options": [
          "4 byte",
          "8 byte",
          "16 byte",
          "Dipende da cosa punta"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "ecd39ebde329af87f72fc3ef",
        "question": "Qual \u00e8 lo scopo di `typedef`?",
        "answer": "Per creare un alias per un tipo di dato esistente",
        "explanation": "**Spiegazione:**\n`typedef` crea un alias (nome alternativo) per un tipo di dato esistente. Non crea un nuovo tipo, solo un nuovo nome per uno esistente.\n[Riferimento](https://en.cppreference.com/w/c/language/typedef)",
        "hint": null,
        "correctAnswer": [
          "Per creare un alias per un tipo di dato esistente"
        ],
        "options": [
          "Per definire un nuovo tipo di dato",
          "Per creare un alias per un tipo di dato esistente",
          "Per dichiarare una variabile",
          "Per definire una macro"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "53cf38a8d8fc55c0d97c535a",
        "question": "Cos'\u00e8 una perdita di memoria?",
        "answer": "Quando la memoria allocata non viene liberata",
        "explanation": "**Spiegazione:**\nUna perdita di memoria si verifica quando la memoria allocata dinamicamente (tramite `malloc`, `calloc`, ecc.) non viene liberata utilizzando `free()`, causando al programma di consumare sempre pi\u00f9 memoria nel tempo.\n[Riferimento](https://en.wikipedia.org/wiki/Memory_leak)",
        "hint": null,
        "correctAnswer": [
          "Quando la memoria allocata non viene liberata"
        ],
        "options": [
          "Quando un puntatore punta a memoria non valida",
          "Quando la memoria allocata non viene liberata",
          "Quando una variabile esce dall'ambito",
          "Quando si verifica uno stack overflow"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "fbd0e17599b6c48d8448cfea",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nint x = 10;\nint *p = &x;\n*p = 20;\nprintf(\"%d\", x);\n```",
        "answer": "20",
        "explanation": "**Spiegazione:**\n`p` punta a `x`. `*p = 20` modifica il valore all'indirizzo a cui p punta, che \u00e8 `x`. Quindi `x` diventa 20.\n[Riferimento](https://en.cppreference.com/w/c/language/pointer)",
        "hint": null,
        "correctAnswer": [
          "20"
        ],
        "options": [
          "10",
          "20",
          "Indirizzo di x",
          "Indefinito"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "fc4e52e31abfa766f3f53d44",
        "question": "Cosa restituisce sempre `sizeof(char)` in C?",
        "answer": "1",
        "explanation": "**Spiegazione:**\nPer definizione nello standard C, `sizeof(char)` \u00e8 sempre 1. Questa \u00e8 l'unit\u00e0 fondamentale di dimensione in C, e tutte le altre dimensioni sono multipli di essa.\n[Riferimento](https://en.cppreference.com/w/c/language/sizeof)",
        "hint": null,
        "correctAnswer": [
          "1"
        ],
        "options": [
          "1",
          "2",
          "4",
          "Dipende dal sistema"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "6983c550a2595f6b0296cc4c",
        "question": "Qual \u00e8 la differenza tra `++i` e `i++`?",
        "answer": "++i incrementa prima dell'uso, i++ incrementa dopo l'uso",
        "explanation": "**Spiegazione:**\n`++i` (pre-incremento) incrementa la variabile e restituisce il nuovo valore. `i++` (post-incremento) restituisce il valore corrente e poi incrementa la variabile.\n[Riferimento](https://en.cppreference.com/w/c/language/operator_incdec)",
        "hint": null,
        "correctAnswer": [
          "++i incrementa prima dell'uso, i++ incrementa dopo l'uso"
        ],
        "options": [
          "++i incrementa prima dell'uso, i++ incrementa dopo l'uso",
          "++i \u00e8 pi\u00f9 veloce di i++",
          "i++ pu\u00f2 essere usato solo nei cicli",
          "Non c'\u00e8 differenza"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "454ce5f3862815140cbaa391",
        "question": "Cos'\u00e8 un segmentation fault?",
        "answer": "Un errore causato dall'accesso a memoria non valida",
        "explanation": "**Spiegazione:**\nUn segmentation fault (segfault) si verifica quando un programma cerca di accedere a memoria a cui non \u00e8 autorizzato ad accedere, come dereferenziare un puntatore NULL o accedere a memoria liberata.\n[Riferimento](https://en.wikipedia.org/wiki/Segmentation_fault)",
        "hint": null,
        "correctAnswer": [
          "Un errore causato dall'accesso a memoria non valida"
        ],
        "options": [
          "Un errore di sintassi",
          "Un errore causato dall'accesso a memoria non valida",
          "Un errore di compilazione",
          "Un avviso"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "36d07d5525dd903ab2307ece",
        "question": "Qual \u00e8 lo scopo della parola chiave `const` con i puntatori?\n```c\nconst int *p;\n```",
        "answer": "Il valore puntato non pu\u00f2 essere modificato tramite p",
        "explanation": "**Spiegazione:**\n`const int *p` significa che p punta a un intero costante - non puoi modificare il valore tramite p, ma puoi cambiare dove punta p. Per `int * const p`, il puntatore stesso \u00e8 costante.\n[Riferimento](https://en.cppreference.com/w/c/language/const)",
        "hint": null,
        "correctAnswer": [
          "Il valore puntato non pu\u00f2 essere modificato tramite p"
        ],
        "options": [
          "Il valore puntato non pu\u00f2 essere modificato tramite p",
          "Il puntatore p non pu\u00f2 essere modificato",
          "Sia il puntatore che il valore sono costanti",
          "Non ha effetto"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "9cbc2447e33a99d7784774a6",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nint arr[5] = {1, 2, 3};\nprintf(\"%d\", arr[4]);\n```",
        "answer": "0",
        "explanation": "**Spiegazione:**\nQuando un array \u00e8 parzialmente inizializzato, gli elementi rimanenti sono automaticamente inizializzati a 0. Quindi arr[3] e arr[4] sono entrambi 0.\n[Riferimento](https://en.cppreference.com/w/c/language/array_initialization)",
        "hint": null,
        "correctAnswer": [
          "0"
        ],
        "options": [
          "0",
          "3",
          "Valore spazzatura",
          "Errore di compilazione"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "b95d5d76631292882df13747",
        "question": "Cosa fa la parola chiave `extern`?",
        "answer": "Dichiara una variabile che \u00e8 definita altrove",
        "explanation": "**Spiegazione:**\n`extern` dichiara una variabile o funzione che \u00e8 definita in un altro file sorgente o pi\u00f9 avanti nello stesso file. Dice al compilatore che la definizione esiste altrove.\n[Riferimento](https://en.cppreference.com/w/c/language/extern)",
        "hint": null,
        "correctAnswer": [
          "Dichiara una variabile che \u00e8 definita altrove"
        ],
        "options": [
          "Rende una variabile esterna al programma",
          "Dichiara una variabile che \u00e8 definita altrove",
          "Esporta una variabile ad altri programmi",
          "Crea una variabile globale"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "4238520b9bbd9a69aa70988b",
        "question": "Qual \u00e8 la differenza tra `struct` e `union`?",
        "answer": "i membri struct hanno memoria separata, i membri union condividono la memoria",
        "explanation": "**Spiegazione:**\nIn una `struct`, ogni membro ha la propria posizione di memoria. In un'`union`, tutti i membri condividono la stessa posizione di memoria e solo un membro pu\u00f2 contenere un valore alla volta. La dimensione di un'unione \u00e8 la dimensione del suo membro pi\u00f9 grande.\n[Riferimento](https://en.cppreference.com/w/c/language/union)",
        "hint": null,
        "correctAnswer": [
          "i membri struct hanno memoria separata, i membri union condividono la memoria"
        ],
        "options": [
          "i membri struct hanno memoria separata, i membri union condividono la memoria",
          "struct \u00e8 pi\u00f9 veloce di union",
          "union pu\u00f2 avere pi\u00f9 membri di struct",
          "Non c'\u00e8 differenza"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "bd7578488db565fdadc3436c",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nint x = 5;\nprintf(\"%d\", x << 2);\n```",
        "answer": "20",
        "explanation": "**Spiegazione:**\nL'operatore `<<` \u00e8 uno spostamento bit a sinistra. `x << 2` sposta i bit di x a sinistra di 2 posizioni, che \u00e8 equivalente a moltiplicare per 2^2 = 4. Quindi 5 \\* 4 = 20.\n[Riferimento](https://en.cppreference.com/w/c/language/operator_arithmetic)",
        "hint": null,
        "correctAnswer": [
          "20"
        ],
        "options": [
          "5",
          "7",
          "20",
          "10"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "5bad6d7db450562aedaef984",
        "question": "Cos'\u00e8 un puntatore a funzione?",
        "answer": "Un puntatore che memorizza l'indirizzo di una funzione",
        "explanation": "**Spiegazione:**\nUn puntatore a funzione \u00e8 una variabile che memorizza l'indirizzo di una funzione. Pu\u00f2 essere utilizzato per chiamare la funzione indirettamente o passare funzioni come argomenti ad altre funzioni.\n[Riferimento](https://en.cppreference.com/w/c/language/pointer#Pointers_to_functions)",
        "hint": null,
        "correctAnswer": [
          "Un puntatore che memorizza l'indirizzo di una funzione"
        ],
        "options": [
          "Un puntatore al valore di ritorno di una funzione",
          "Un puntatore che memorizza l'indirizzo di una funzione",
          "Una funzione che restituisce un puntatore",
          "Un puntatore all'interno di una funzione"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "e9614dc8a884bcd632c59764",
        "question": "Cosa rappresenta `NULL` in C?",
        "answer": "Una costante puntatore null",
        "explanation": "**Spiegazione:**\n`NULL` \u00e8 una macro che rappresenta una costante puntatore null. \u00c8 tipicamente definito come `((void*)0)` o semplicemente `0`. Indica che un puntatore non punta a nessuna posizione di memoria valida.\n[Riferimento](https://en.cppreference.com/w/c/types/NULL)",
        "hint": null,
        "correctAnswer": [
          "Una costante puntatore null"
        ],
        "options": [
          "Il numero zero",
          "Una costante puntatore null",
          "Una stringa vuota",
          "Un valore indefinito"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "1496f6226eafbc186035246f",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nint x = 10, y = 20;\nint *p1 = &x, *p2 = &y;\n*p1 = *p2;\nprintf(\"%d %d\", x, y);\n```",
        "answer": "20 20",
        "explanation": "**Spiegazione:**\n`*p1 = *p2` copia il valore puntato da p2 (che \u00e8 20) nella posizione puntata da p1 (che \u00e8 x). Quindi x diventa 20, y rimane 20.\n[Riferimento](https://en.cppreference.com/w/c/language/pointer)",
        "hint": null,
        "correctAnswer": [
          "20 20"
        ],
        "options": [
          "10 20",
          "20 20",
          "10 10",
          "20 10"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "1af90c8b69668aff4936ff1f",
        "question": "Qual \u00e8 lo scopo della direttiva `#pragma`?",
        "answer": "Per fornire istruzioni specifiche del compilatore",
        "explanation": "**Spiegazione:**\n`#pragma` \u00e8 una direttiva del preprocessore che fornisce informazioni aggiuntive al compilatore. \u00c8 definito dall'implementazione e utilizzato per funzionalit\u00e0 specifiche del compilatore.\n[Riferimento](https://en.cppreference.com/w/c/preprocessor/impl)",
        "hint": null,
        "correctAnswer": [
          "Per fornire istruzioni specifiche del compilatore"
        ],
        "options": [
          "Per includere file di intestazione",
          "Per definire macro",
          "Per fornire istruzioni specifiche del compilatore",
          "Per dichiarare variabili"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "505c0671478926d833afd898",
        "question": "Qual \u00e8 la differenza tra `break` e `continue`?",
        "answer": "break esce dal ciclo, continue salta alla prossima iterazione",
        "explanation": "**Spiegazione:**\n`break` termina completamente il ciclo e continua l'esecuzione dopo il ciclo. `continue` salta il resto dell'iterazione corrente e passa alla prossima iterazione del ciclo.\n[Riferimento](https://en.cppreference.com/w/c/language/break)",
        "hint": null,
        "correctAnswer": [
          "break esce dal ciclo, continue salta alla prossima iterazione"
        ],
        "options": [
          "break esce dal ciclo, continue salta alla prossima iterazione",
          "break \u00e8 pi\u00f9 veloce di continue",
          "continue esce dal ciclo, break salta l'iterazione",
          "Non c'\u00e8 differenza"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "9ec16523253b00a601bff28b",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nint arr[] = {1, 2, 3, 4, 5};\nprintf(\"%d\", sizeof(arr) / sizeof(arr[0]));\n```",
        "answer": "5",
        "explanation": "**Spiegazione:**\n`sizeof(arr)` d\u00e0 la dimensione totale dell'array in byte. `sizeof(arr[0])` d\u00e0 la dimensione di un elemento. Dividendoli si ottiene il numero di elementi: 5.\n[Riferimento](https://en.cppreference.com/w/c/language/sizeof)",
        "hint": null,
        "correctAnswer": [
          "5"
        ],
        "options": [
          "4",
          "5",
          "20",
          "1"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "8785d84dddf70522f11e01df",
        "question": "Cos'\u00e8 un puntatore void?",
        "answer": "Un puntatore generico che pu\u00f2 puntare a qualsiasi tipo di dato",
        "explanation": "**Spiegazione:**\nUn puntatore `void*` \u00e8 un puntatore generico che pu\u00f2 puntare a qualsiasi tipo di dato. Deve essere convertito al tipo appropriato prima di essere dereferenziato.\n[Riferimento](https://en.cppreference.com/w/c/language/pointer)",
        "hint": null,
        "correctAnswer": [
          "Un puntatore generico che pu\u00f2 puntare a qualsiasi tipo di dato"
        ],
        "options": [
          "Un puntatore che punta a nulla",
          "Un puntatore generico che pu\u00f2 puntare a qualsiasi tipo di dato",
          "Un puntatore a funzioni void",
          "Un puntatore non valido"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "9c30d29acdd92ebc95102d20",
        "question": "Cosa suggerisce la parola chiave `register` al compilatore?",
        "answer": "Di memorizzare una variabile in un registro CPU per un accesso pi\u00f9 veloce",
        "explanation": "**Spiegazione:**\nLa parola chiave `register` suggerisce (ma non garantisce) che il compilatore dovrebbe memorizzare la variabile in un registro CPU per un accesso pi\u00f9 veloce. I compilatori moderni spesso ignorano questo suggerimento e prendono le proprie decisioni di ottimizzazione.\n[Riferimento](https://en.cppreference.com/w/c/language/storage_duration)",
        "hint": null,
        "correctAnswer": [
          "Di memorizzare una variabile in un registro CPU per un accesso pi\u00f9 veloce"
        ],
        "options": [
          "Di rendere una variabile globale",
          "Di memorizzare una variabile in un registro CPU per un accesso pi\u00f9 veloce",
          "Di proteggere una variabile dalla modifica",
          "Di allocare memoria sull'heap"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "8f897519fe16135a3fd349c6",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nint x = 5;\nint y = (x > 3) ? 10 : 20;\nprintf(\"%d\", y);\n```",
        "answer": "10",
        "explanation": "**Spiegazione:**\nQuesto \u00e8 l'operatore ternario. Poich\u00e9 x > 3 \u00e8 vero, y viene assegnato 10.\n[Riferimento](https://en.cppreference.com/w/c/language/operator_other)",
        "hint": null,
        "correctAnswer": [
          "10"
        ],
        "options": [
          "10",
          "20",
          "5",
          "3"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "f7efcaec47bf04a4a9c4dec9",
        "question": "Qual \u00e8 la differenza tra `malloc()` e `realloc()`?",
        "answer": "realloc ridimensiona la memoria precedentemente allocata",
        "explanation": "**Spiegazione:**\n`malloc()` alloca nuova memoria. `realloc()` cambia la dimensione di un blocco di memoria precedentemente allocato, potenzialmente spostandolo in una nuova posizione se necessario.\n[Riferimento](https://en.cppreference.com/w/c/memory/realloc)",
        "hint": null,
        "correctAnswer": [
          "realloc ridimensiona la memoria precedentemente allocata"
        ],
        "options": [
          "malloc \u00e8 pi\u00f9 veloce di realloc",
          "realloc ridimensiona la memoria precedentemente allocata",
          "malloc inizializza la memoria, realloc no",
          "Non c'\u00e8 differenza"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "1503a0ff37291555765acaf5",
        "question": "Cos'\u00e8 un'enumerazione in C?",
        "answer": "Un tipo definito dall'utente costituito da costanti intere nominate",
        "explanation": "**Spiegazione:**\nUn'enumerazione (`enum`) \u00e8 un tipo definito dall'utente che consiste in un insieme di costanti intere nominate. Rende il codice pi\u00f9 leggibile dando nomi significativi ai valori interi.\n[Riferimento](https://en.cppreference.com/w/c/language/enum)",
        "hint": null,
        "correctAnswer": [
          "Un tipo definito dall'utente costituito da costanti intere nominate"
        ],
        "options": [
          "Un costrutto di ciclo",
          "Un tipo definito dall'utente costituito da costanti intere nominate",
          "Una funzione che conta gli elementi",
          "Un array di costanti"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "00935ebfc95818c4423fa702",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nint x = 10;\nint y = x++ + ++x;\nprintf(\"%d %d\", x, y);\n```",
        "answer": "12 22",
        "explanation": "**Spiegazione:**\nPrima, x++ usa 10 e incrementa x a 11. Poi ++x incrementa x a 12 e usa 12. Quindi y = 10 + 12 = 22, e x \u00e8 12.\n[Riferimento](https://en.cppreference.com/w/c/language/operator_incdec)",
        "hint": null,
        "correctAnswer": [
          "12 22"
        ],
        "options": [
          "11 21",
          "12 22",
          "12 21",
          "11 22"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "552111f53f3ab468deef23af",
        "question": "Qual \u00e8 lo scopo della macro `assert()`?",
        "answer": "Per verificare le assunzioni e terminare se false",
        "explanation": "**Spiegazione:**\n`assert()` \u00e8 una macro utilizzata per il debug. Verifica se una condizione \u00e8 vera. Se falsa, stampa un messaggio di errore e termina il programma. \u00c8 tipicamente disabilitata nelle build di rilascio.\n[Riferimento](https://en.cppreference.com/w/c/error/assert)",
        "hint": null,
        "correctAnswer": [
          "Per verificare le assunzioni e terminare se false"
        ],
        "options": [
          "Per assegnare valori alle variabili",
          "Per verificare le assunzioni e terminare se false",
          "Per affermare la dominanza su altre funzioni",
          "Per creare asserzioni nella documentazione"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "916a909506eb5246a8ff4b5c",
        "question": "Qual \u00e8 la differenza tra `fgets()` e `gets()`?",
        "answer": "fgets \u00e8 pi\u00f9 sicura perch\u00e9 limita la dimensione dell'input",
        "explanation": "**Spiegazione:**\n`gets()` non \u00e8 sicura perch\u00e9 non controlla la dimensione del buffer, portando a vulnerabilit\u00e0 di buffer overflow. `fgets()` ti permette di specificare il numero massimo di caratteri da leggere, rendendola pi\u00f9 sicura. `gets()` \u00e8 stata rimossa dallo standard C11.\n[Riferimento](https://en.cppreference.com/w/c/io/fgets)",
        "hint": null,
        "correctAnswer": [
          "fgets \u00e8 pi\u00f9 sicura perch\u00e9 limita la dimensione dell'input"
        ],
        "options": [
          "fgets \u00e8 pi\u00f9 veloce di gets",
          "fgets \u00e8 pi\u00f9 sicura perch\u00e9 limita la dimensione dell'input",
          "gets pu\u00f2 leggere da qualsiasi file",
          "Non c'\u00e8 differenza"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "1f566e806a986538cf2b2e5d",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nint x = 5;\nint *p = &x;\nprintf(\"%p %p\", (void*)&x, (void*)p);\n```",
        "answer": "Stesso indirizzo stampato due volte",
        "explanation": "**Spiegazione:**\n`&x` d\u00e0 l'indirizzo di x, e p memorizza l'indirizzo di x. Entrambi stampano lo stesso indirizzo (in formato esadecimale a causa di %p).\n[Riferimento](https://en.cppreference.com/w/c/io/fprintf)",
        "hint": null,
        "correctAnswer": [
          "Stesso indirizzo stampato due volte"
        ],
        "options": [
          "Stesso indirizzo stampato due volte",
          "Due indirizzi diversi",
          "Errore di compilazione",
          "5 5"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "ae94a58a43e393c7a02978d8",
        "question": "Cos'\u00e8 una direttiva del preprocessore?",
        "answer": "Un'istruzione al preprocessore prima della compilazione",
        "explanation": "**Spiegazione:**\nLe direttive del preprocessore (come #include, #define, #ifdef) sono istruzioni elaborate prima della compilazione vera e propria. Iniziano con # e sono gestite dal preprocessore.\n[Riferimento](https://en.cppreference.com/w/c/preprocessor)",
        "hint": null,
        "correctAnswer": [
          "Un'istruzione al preprocessore prima della compilazione"
        ],
        "options": [
          "Una funzione che elabora dati",
          "Un'istruzione al preprocessore prima della compilazione",
          "Una direttiva dal processore",
          "Un tipo di ciclo"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "61afccb15c37b82a5d0f61bf",
        "question": "Qual \u00e8 l'output di questo codice?\n{% raw %}\n```c\nint arr[3][3] = {{1,2,3},{4,5,6},{7,8,9}};\nprintf(\"%d\", arr[1][2]);\n```\n{% endraw %}",
        "answer": "6",
        "explanation": "**Spiegazione:**\n`arr[1][2]` accede alla riga 1 (seconda riga: {4,5,6}), colonna 2 (terzo elemento: 6).\n[Riferimento](https://en.cppreference.com/w/c/language/array)",
        "hint": null,
        "correctAnswer": [
          "6"
        ],
        "options": [
          "5",
          "6",
          "8",
          "9"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "28651456ddda9ab1017871c1",
        "question": "Qual \u00e8 lo scopo della funzione `memset()`?",
        "answer": "Per riempire un blocco di memoria con un valore specifico",
        "explanation": "**Spiegazione:**\n`memset()` riempie un blocco di memoria con un valore byte specificato. \u00c8 comunemente usato per inizializzare array o strutture a zero.\n[Riferimento](https://en.cppreference.com/w/c/string/byte/memset)",
        "hint": null,
        "correctAnswer": [
          "Per riempire un blocco di memoria con un valore specifico"
        ],
        "options": [
          "Per allocare memoria",
          "Per riempire un blocco di memoria con un valore specifico",
          "Per copiare memoria",
          "Per liberare memoria"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "ff9daf75df6c2f318bf475cb",
        "question": "Qual \u00e8 la differenza tra `strcpy()` e `strncpy()`?",
        "answer": "strncpy limita il numero di caratteri copiati",
        "explanation": "**Spiegazione:**\n`strcpy()` copia l'intera stringa incluso il terminatore null. `strncpy()` copia al massimo n caratteri, fornendo protezione contro il buffer overflow.\n[Riferimento](https://en.cppreference.com/w/c/string/byte/strncpy)",
        "hint": null,
        "correctAnswer": [
          "strncpy limita il numero di caratteri copiati"
        ],
        "options": [
          "strcpy \u00e8 pi\u00f9 veloce",
          "strncpy limita il numero di caratteri copiati",
          "strcpy pu\u00f2 copiare qualsiasi tipo di dato",
          "Non c'\u00e8 differenza"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "4ac14bcc1c690215e06c47f2",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nint x = 10;\nint y = 3;\nprintf(\"%d\", x % y);\n```",
        "answer": "1",
        "explanation": "**Spiegazione:**\nL'operatore `%` \u00e8 l'operatore modulo. 10 % 3 d\u00e0 il resto di 10 diviso per 3, che \u00e8 1.\n[Riferimento](https://en.cppreference.com/w/c/language/operator_arithmetic)",
        "hint": null,
        "correctAnswer": [
          "1"
        ],
        "options": [
          "1",
          "3",
          "0",
          "10"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "8c641fc87709646cf453cc62",
        "question": "Cos'\u00e8 una macro in C?",
        "answer": "Una direttiva del preprocessore che definisce un frammento di codice",
        "explanation": "**Spiegazione:**\nUna macro \u00e8 definita usando #define e rappresenta un frammento di codice che viene sostituito dal preprocessore prima della compilazione. Pu\u00f2 essere una costante o un costrutto simile a una funzione.\n[Riferimento](https://en.cppreference.com/w/c/preprocessor/replace)",
        "hint": null,
        "correctAnswer": [
          "Una direttiva del preprocessore che definisce un frammento di codice"
        ],
        "options": [
          "Una funzione grande",
          "Una direttiva del preprocessore che definisce un frammento di codice",
          "Un tipo di variabile",
          "Un costrutto di ciclo"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "d28a6ee95c53762fc079059b",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nint x = 5;\nint y = 10;\nint z = (x > y) ? x : y;\nprintf(\"%d\", z);\n```",
        "answer": "10",
        "explanation": "**Spiegazione:**\nL'operatore ternario verifica se x > y. Poich\u00e9 \u00e8 falso (5 non \u00e8 maggiore di 10), a z viene assegnato il valore di y, che \u00e8 10.\n[Riferimento](https://en.cppreference.com/w/c/language/operator_other)",
        "hint": null,
        "correctAnswer": [
          "10"
        ],
        "options": [
          "5",
          "10",
          "1",
          "0"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "cb9cbc0025a62ba83bc13123",
        "question": "Qual \u00e8 lo scopo della funzione `free()`?",
        "answer": "Per deallocare memoria allocata dinamicamente",
        "explanation": "**Spiegazione:**\n`free()` dealloca la memoria che era stata precedentemente allocata da `malloc()`, `calloc()` o `realloc()`. \u00c8 essenziale per prevenire perdite di memoria.\n[Riferimento](https://en.cppreference.com/w/c/memory/free)",
        "hint": null,
        "correctAnswer": [
          "Per deallocare memoria allocata dinamicamente"
        ],
        "options": [
          "Per liberare risorse CPU",
          "Per deallocare memoria allocata dinamicamente",
          "Per liberare variabili dall'ambito",
          "Per cancellare lo schermo"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "09ed5d48e5b460baf12082ad",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nchar str[] = \"Hello\";\nprintf(\"%d\", strlen(str));\n```",
        "answer": "5",
        "explanation": "**Spiegazione:**\n`strlen()` restituisce la lunghezza della stringa escludendo il terminatore null. \"Hello\" ha 5 caratteri.\n[Riferimento](https://en.cppreference.com/w/c/string/byte/strlen)",
        "hint": null,
        "correctAnswer": [
          "5"
        ],
        "options": [
          "6",
          "5",
          "4",
          "Indefinito"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "a0cf21c12a32470873038110",
        "question": "Cos'\u00e8 una variabile statica all'interno di una funzione?",
        "answer": "Una variabile che mantiene il suo valore tra le chiamate di funzione",
        "explanation": "**Spiegazione:**\nUna variabile statica all'interno di una funzione mantiene il suo valore tra le chiamate di funzione. \u00c8 inizializzata solo una volta ed esiste per la durata del programma.\n[Riferimento](https://en.cppreference.com/w/c/language/storage_duration)",
        "hint": null,
        "correctAnswer": [
          "Una variabile che mantiene il suo valore tra le chiamate di funzione"
        ],
        "options": [
          "Una variabile che non pu\u00f2 cambiare",
          "Una variabile che mantiene il suo valore tra le chiamate di funzione",
          "Una variabile memorizzata in ROM",
          "Una variabile globale"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "51144c376a2536bbe1a45c04",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nint arr[] = {1, 2, 3, 4, 5};\nint *p = arr + 2;\nprintf(\"%d\", *p);\n```",
        "answer": "3",
        "explanation": "**Spiegazione:**\n`arr + 2` punta al terzo elemento (indice 2). Dereferenziandolo con `*p` si ottiene il valore 3.\n[Riferimento](https://en.cppreference.com/w/c/language/operator_member_access)",
        "hint": null,
        "correctAnswer": [
          "3"
        ],
        "options": [
          "1",
          "2",
          "3",
          "4"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "2721152c666f6d2e8eeca410",
        "question": "Qual \u00e8 la differenza tra `printf()` e `sprintf()`?",
        "answer": "sprintf scrive su una stringa, printf scrive su stdout",
        "explanation": "**Spiegazione:**\n`printf()` scrive output formattato su stdout (console). `sprintf()` scrive output formattato su un buffer di stringa di caratteri.\n[Riferimento](https://en.cppreference.com/w/c/io/fprintf)",
        "hint": null,
        "correctAnswer": [
          "sprintf scrive su una stringa, printf scrive su stdout"
        ],
        "options": [
          "printf \u00e8 pi\u00f9 veloce",
          "sprintf scrive su una stringa, printf scrive su stdout",
          "sprintf pu\u00f2 stampare solo stringhe",
          "Non c'\u00e8 differenza"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "d2642c38bd43ee786a3cbf59",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nint x = 5;\nprintf(\"%d\", x & 3);\n```",
        "answer": "1",
        "explanation": "**Spiegazione:**\nL'operatore `&` \u00e8 AND bit a bit. 5 in binario \u00e8 101, 3 \u00e8 011. 101 & 011 = 001 = 1.\n[Riferimento](https://en.cppreference.com/w/c/language/operator_arithmetic)",
        "hint": null,
        "correctAnswer": [
          "1"
        ],
        "options": [
          "5",
          "3",
          "1",
          "8"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "4c6ca3d9fd99bf38aa9a003b",
        "question": "Cos'\u00e8 una guardia di intestazione?",
        "answer": "Un costrutto del preprocessore per prevenire l'inclusione multipla",
        "explanation": "**Spiegazione:**\nLe guardie di intestazione (usando #ifndef, #define, #endif) impediscono che un file di intestazione venga incluso pi\u00f9 volte nella stessa unit\u00e0 di compilazione, il che causerebbe errori di ridefinizione.\n[Riferimento](https://en.cppreference.com/w/c/preprocessor/conditional)",
        "hint": null,
        "correctAnswer": [
          "Un costrutto del preprocessore per prevenire l'inclusione multipla"
        ],
        "options": [
          "Una funzionalit\u00e0 di sicurezza",
          "Un costrutto del preprocessore per prevenire l'inclusione multipla",
          "Una funzione che protegge le intestazioni",
          "Un tipo di commento"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "c1c0682558193d409a7f4389",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nint x = 10;\nint y = 20;\nint *p = &x;\np = &y;\nprintf(\"%d\", *p);\n```",
        "answer": "20",
        "explanation": "**Spiegazione:**\nInizialmente p punta a x. Poi `p = &y` fa puntare p a y. `*p` dereferenzia p per ottenere il valore di y, che \u00e8 20.\n[Riferimento](https://en.cppreference.com/w/c/language/pointer)",
        "hint": null,
        "correctAnswer": [
          "20"
        ],
        "options": [
          "10",
          "20",
          "Indirizzo di x",
          "Indirizzo di y"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "c6e15bea060d1111982ffc4f",
        "question": "Qual \u00e8 lo scopo della funzione `memcpy()`?",
        "answer": "Per copiare un blocco di memoria dalla sorgente alla destinazione",
        "explanation": "**Spiegazione:**\n`memcpy()` copia n byte dalla memoria sorgente alla memoria di destinazione. \u00c8 pi\u00f9 veloce della copia elemento per elemento ma non gestisce regioni di memoria sovrapposte (usa `memmove()` per quello).\n[Riferimento](https://en.cppreference.com/w/c/string/byte/memcpy)",
        "hint": null,
        "correctAnswer": [
          "Per copiare un blocco di memoria dalla sorgente alla destinazione"
        ],
        "options": [
          "Per allocare memoria",
          "Per copiare un blocco di memoria dalla sorgente alla destinazione",
          "Per confrontare blocchi di memoria",
          "Per liberare memoria"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "8ad1d18d624bb8e7ff2c4987",
        "question": "Qual \u00e8 l'output di questo codice?\n```c\nint x = 5;\nprintf(\"%d\", x | 3);\n```",
        "answer": "7",
        "explanation": "**Spiegazione:**\nL'operatore `|` \u00e8 OR bit a bit. 5 in binario \u00e8 101, 3 \u00e8 011. 101 | 011 = 111 = 7.\n[Riferimento](https://en.cppreference.com/w/c/language/operator_arithmetic)",
        "hint": null,
        "correctAnswer": [
          "7"
        ],
        "options": [
          "3",
          "5",
          "7",
          "8"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "916f2d076e7203a225f0f54f",
        "question": "Qual \u00e8 la differenza tra `strcmp()` e `strncmp()`?",
        "answer": "strncmp confronta solo i primi n caratteri",
        "explanation": "**Spiegazione:**\n`strcmp()` confronta stringhe intere. `strncmp()` confronta al massimo n caratteri, il che \u00e8 utile per confrontare prefissi di stringhe o limitare la lunghezza del confronto.\n[Riferimento](https://en.cppreference.com/w/c/string/byte/strncmp)",
        "hint": null,
        "correctAnswer": [
          "strncmp confronta solo i primi n caratteri"
        ],
        "options": [
          "strcmp distingue maiuscole/minuscole, strncmp no",
          "strncmp confronta solo i primi n caratteri",
          "strcmp \u00e8 pi\u00f9 veloce",
          "Non c'\u00e8 differenza"
        ],
        "nature": "ChooseOne",
        "attachments": []
      }
    ]
  },
  "meta": {
    "source": "c-(programming-language)/c-(programming-language)-quiz-it.md",
    "language": "it",
    "generatedAt": "2025-12-09T14:56:14.134698+00:00",
    "warnings": []
  }
}