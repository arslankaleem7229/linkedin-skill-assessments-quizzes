{
  "quizz": {
    "id": "68f69b845e3034aba6721754",
    "title": "C++",
    "description": "Seeded from c++/c++-quiz-fr.md",
    "createdById": "seed-user",
    "questions": [
      {
        "id": "57359ab0840a42c07d815f0e",
        "question": "What is the output of this code?\n```cpp\nvector<int> v(22);\nbool b = (v[6]);\nprintf(\"%d\", !b);\n```",
        "answer": "1",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["1"],
        "options": ["False", "0", "1", "This code has an error."],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "3e8f30ba9603763af90876f3",
        "question": "Which of the following is a reason why using this line is considered a bad practice? (_Alternative_: Why is using this line considered a bad practice?)\n```cpp\nusing namespace std;\n```",
        "answer": "If the code uses a function defined in two different libraries with the same prototype but possibly with different implementations, there will be a compilation error due to ambiguity.",
        "explanation": "[Reference](https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/)",
        "hint": null,
        "correctAnswer": [
          "If the code uses a function defined in two different libraries with the same prototype but possibly with different implementations, there will be a compilation error due to ambiguity."
        ],
        "options": [
          "The compiled code is always bigger because of all of the imported symbols.",
          "If the code uses a function defined in two different libraries with the same prototype but possibly with different implementations, there will be a compilation error due to ambiguity.",
          "It automatically includes all header files in the standard library (cstdint, cstdlib, cstdio, iostream, etc).",
          "It causes the compiler to enforce the exclusive inclusion of header files belonging to the standard library, generating a compilation error when a different header file is included."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "d0a23d82b4ccf6c61831dc3f",
        "question": "What is the smallest size a variable of the type child_t may occupy in memory?\n```cpp\ntypedef struct{\n    unsigned int  age    : 4;\n    unsigned char gender : 1;\n    unsigned int  size   : 2;\n}child_t;\n```",
        "answer": "1 byte.",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/bit_field)",
        "hint": null,
        "correctAnswer": ["1 byte."],
        "options": ["7 bits.", "25 bytes.", "1 bit.", "1 byte."],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "7d65b0c3c9aa2b020b390e73",
        "question": "What are the vectors v1 and v2 after executing the code?\n```cpp\nstd::vector<int> v1{1,2,3},v2;\nv2=v1;\nv1.push_back(4);\nv2.push_back(5);\n```",
        "answer": "v1:{1,2,3,4}; v2:{1,2,3,5};",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["v1:{1,2,3,4}; v2:{1,2,3,5};"],
        "options": [
          "Error",
          "v1:{1,2,3,4}; v2:{5};",
          "v1:{1,2,3,4,5}; v2:{1,2,3,4,5};",
          "v1:{1,2,3,4}; v2:{1,2,3,5};"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "6c349a22dac213d9461d0e01",
        "question": "Which of the following is a true statement about the difference between pointers and iterators?",
        "answer": "Incrementing an iterator always means accessing the next element in the container(if any), no matter the container. Incrementing the pointer means pointing to the next element in memory, not always the next element.",
        "explanation": "[Reference](https://stackoverflow.com/a/31128162)",
        "hint": null,
        "correctAnswer": [
          "Incrementing an iterator always means accessing the next element in the container(if any), no matter the container. Incrementing the pointer means pointing to the next element in memory, not always the next element."
        ],
        "options": [
          "While pointers are variables that hold memory addresses, iterators are generic functions used to traverse containers. This function allows the programmer to implement read and write code as the container is traversed.",
          "Incrementing an iterator always means accessing the next element in the container(if any), no matter the container. Incrementing the pointer means pointing to the next element in memory, not always the next element.",
          "Pointers are variables that hold memory address whereas iterator is unsigned integers that refer to offsets in arrays.",
          "All iterators are implemented with pointers so all iterators are pointers but not all pointers are iterators."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "6157acf85446ccda5969a32e",
        "question": "What's the storage occupied by u1?\n```cpp\nunion {\n    uint16_t a;\n    uint32_t b;\n    int8_t c;\n} u1;\n```",
        "answer": "4 bytes",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/union)",
        "hint": null,
        "correctAnswer": ["4 bytes"],
        "options": ["4 bytes", "7 bytes", "8 bytes", "2 bytes"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "ce8d06497be38b09d7c8d9f1",
        "question": "Which of the following operator can be overloaded?",
        "answer": "`new`",
        "explanation": "[Reference](https://www.tutorialspoint.com/operators-that-cannot-be-overloaded-in-cplusplus)",
        "hint": null,
        "correctAnswer": ["`new`"],
        "options": ["`?:`", "`new`", "`::`", "`.`"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "09a25be9f90bdb56a27fd47e",
        "question": "Which of the following shows the contents of the vector pointed by v1 and v2 after running this code?\n```cpp\nstd:: vector<int> *v1 = new std::vector<int>({1,2,3});\nstd:: vector<int> *v2;\nv2=v1;\nv1->push_back(4);\nv2->push_back(5);\n```",
        "answer": "`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`",
        "explanation": "v1 and v2 point to the same vector.",
        "hint": null,
        "correctAnswer": ["`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`"],
        "options": [
          "`*v1:{1,2,3,4}; *v2:{5};`",
          "`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`",
          "Error",
          "`*v1:{1,2,3,4}; *v2:{1,2,3,5};`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "74f1db4878f4af63bb8c50ec",
        "question": "Which of the following is not a difference between a class and a struct?",
        "answer": "Template type parameters can be declared with classes, but not with the struct keyword.",
        "explanation": "Templates can be used with both classes and structs\n[Reference](https://docs.microsoft.com/en-us/cpp/cpp/struct-cpp?view=msvc-170)\n[Reference](https://www.fluentcpp.com/2017/06/13/the-real-difference-between-struct-class/)",
        "hint": null,
        "correctAnswer": [
          "Template type parameters can be declared with classes, but not with the struct keyword."
        ],
        "options": [
          "Because structs are part of the C programming language, there is some complexity between C and C++ structs. This is not the case with classes.",
          "Classes may have member functions; structs are private.",
          "The default access specifier for members of a struct is public, whereas, for members of the class, it is private.",
          "Template type parameters can be declared with classes, but not with the struct keyword."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "de02a926534d454b1714d7dd",
        "question": "Suppose you need to keep a data struct with permission to access some resource based on the days of the week, but you can't use a bool variable for each day. You need to use one bit per day of the week. Which of the following is a correct implementation of a structure with bit fields for this application?",
        "answer": "A",
        "explanation": "```cpp\ntypedef struct {\nint sunday:1;\nint monday:1;\n// more days\nint friday:1;\nint saturday:1;\n} weekdays;\n```\n```cpp\ntypedef char[7]: weekdays;\n```\n```cpp\ntypedef struct {\nbit sunday:1;\nbit monday:1;\n// more days\nbit friday:1;\nbit saturday:1;\n} weekdays;\n```\n```cpp\ntypedef struct {\nbit sunday;\nbit monday;\n// more days\nbit friday;\nbit saturday;\n} weekdays;\n```\n[Reference](https://en.cppreference.com/w/cpp/language/bit_field) _NOTE_: Correct syntax is that each variable size is 1 bit. `bit` is not a type in C++.",
        "hint": null,
        "correctAnswer": ["A"],
        "options": ["A", "B", "C", "D"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "4c707a182e1fb2d69d8eaecc",
        "question": "What is an lvalue?",
        "answer": "It's a location value, meaning a memory address suitable for assigning to a pointer or reference.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "It's a location value, meaning a memory address suitable for assigning to a pointer or reference."
        ],
        "options": [
          "It's a constant expression, meaning an expression composed of constants and operations.",
          "It's an expression that represents an object with an address.",
          "It's an expression suitable for the left-hand side operand in a binary operation.",
          "It's a location value, meaning a memory address suitable for assigning to a pointer or reference."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "b2831fb05965a9f2c26feafc",
        "question": "What does auto type specifier do in this line of code (since C++11)?\n```cpp\nauto x = 4000.22;\n```",
        "answer": "It specifies that the type of x will be deduced from the initializer - in this case, double.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "It specifies that the type of x will be deduced from the initializer - in this case, double."
        ],
        "options": [
          "It specifies that the type of x will be deduced from the initializer - in this case, double.",
          "It specifies that the type of x is automatic meaning that it can be assigned different types of data throughout the program.",
          "It specifies that x is a variable with automatic storage duration.",
          "It specifies that more memory will be allocated for x in case it needs more space, avoiding loss of data due to overflow."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "8573540800522b76862f7b2b",
        "question": "A class template is a \\_?",
        "answer": "class written with the generic programming paradigm, specifying behavior in terms of type parameter rather than specific type.",
        "explanation": "[Reference](https://www.mygreatlearning.com/blog/templates-in-cpp/)",
        "hint": null,
        "correctAnswer": [
          "class written with the generic programming paradigm, specifying behavior in terms of type parameter rather than specific type."
        ],
        "options": [
          "class written with the generic programming paradigm, specifying behavior in terms of type parameter rather than specific type.",
          "blank superclass intended for inheritance and polymorphism.",
          "class that only consists of a member variable, with no constructor, destructor, or member functions.",
          "skeleton source code for a class where the programmer has to fill in specific parts to define the data types and algorithms used."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "280b6dc5f751005037d0cb18",
        "question": "What is the ternary operator equivalent to this code snippet?\n```cpp\nif(x)\n    y=a;\nelse\n    y=b;\n```",
        "answer": "`y=x?a:b;`",
        "explanation": "[Reference](https://www.w3schools.com/cpp/cpp_conditions_shorthand.asp)",
        "hint": null,
        "correctAnswer": ["`y=x?a:b;`"],
        "options": ["`y=a?b:x;`", "`y=if(x?a:b);`", "`y=(x&a)?a:(x&b)?b:0;`", "`y=x?a:b;`"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "813878b1639cc41a32ee7a09",
        "question": "What is the output of the code given below?\n```cpp\n#include <iostream>\nint main(){\n    int x=10, y=20;\n    std::cout << \"x = \" << x++ << \" and y = \" << --y << std::endl;\n    std::cout << \"x = \" << x-- << \" and y = \" << ++y << std::endl;\n    return(0);\n}\n```",
        "answer": "`x = 10 and y = 19`",
        "explanation": "`x = 11 and y = 19`\n`x = 10 and y = 20`\n`x = 11 and y = 20`\n`x = 10 and y = 19`",
        "hint": null,
        "correctAnswer": ["`x = 10 and y = 19`"],
        "options": [
          "`x = 10 and y = 20`",
          "`x = 11 and y = 19`",
          "`x = 10 and y = 19`",
          "`x = 11 and y = 20`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "c6580282381a1d975be9bbda",
        "question": "What is the meaning of the two parts specified between parentheses in a range-based for loop, separated by a colon?",
        "answer": "The first is a variable declaration that will hold an element in a sequence. The second is the sequence to traverse.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "The first is a variable declaration that will hold an element in a sequence. The second is the sequence to traverse."
        ],
        "options": [
          "The first is a variable declaration that will hold an element in a sequence. The second is the sequence to traverse.",
          "The first is an iterator, and the second is the increment value to be added to the iterator.",
          "The first is the iterating variable. The second is a `std::pair` that specifies the range (start and end) in which the variable will iterate.",
          "The first is a container object. The second is a `std::pair` that specifies the range (start and end) in which the elements will be accessed within the loop."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "277847213c740400c3769e4f",
        "question": "What is the output of the code given below?\n```cpp\nint8_t a=200;\nuint8_t b=100;\nif(a>b)\n    std::cout<<\"greater\";\nelse\n    std::cout<<\"less\";\n```",
        "answer": "less",
        "explanation": "Note: a variant of the question below.",
        "hint": null,
        "correctAnswer": ["less"],
        "options": [
          "There is no output because there is an exception when comparing an int8_t with a uint8_t.",
          "greater",
          "less",
          "There is no output because there is a compiler error."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "f2ef03098c0583e77a2f039d",
        "question": "What is the output of this block of code?\n```cpp\nint8_t a=200;\nuint8_t b=100;\nstd::cout<<\"a=\"<<(int)a;\nstd::cout<<\", b=\"<<(int)b;\n```",
        "answer": "a=-56, b=100",
        "explanation": "Note: Implicit conversion from 'int' to 'int8_t' (aka 'signed char') changes value from 200 to -56",
        "hint": null,
        "correctAnswer": ["a=-56, b=100"],
        "options": ["a=-56, b=100", "a=-55, b=100", "a=200, b=-156", "a=200, b=100"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "3f52105716d57c3234985bff",
        "question": "What is the output after executing this code snippet?\n```cpp\nint x=5, y=2;\nif(x & y) {\n    /*_part A_*/\n}\nelse {\n    /*_part B_*/\n}\n```",
        "answer": "Part B executes because (x & y) results in 0, or false.",
        "explanation": "[Reference](https://stackoverflow.com/questions/63867765/dont-understand-why-if-5-2-is-false)",
        "hint": null,
        "correctAnswer": ["Part B executes because (x & y) results in 0, or false."],
        "options": [
          "Part A executes because x==5 (true) and y==2 (true), thus the AND operation evaluates as true.",
          "Part B executes because (x & y) results in 0, or false.",
          "Part A executes because (x & y) results in a nonzero value, or true.",
          "Part B executes because the statement (x & y) is invalid, thus false."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "1ac15e06e9f00672be691174",
        "question": "What is a valid definition for the `get_length` function, which returns the length of a null-terminated string?",
        "answer": "A",
        "explanation": "```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str[count++]);\nreturn count-1;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str!=NULL){\ncount++;\nstr++;\n}\nreturn count;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile((*str)++)\ncount++;\nreturn count;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str++)\ncount++;\nreturn count;\n}\n```",
        "hint": null,
        "correctAnswer": ["A"],
        "options": ["A", "B", "C", "D"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "522105f92ede7813fa7abdd8",
        "question": "Which STL class is the best fit for implementing a collection of data that is always ordered so that the pop operation always gets the greatest of the elements? Suppose you are interested only in push and pop operations.",
        "answer": "`std::priority_queue`",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["`std::priority_queue`"],
        "options": ["`std::list`", "`std::vector`", "`std::priority_queue`", "`std::map`"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "dbb63894a067a7bceab19d46",
        "question": "What is the meaning of the three sections specified between parentheses in a for loop separated by semicolons?",
        "answer": "The first is the initialization block, the second is the condition to iterate, and the third is the increment block.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "The first is the initialization block, the second is the condition to iterate, and the third is the increment block."
        ],
        "options": [
          "The first is the iterating variable name, the second is the number of times to iterate, and the third is the desired increment or decrement (specified with a signed integer).",
          "The first is the initialization block, the second is the condition to iterate, and the third is the increment block.",
          "The first is the iterating variable, the second is the container in which it should operate, and the third is an exit condition to abort at any time.",
          "The first is the iterating variable name, the second is the starting value for the iterating variable, and the third is the stop value (the last value plus one)."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "c2ca17fe963f171f8773a124",
        "question": "What does this code print?\n```cpp\nint i = 0;\nprintf(\"%d\", i++);\nprintf(\"%d\", i--);\nprintf(\"%d\", ++i);\nprintf(\"%d\", --i);\n```",
        "answer": "0,1,1,0",
        "explanation": "[Reference](https://www.geeksforgeeks.org/pre-increment-and-post-increment-in-c/)",
        "hint": null,
        "correctAnswer": ["0,1,1,0"],
        "options": ["0,1,1,0", "0,1,0,1", "0,0,1,0", "1,0,1,0"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "090c6dad93c557fd2fc368c0",
        "question": "What is true about the variable named `ptr`?\n```cpp\nvoid *ptr;\n```",
        "answer": "It is a pointer to a value with no specific type, so it may be cast to point to any type.",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/pointer)",
        "hint": null,
        "correctAnswer": [
          "It is a pointer to a value with no specific type, so it may be cast to point to any type."
        ],
        "options": [
          "It is a pointer initialized at NULL.",
          "It is a pointer to a void function.",
          "That declaration causes a compiler error, as pointers must specify a type.",
          "It is a pointer to a value with no specific type, so it may be cast to point to any type."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "ee6e064aabad8eb7400973fd",
        "question": "What is the output of the code given below?\n```cpp\nint c=3; char d='A';\nstd::printf(\"c is %d and d is %c\",c,d);\n```",
        "answer": "c is 3 and d is A",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["c is 3 and d is A"],
        "options": [
          "c is d and d is c",
          "c is A and d is 3",
          "c is 3 and d is A",
          "c is c and d is d"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "b01d3b9e5bc3a0f3b4bf8c6d",
        "question": "What is the output of this code?\n```cpp\nprintf(\"1/2 = %f\",(float)(1/2));\n```",
        "answer": "1/2 = 0.000000",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["1/2 = 0.000000"],
        "options": ["1/2 = 0.499999", "1/2 = 0", "1/2 = 0.000000", "1/2 = 0.5"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "7e4499c667886a9e4a46df66",
        "question": "What is the difference between a public and a private class member?",
        "answer": "Public members can be accessed by any function. Private members can be accessed only by the same class's member functions and the friends of the class.",
        "explanation": "[Reference](https://www.geeksforgeeks.org/difference-between-public-and-private-in-c-with-example/)",
        "hint": null,
        "correctAnswer": [
          "Public members can be accessed by any function. Private members can be accessed only by the same class's member functions and the friends of the class."
        ],
        "options": [
          "Public members are the same as global variables, so every part of the code has access to them. Private members are the same as automatic variables, so only their class has access to them.",
          "Public members are made accessible to any running application. Private members are made accessible only to the application where the object is instantiated.",
          "Public members will be compiled as shared variables in a multithreaded environment. Private members will be compiled as Thread-local variables.",
          "Public members can be accessed by any function. Private members can be accessed only by the same class's member functions and the friends of the class."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "022eb92f8410c9e3c6324b8c",
        "question": "What is the value of `x` after executing this code?\n```cpp\nint x=10, a=-3;\nx+=a;\n```",
        "answer": "7",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["7"],
        "options": ["3", "7", "-3", "13"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "f43c5ffce213982bf5a5d7c1",
        "question": "Which statement is true?",
        "answer": "C++ supports multiple inheritance.",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["C++ supports multiple inheritance."],
        "options": [
          "Only classes can have member variables and methods.",
          "C++ supports multiple inheritance.",
          "C++ supports only single inheritance.",
          "Only structs can inherit."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "e5646ff58a474934a90fe388",
        "question": "Consider a pointer to void, named `ptr`, which has been set to point to a floating point variable `g`. Which choice is a valid way to dereference `ptr` to assign its pointed value to a float variable `f` later in the program?\n```cpp\nfloat g;\nvoid *ptr=&g;\n```",
        "answer": "`float f=*(float *)ptr;`",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["`float f=*(float *)ptr;`"],
        "options": [
          "`float f=*(float)ptr;`",
          "`float f=(float *)ptr;`",
          "`float f=(float)*ptr;`",
          "`float f=*(float *)ptr;`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "9c8510a02838c7da1fb6a7de",
        "question": "What is the `.*` operator and what does it do?",
        "answer": "It is the pointer to the member operator, and it allows you to access a member of an object through a pointer to that specific class member.",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/operator_member_access)",
        "hint": null,
        "correctAnswer": [
          "It is the pointer to the member operator, and it allows you to access a member of an object through a pointer to that specific class member."
        ],
        "options": [
          "It is the same as the class member access operator, or arrow operator `(->)`, which allows you to access a member of an object through a pointer to the object.",
          "It is the pointer to the member operator, and it allows you to access a member of an object through a pointer to that specific class member.",
          "It is the member access with an address of the operator, which returns the address of a class or struct member.",
          "It is a combination of the member access operator `(.)` and the dereference operator `(*)`, so it allows you to access the object that a member pointer points to."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "7045444d2d2edf6b6c598d84",
        "question": "For these declarations, which choice shows four equivalent ways to assign the character \"y\" in the string to a char variable c?\n```cpp\nchar buff[50] = \"strings as arrays of characters are fun!\"\nchar *str = buff+11;\nchar c;\n```",
        "answer": "C",
        "explanation": "```cpp\nc = buff[16];\nc = str[5];\nc = *(buff+16);\nc = *(str+5);\n```\n```cpp\nc = *(buff[15]);\nc = *(str[4]);\nc = buff+15;\nc = str+4;\n```\n```cpp\nc = buff[15];\nc = str[4];\nc = *(buff+15);\nc = *(str+4);\n```\n```cpp\nc = *(buff[16]);\nc = *(str[5]);\nc = buff+16;\nc = str+5;\n```",
        "hint": null,
        "correctAnswer": ["C"],
        "options": ["A", "B", "C", "D"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "d4031aab9d3ac1b5223ac9d8",
        "question": "Which choice is the correct declaration for the class named Dog, derived from the Animal class?\n```cpp\nclass Animal{\n    //....\n}\n```",
        "answer": "B",
        "explanation": "```cpp\nclass Dog :: public Animal {\n//....\n};\n```\n```cpp\nclass Dog : public Animal {\n//....\n};\n```\n```cpp\npublic class Animal :: Dog {\n//....\n};\n```\n```cpp\npublic class Dog extends Animal {\n//....\n};\n```",
        "hint": null,
        "correctAnswer": ["B"],
        "options": ["A", "B", "C", "D"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "a53dfa3277e905e232c3e81b",
        "question": "What is the output of this code given below?\n```cpp\n#include <cstdio>\nusing namespace std;\nint main(){\n    char c = 255;\n    if(c>10)\n        printf(\"c = %i, which is greater than 10\", c);\n    else\n        printf(\"c = %i, which is less than 10\", c);\n    return 0;\n}\n```",
        "answer": "c = -1, which is less than 10",
        "explanation": "Technically, whether a `char` is `signed` or `unsigned` is implementation-defined;\nin the latter case, the second answer would be correct.\n[Reference](https://en.cppreference.com/w/cpp/language/types)",
        "hint": null,
        "correctAnswer": ["c = -1, which is less than 10"],
        "options": [
          "c = -1, which is less than 10",
          "c = 255, which is greater than 10",
          "c = -1, which is greater than 10",
          "c = 255, which is less than 10"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "f6613efe9af8c39b7af60c7f",
        "question": "How can C++ code call a C function?",
        "answer": "by using extern \"C\"",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["by using extern \"C\""],
        "options": [
          "by simply calling the C code",
          "There is no way for C++ to call a C function",
          "by using extern \"C\"",
          "by importing the source C code"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "1018980c001f16eff63bf4a4",
        "question": "Which choice is _not_ a valid type definition of a structure that contains x and y coordinates as integers, and that can be used exactly as shown for the variable named `center`?\n```cpp\ncoord center;\ncenter.x = 5;\ncenter.y = 3;\n```",
        "answer": "A",
        "explanation": "```cpp\ntypedef struct coord {\nint x;\nint y;\n};\n```\n```cpp\ntypedef struct coord {\nint x;\nint y;\n} coord;\n```\n```cpp\ntypedef struct {\nint x;\nint y;\n} coord;\n```\n```cpp\nstruct coord {\nint x;\nint y;\n};\ntypedef struct coord coord;\n```",
        "hint": null,
        "correctAnswer": ["A"],
        "options": ["A", "B", "C", "D"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "88687038bf5b9da4efa80e0a",
        "question": "Which choice does _not_ produce the same output as this code snippet? Assume the variable `i` will not be used anywhere else in the code.\n```cpp\nfor (i=1;i<10;i++){\n    cout<<i<<endl;\n}\n```",
        "answer": "A",
        "explanation": "```cpp\ni=1;\nwhile(i<10){\ncout<<++i<<endl;\n}\n```\n```cpp\nfor (int i:{1,2,3,4,5,6,7,8,9}) {\ncout<<i<<endl;\n}\n```\n```cpp\ni = 1;\ndo {\ncout<<i++<<endl;\n} while(i<10);\n```\n```cpp\ni = 1;\nloop:\ncout<<i++<<endl;\nif(i<10) goto loop;\n```",
        "hint": null,
        "correctAnswer": ["A"],
        "options": ["A", "B", "C", "D"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "95c21d0ed4f052c69f609a33",
        "question": "What does this part of a main.cpp file do?\n```cpp\n#include \"library.h\"\n```",
        "answer": "It causes the replacement of the `#include` directive by the entire contents of the source file library.h. This is similar to the Copy-Paste operation of library.h into main.cpp.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "It causes the replacement of the `#include` directive by the entire contents of the source file library.h. This is similar to the Copy-Paste operation of library.h into main.cpp."
        ],
        "options": [
          "It causes the toolchain to compile all the contents of library.h so that its executable code is available when needed by the final application.",
          "It cherry-picks library.h for the declarations and definitions of all data and functions used in the remainder of the source file main.cpp, finally replacing the `#include` directive with those declarations and definitions.",
          "It informs the linker that some functions or data used in the source file main.cpp are contained in library.h, so that they can be called in run time. This is also known as dynamic linking.",
          "It causes the replacement of the `#include` directive by the entire contents of the source file library.h. This is similar to the Copy-Paste operation of library.h into main.cpp."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "2b793abfc991cc9c4946dcc8",
        "question": "Consider this function declaration of `is_even`, which takes in an integer and returns true if the argument is an even number and false otherwise. Which declarations are correct for overloaded versions of that function to support floating point numbers and string representations of numbers?\n```cpp\nbool is_even(int);\n```",
        "answer": "A",
        "explanation": "```cpp\nbool is_even(float f);\nbool is_even(char *str);\n```\n```cpp\nbool is_even(float f);\nbool is_even(char str);\n```\n```cpp\nbool is_even_float(float f);\nbool is_even_str(char *str);\n```\n```cpp\nfloat is_even(float f);\nchar *is_even(char *str);\n```",
        "hint": null,
        "correctAnswer": ["A"],
        "options": ["A", "B", "C", "D"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "c29e57e1898d551229868553",
        "question": "Which choice is an include guard for the header file `my_library.h`?",
        "answer": "B",
        "explanation": "```cpp\n#ifdef MY_LIBRARY_H\n#define MY_LIBRARY_H\n// my_library.h content\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#ifndef MY_LIBRARY_H\n#define MY_LIBRARY_H\n// my_library.h content\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#ifdef MY_LIBRARY_H\n#undef MY_LIBRARY_H\n// my_library.h content\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#define MY_LIBRARY_H\n#include MY_LIBRARY_H\n// my_library.h content\n#undef MY_LIBRARY_H\n```",
        "hint": null,
        "correctAnswer": ["B"],
        "options": ["A", "B", "C", "D"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "53a37f9e4d4519434c0bbaa0",
        "question": "What's wrong with this definition when using a pre-C++11 compiler?\n```cpp\nstd::vector<std::vector<int>> thematrix;\n```",
        "answer": "`>>` is parsed as the shift-right operator, and thus results in a compile error.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "`>>` is parsed as the shift-right operator, and thus results in a compile error."
        ],
        "options": [
          "There's nothing wrong with it.",
          "An `std::vector` cannot contain more `std::vector` containers as its elements.",
          "The correct syntax should be: `std::vector[std::vector[int]] thematrix;`",
          "`>>` is parsed as the shift-right operator, and thus results in a compile error."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "eb91ca582d3f99e04dbd5838",
        "question": "What is the statement below equivalent to?",
        "answer": null,
        "explanation": null,
        "hint": null,
        "correctAnswer": [],
        "options": [],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "d484c55863f6a088652ed0a2",
        "question": "b. What is the statement equivalent to?\n```cpp\nsprite->x\n```",
        "answer": "`(*sprite).x`",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["`(*sprite).x`"],
        "options": ["`sprite.x`", "`sprite.*x`", "`(*sprite).x`", "`*sprite.x`"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "ee3bcc6140d3a49f769b825c",
        "question": "Consider a class named `complexNumber`. Which code will result in an equivalent object?\n```cpp\ncomplexNumber(float real, float im)\n: real_part(real),\n im_part(im){}\n```",
        "answer": "C",
        "explanation": "```cpp\ncomplexNumber(float real, float im) {\nthis->real = real_part;\nthis->im = im_part;\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part(real);\nthis->im_part(im);\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part = real;\nthis->im_part = im;\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part = &real;\nthis->im_part = &im;\n}\n```",
        "hint": null,
        "correctAnswer": ["C"],
        "options": ["A", "B", "C", "D"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "a81cb16f75ddd2402f3fafa2",
        "question": "What is the result of executing this code snippet?\n```cpp\nbool x=true, y=false;\nif (~x || y) {\n    /*part A*/\n} else {\n    /*part B*/\n}\n```",
        "answer": "Part A executes because `~x` is not zero, meaning true.",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["Part A executes because `~x` is not zero, meaning true."],
        "options": [
          "Part A executes because the expression `(~x || y)` always results in true if `y==false`.",
          "Part B executes because the statement `(~x || y)` is invalid, thus false.",
          "Part A executes because `~x` is not zero, meaning true.",
          "Part B executes because `~x` is false and `y` is false, thus the `OR` operation evaluates as false."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "6051542d9696b22f485aca62",
        "question": "What would be the output of this code?\n```cpp\nint32_t nums[3]={2,4,3};\nstd::cout << ( nums[0] << nums[1] << nums[2] );\n```",
        "answer": "256",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["256"],
        "options": [
          "The output is the addresses of `nums[0]`, `nums[1]`, and `nums[2]`, in that order, with no spaces.",
          "256",
          "`0`",
          "`243`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "ed7c7407b771e4a7487608c6",
        "question": "What is the output of this code?\n```cpp\nfloat values[5]={0.54f, 2.71828f, 3.14159f, 5.499999f, 10.0f};\nfor(auto f:values)\n    printf(\"%i \",(int)(f+0.5f));\n```",
        "answer": "`1 3 3 5 10`",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["`1 3 3 5 10`"],
        "options": [
          "`0.54 2.71828 3.14159 5.499999 10.0`",
          "`1 3 4 6 11`",
          "`0 2 3 5 10`",
          "`1 3 3 5 10`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "5dd087e3a00d2025dc52c1d3",
        "question": "Which of the following STL classes is the best fit for implementing a phonebook? Suppose each entry contains a name and a phone number, with no duplicates, and you want to have a lookup by name.",
        "answer": "`std::map`",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/container/map)",
        "hint": null,
        "correctAnswer": ["`std::map`"],
        "options": ["`std::priority_queue`", "`std::list`", "`std::vector`", "`std::map`"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "3b655f0a713931a9bdcca12a",
        "question": "What does this program do?\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\nint main(){\n    ifstream file1(\"text1.txt\", ios::binary);\n    ofstream file2(\"text2.txt\", ios::binary);\n    file2 << file1.rdbuf();\n}\n```",
        "answer": "It copies the contents of text1.txt into text2.txt - i.e., it makes a copy of text1.txt, named text2.txt.",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/header/fstream)",
        "hint": null,
        "correctAnswer": [
          "It copies the contents of text1.txt into text2.txt - i.e., it makes a copy of text1.txt, named text2.txt."
        ],
        "options": [
          "It renames text1.txt to text2.txt.",
          "It makes a directory called text2.txt and moves text1.txt there.",
          "It copies the contents of text1.txt into text2.txt - i.e., it makes a copy of text1.txt, named text2.txt.",
          "It appends the contents of text1.txt into text2.txt - i.e., replaces the contents of text2.txt by the concatenation of text2.txt and text1.txt."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "2a900fd3651de4336bb9cdf9",
        "question": "Which of the following is _not_ a consequence of declaring the member variable `count` of my_class as static? / Alt.: Which statement is true when declaring the member variable `count` as static?\n```cpp\nclass my_class {\n    public: static int count;\n}\n```",
        "answer": "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it.",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/static)",
        "hint": null,
        "correctAnswer": [
          "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it."
        ],
        "options": [
          "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it.",
          "The variable exists even when no objects of the class have been defined so it can be modified at any point in the source code.",
          "The variable is allocated only once, regardless of how many objects are instantiated because it is bound to the class itself, not its instances.",
          "All objects that try to access their count member variable actually refer to the only class-bound static count variable."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "e6213b1309ed3217b6e2c541",
        "question": "What is the assumed type of a constant represented in the source code as `0.44`?",
        "answer": "double",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["double"],
        "options": ["double", "long float", "long double", "float"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "04a634fe1878af4a3a031aa8",
        "question": "What is an appropriate way of removing `my_object` as shown below?\n```cpp\nmy_class *my_object = new my_class();\n```",
        "answer": "`delete(my_object);`",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["`delete(my_object);`"],
        "options": [
          "`delete(my_object);`",
          "`free(my_object);`",
          "The garbage collector will destroy the object eventually.",
          "Exiting the scope will destroy the object."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "c7d793fd35829d62a6cd9b78",
        "question": "What is the correct way to call the `count` member function for the object pointer called `grades`?\n```cpp\nclass my_array{\n    public:\n        int count();\n};  // ... more members above\nint main(){\n    my_array *grades = new my_array();\n};  // ... more code above\n```",
        "answer": "`grades->count();`",
        "explanation": "[Reference](https://en.cppreference.com/w/c/language/operator_member_access)",
        "hint": null,
        "correctAnswer": ["`grades->count();`"],
        "options": [
          "`grades.count();`",
          "`my_array->count();`",
          "`grades->count();`",
          "`my_array.count();`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "49e2287434eb8bcf7cb4cc12",
        "question": "What would be the output of this code?\n```cpp\nint i0=4, i1=6, i2=8;\nint& nums[3]={i2,i0,i1};\nstd::cout<<nums[0]<<nums[1]<<nums[2];\n```",
        "answer": "There is no output. The code causes a compiler error because `nums` is an array of references, which is illegal.",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/array)",
        "hint": null,
        "correctAnswer": [
          "There is no output. The code causes a compiler error because `nums` is an array of references, which is illegal."
        ],
        "options": [
          "There is no output. The code causes a compiler error because `nums` is an array of references, which is illegal.",
          "846",
          "The output is the addresses of `i2`, `i0`, and `i1`, in that order, with no spaces.",
          "468"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "bf7ca29125f7c7fa6f543dd7",
        "question": "Does this code cause a compiler error? If so, why, and if not, what is `child_t`?\n```cpp\ntypedef struct{\n    unsigned int  age    : 4;\n    unsigned char gender : 1;\n    char                 : 0;\n    unsigned int  size   : 2;\n}child_t;\n```",
        "answer": "No, and `child_t` is a type defined as a structure with bit fields. It has 4 bits for age and 1 bit for gender in the first byte, and 2 bits for size in the second byte.",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/bit_field)",
        "hint": null,
        "correctAnswer": [
          "No, and `child_t` is a type defined as a structure with bit fields. It has 4 bits for age and 1 bit for gender in the first byte, and 2 bits for size in the second byte."
        ],
        "options": [
          "Yes, it causes a compiler error because the colon character is not allowed in struct definitions.",
          "No, and `child_t` is a type defined as a structure with bit fields. It has 4 bits for age and 1 bit for gender in the first byte, and 2 bits for size in the second byte.",
          "Yes, it causes a compiler error because there is an unnamed field.",
          "Yes, it causes a compiler error because one field is defined as having a size of 0."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "16e735b173b70729606de4ae",
        "question": "What is this expression equivalent to?\n```cpp\nA->B\n```",
        "answer": "`(*A).B`",
        "explanation": "Note: a simpler variant of the question below.",
        "hint": null,
        "correctAnswer": ["`(*A).B`"],
        "options": ["`*(A.B)`", "`B=A`", "`(*A).B`", "`&A.B`"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "cb7cbe26b84f604159f205e2",
        "question": "What is this expression equivalent to?\n```cpp\nA->B->C->D\n```",
        "answer": "`*(*((*A).B).C).D`",
        "explanation": "**Note:** a more complex variant of the question above.",
        "hint": null,
        "correctAnswer": ["`*(*((*A).B).C).D`"],
        "options": ["`A.B.C.D`", "`*A.*B.*C.*D`", "`&A.&B.&C.&D`", "`*(*((*A).B).C).D`"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "1f12957119413ac672e72148",
        "question": "What does this function do?\n```cpp\nauto buff = new char[50];\nstd::memset(buff,20,50);\n```",
        "answer": "It writes the value 20 in every memory address from buff to buff+49.",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/string/byte/memset)",
        "hint": null,
        "correctAnswer": ["It writes the value 20 in every memory address from buff to buff+49."],
        "options": [
          "It declares a memory buffer named buff that starts at address 20 and ends at address 70.",
          "It sets all bits in the array named buffer from its element at index 20 to its element at index 50.",
          "It writes the value 20 in every memory address from buff to buff+49.",
          "It declares a memory buffer named buff that starts at address 20 and ends at address 50."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "359e7183faa2b4e01c058c1c",
        "question": "Consider a class named `CustomData`. Which choice is a correct declaration syntax to overload the postfix `++` operator as a class member?",
        "answer": "`CustomData operator++(int);`",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/operators)",
        "hint": null,
        "correctAnswer": ["`CustomData operator++(int);`"],
        "options": [
          "`CustomData& operator++();`",
          "`void operator++(CustomData);`",
          "`CustomData operator++(CustomData);`",
          "`CustomData operator++(int);`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "256f226a71a9adaab4bb0f9d",
        "question": "You want to sort my_array, declared below. Which choice is the correct call to std::sort, using a lambda expression as the comparison function?\n```cpp\nstd::array<uint32_t, 50> my_array;\n```",
        "answer": "A",
        "explanation": "```cpp\nstd::sort(my_array.begin(), my_array.end(),\n[](uint32_t a, uint32_t b) {\nreturn a < b;\n})\n```\n```cpp\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n}\nstd::sort(my_array.begin(), my_array.end(), lambda);\n```\n```cpp\nstd::sort(my_array.begin(), my_array.end(),\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n})\n```\n```cpp\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n}\nstd::sort(my_array.begin(), my_array.end(), &lambda);\n```\n[Reference](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160)",
        "hint": null,
        "correctAnswer": ["A"],
        "options": ["A", "B", "C", "D"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "90f97d2efdf96c448dc96b6d",
        "question": "Which choice is the most reasonable implementation of the function std::mutex::lock() by using std::mutex::try_lock()?",
        "answer": "A",
        "explanation": "```cpp\nvoid std::mutex::lock(){\nwhile(!this->try_lock());\n}\n```\n```cpp\nvoid std::mutex::lock(){\nreturn (this->try_lock());\n}\n```\n```cpp\nvoid std::mutex::lock(){\nwhile(1)\nthis->try_lock();\n}\n```\n```cpp\nvoid std::mutex::lock(){\nwhile(this->try_lock());\n}\n```\nNote: variant of the question below.",
        "hint": null,
        "correctAnswer": ["A"],
        "options": ["A", "B", "C", "D"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "94db5d44bf71381238f2e7eb",
        "question": "What is the main difference between these two Functions?\n```cpp\nstd::mutex::lock()\nstd::mutex::try_lock()\n```",
        "answer": "Both attempt to acquire a lock, but `lock()` blocks if the mutex is not available, whereas `try_lock()` returns whether the mutex is available or not.",
        "explanation": "Note: variant of the question above.\n[Reference](https://en.cppreference.com/w/cpp/thread/mutex/try_lock)",
        "hint": null,
        "correctAnswer": [
          "Both attempt to acquire a lock, but `lock()` blocks if the mutex is not available, whereas `try_lock()` returns whether the mutex is available or not."
        ],
        "options": [
          "`lock()` has a higher privilege over `try_lock()`. This means that you have a better chance of acquiring a mutex `with lock()`.",
          "Both attempt to acquire a lock, but `lock()` blocks if the mutex is not available, whereas `try_lock()` returns whether the mutex is available or not.",
          "`lock()` enforces preemption, whereas `try_lock()` suggests preemption.",
          "If the mutex is not available, `try_lock()` returns with a corresponding code, whereas `lock()` snatches the mutex from the thread that currently has it."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "852f4e0b75f6d9c51dd3bc77",
        "question": "What is the purpose of a destructor?",
        "answer": "It allows the programmer to write the necessary code to free the resources acquired by the object prior to deleting the object itself.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "It allows the programmer to write the necessary code to free the resources acquired by the object prior to deleting the object itself."
        ],
        "options": [
          "It allows the programmer to write the necessary code to free the resources acquired by the object prior to deleting the object itself.",
          "It deletes an object. One example of a destructor is the `delete()` function.",
          "It terminates a program. This may be achieved as a regular function call or as an exception.",
          "There are no destructors in C++."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "66c9b437489e6f7b194c6752",
        "question": "What is one benefit of declaring the parameter as a `const` reference instead of declaring it as a regular object?\n```cpp\nint calculateMedian(const my_array& a)\n```",
        "answer": "The `const` qualifier forbids the code to modify the argument, so the programmer can rest assured that the source object will remain unchanged. / Alt.: The argument is passed as a reference, so if the passed my_array object is large, the program will require less time and memory.",
        "explanation": "[Reference](https://stackoverflow.com/a/2627179/10773894)",
        "hint": null,
        "correctAnswer": [
          "The `const` qualifier forbids the code to modify the argument, so the programmer can rest assured that the source object will remain unchanged. / Alt.: The argument is passed as a reference, so if the passed my_array object is large, the program will require less time and memory."
        ],
        "options": [
          "Actually, objects cannot be passed as regular variables, because they require a constructor call. Therefore, a `const` reference is the only way to pass class instances to functions.",
          "There are no benefits because a reference and an object are treated as the same thing.",
          "The `const` qualifier forbids the code to modify the argument, so the programmer can rest assured that the source object will remain unchanged. / Alt.: The argument is passed as a reference, so if the passed my_array object is large, the program will require less time and memory.",
          "The argument is passed as a reference, so the function receives a copy that can be modified without affecting the original variable."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "4a11a8a861c75ae5a0b32a11",
        "question": "What is an include guard?",
        "answer": "a preprocessor statement that prevents a source file from being included more than once in a project",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "a preprocessor statement that prevents a source file from being included more than once in a project"
        ],
        "options": [
          "a preprocessor directive that prevents inconsistent behaviors in lines that contain the #ifdef, #ifndef, or #elif directives",
          "a compiler option that prevents the user code from including additional libraries",
          "a preprocessor statement that prevents a source file from being included more than once in a project",
          "a library that adds safety features such as mutexes, watchdog timers, and assertions to the project"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "43052458c27f46b72e26759d",
        "question": "What would be the correct declaration of a default constructor for a class named Sprite?",
        "answer": "A",
        "explanation": "```cpp\npublic: Sprite();\n```\n```cpp\nprivate: void Sprite();\n```\n```cpp\npublic: void Sprite();\n```\n```cpp\nprivate: Sprite();\n```",
        "hint": null,
        "correctAnswer": ["A"],
        "options": ["A", "B", "C", "D"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "184a4f8ba58473a0866205cb",
        "question": "What is the purpose of this line in a header file?\n```cpp\n#pragma once\n```",
        "answer": "to make the compiler parse that header file only once, even if it is included multiple times in the source",
        "explanation": "[reference here](https://en.cppreference.com/w/cpp/preprocessor/impl)",
        "hint": null,
        "correctAnswer": [
          "to make the compiler parse that header file only once, even if it is included multiple times in the source"
        ],
        "options": [
          "to restrict the use of its contents to only one source file",
          "to tell the compiler that only one variable can be instantiated from the classes or types contained in this header file",
          "to help the compiler finish faster by assuring that only one compiler pass is necessary for the code included in this header file",
          "to make the compiler parse that header file only once, even if it is included multiple times in the source"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "b64bf85ecc95b023a14d0e1e",
        "question": "What is a variable of type double?",
        "answer": "a floating point number",
        "explanation": "[Reference](https://www.educba.com/c-plus-plus-double/)",
        "hint": null,
        "correctAnswer": ["a floating point number"],
        "options": [
          "a 2-tuple",
          "an integer number",
          "a floating point number",
          "a string with more than 255 characters"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "1c626ac83b42e745c864423c",
        "question": "Other than shifting bits to the left, what is the << operator used for?",
        "answer": "inserting characters into an output stream like std::cout.",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["inserting characters into an output stream like std::cout."],
        "options": [
          "shifting characters to the left in a string.",
          "inserting characters into an output stream like std::cout.",
          "comparing floating point numbers as less-than.",
          "assigning a variable to a reference."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "aee4da0419c8faad59547cb2",
        "question": "Which choice is a reason to specify the type of a pointer instead of using `void *`, which works as a pointer to any type?",
        "answer": "The compiler needs the data type to know how much memory to allocate for the pointer because different data types require different pointer lengths.",
        "explanation": "[Reference](https://stackoverflow.com/questions/9802585/why-is-the-data-type-needed-in-pointer-declarations)",
        "hint": null,
        "correctAnswer": [
          "The compiler needs the data type to know how much memory to allocate for the pointer because different data types require different pointer lengths."
        ],
        "options": [
          "The compiler needs the data type to make sure that the pointer is not going to be used on illegal non-pointable types such as functions, labels, pointers, and references.",
          "`void *` does not work for any type. The language does not allow assigning anything other than `void` to a pointer to `void *`.",
          "The compiler needs the data type to know how much memory to allocate for the pointer because different data types require different pointer lengths.",
          "Yes, it causes a compiler error because one field is defined as having a size of 0."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "25c34acee8b521f1a578af89",
        "question": "What is wrong with this piece of code?\n```cpp\n#include <iostream>\nchar str[20];\nint main(){\n    std::cout << \"What's your name? \";\n    str << std::cin\n    std::cout << \"Hello, \" << str;\n    return 0;\n}\n```",
        "answer": "The input operator flow is inverted. it should start from `std::cin` and then flow (>>) into `str`.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "The input operator flow is inverted. it should start from `std::cin` and then flow (>>) into `str`."
        ],
        "options": [
          "The main function is supposed to have a void return type.",
          "`std::cin` and `std::cout` are invalid. The correct names for the character input and output streams are `cin` and `cout`.",
          "The address of `str` is supposed to be used. That is `&str` instead of `str`.",
          "The input operator flow is inverted. it should start from `std::cin` and then flow (>>) into `str`."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "3e1552a46ff68f1d7892c2ba",
        "question": "When placed in a valid execution context, which statement will dynamically allocate memory from the heap for an integer of value 11?",
        "answer": "`int* anInt = new int(11);`",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["`int* anInt = new int(11);`"],
        "options": [
          "`int anInt = new int(11);`",
          "`int* anInt = new int[11];`",
          "`int anInt = new int[11];`",
          "`int* anInt = new int(11);`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "6672c682b0ab492405181f56",
        "question": "Which choice best describes the type `long`?",
        "answer": "an integer number of at least 32 bits",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["an integer number of at least 32 bits"],
        "options": [
          "an integer number of at least 32 bits",
          "a string with more than 255 characters",
          "a pointer",
          "a 64-bit floating point number"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "a168f9b1a8d91935ae8fef9b",
        "question": "Which of the following types has the closest functionality to a class?",
        "answer": "`struct`",
        "explanation": "[Reference](https://en.cppreference.com/w/c/language/struct)",
        "hint": null,
        "correctAnswer": ["`struct`"],
        "options": ["`struct`", "`union`", "`enum`", "`namespace`"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "af706cc597402e987d682342",
        "question": "Given these records in a map, how will you update the value for the key \"Sinead\" to 22?\n![image](images/Q79.png)",
        "answer": "`marks[\"Sinead\"] = 22`",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["`marks[\"Sinead\"] = 22`"],
        "options": [
          "`marks[\"Sinead\"] = 22`",
          "`marks[\"Sinead\"].22`",
          "`marks[\"Sinead\"] -> 22`",
          "`marks[\"Sinead\"].value = 22`"
        ],
        "nature": "ChooseOne",
        "attachments": [
          {
            "id": "5ded33e4f9551eda1c9769a0",
            "url": "images/Q79.png",
            "type": "question"
          }
        ]
      },
      {
        "id": "8db6108fc88ec154e5deee0c",
        "question": "Why can the std::sort receive a function object as one of its parameters?",
        "answer": "`The std::sort function is a template. The programmer is free to enter the sorting algorithm in a function object as an argument.`",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "`The std::sort function is a template. The programmer is free to enter the sorting algorithm in a function object as an argument.`"
        ],
        "options": [
          "`The std::sort function is a template. The programmer is free to enter the sorting algorithm in a function object as an argument.`",
          "`Actually, std::sort takes only one argument, which is the container to be sorted.`",
          "`std::sort operates on a template container. The compiler does not know how to relationally compare the values it contains, so a function must be provided to do the comparison.`",
          "`std::sort will use the parameter function as an error handler. The function will be called if an error occurs.`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "6f21014ee98b5242eec01d1c",
        "question": "What will happen when you execute this code snippet?\n```\n#include <iostream>\nint main() {\nfloat a = 5.51;\nint b = static_cast<int>(a);\nstd::cout << b;\n}\n```",
        "answer": "`5 will be printed on standard output, with no compilation warnings generated.`",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "`5 will be printed on standard output, with no compilation warnings generated.`"
        ],
        "options": [
          "`6 will be printed on standard output, with no compilation warnings generated.`",
          "`5 will be printed on standard output, with no compilation warnings generated.`",
          "`6 will be printed on standard output, with compilation warnings generated.`",
          "`5 will be printed on standard output, with compilation warnings generated.`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "8207d633ba99efdcaefd715d",
        "question": "Which access specifier does not allow class members to be accessed from outside the class, but allows them to be accessed by derived classes?",
        "answer": "protected",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["protected"],
        "options": ["guarded", "protected", "public", "private"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "e75229ef4ea4d01128451043",
        "question": "The default executable generation on UNIX for a C++ program is \\_",
        "answer": "a.out",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["a.out"],
        "options": ["a.exe", "a", "a.out", "out.a"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "de3e6e211fab1838bea63c9f",
        "question": "What will be the output of the following program?\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\n  int a=1;\n  cout<<(a++)*(++a)<<endl;\n  return 0;\n}\n```",
        "answer": "3",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["3"],
        "options": ["1", "2", "3", "6"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "fd88f9e23608fba37735805a",
        "question": "What does \"c\" stand for in cout and cin?",
        "answer": "character",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["character"],
        "options": ["compiler", "console", "character", "standard namespace"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "8e3ed2c0859a025feb5c3ef8",
        "question": "What is the use of tellp()?",
        "answer": "Current Output Pointer position",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["Current Output Pointer position"],
        "options": [
          "Current Input Pointer position",
          "Current Output Pointer position",
          "Last Input Pointer position",
          "Last Output Pointer position"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "251521fc9857980fc12817df",
        "question": "What is callback function?",
        "answer": "Pointer for a function",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["Pointer for a function"],
        "options": [
          "Pointer for a pointer",
          "Pointer for a function",
          "function for a pointer",
          "function for a class"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "e0965e016be19d676f1e8477",
        "question": "What is the correct syntax to output \"Hello World\" in C++?",
        "answer": "`cout << \"Hello World\";`",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["`cout << \"Hello World\";`"],
        "options": [
          "`cout << \"Hello World\";`",
          "`System.out.println(\"Hello World\");`",
          "`print(\"Hello World\");`",
          "Console.WriteLine(\"Hello World\");```"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "1648ea9982450a960f01203f",
        "question": "How many categories of iterators are there in C++?",
        "answer": "5",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["5"],
        "options": ["4", "3", "7", "5"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "3f5e884e6c631edc0458afc9",
        "question": "What is the meaning of base class in C++ ?",
        "answer": "Another class got inherited from this class",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["Another class got inherited from this class"],
        "options": [
          "It inherits other class",
          "It has a pointer variable",
          "It is the first class declared",
          "Another class got inherited from this class"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "2cf842c8f72941bd618e8c95",
        "question": "The size of C++ objects is expressed in terms of multiples of the size of a ** and the size of a char is **.",
        "answer": "char, 1",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["char, 1"],
        "options": ["char, 4", "float, 8", "int, 1", "char, 1"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "3681ffda203c0f9461642ee7",
        "question": "Implementation-dependent aspects about an implementation can be found in",
        "answer": "`<limits>`",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["`<limits>`"],
        "options": ["`<numeric>`", "`<limit>`", "`<limits>`", "`<implementation>`"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "2d3fe3a23b1a7af3a1b3af8c",
        "question": "What is a default constructor?",
        "answer": "a constructor that can be used with no arguments",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["a constructor that can be used with no arguments"],
        "options": [
          "a constructor that can be used with no arguments",
          "a constructor that does not have a return value",
          "a constructor that is used by multiple classes",
          "a constructor that initializes all members of a class"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "65f854a69a69ef1c158984a9",
        "question": "When protecting a header file, why would you use '#pragma once' instead of 'include' guard?",
        "answer": "An include guard uses a macro to achieve single inclusion, but the compiler cannot prevent the programmer from defining that macro elsewhere, which would result in no inclusion at all",
        "explanation": "defining that macro elsewhere, which would result in no inclusion at all\nmore than once in a project. This is not a problem with '#pragma once'",
        "hint": null,
        "correctAnswer": [
          "An include guard uses a macro to achieve single inclusion, but the compiler cannot prevent the programmer from defining that macro elsewhere, which would result in no inclusion at all"
        ],
        "options": [
          "There is no reason to choose because they serve different purposes",
          "An include guard uses a macro to achieve single inclusion, but the compiler cannot prevent the programmer from defining that macro elsewhere, which would result in no inclusion at all",
          "'#pragma once' guarantees that the header code will never be changed because it is enforced by the compiler",
          "Include guards refer to the header file in the file system, not to the code, so they are not helpful if the header file exists"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "201c7c4f1e68889d40dc66c7",
        "question": "Which of the following statements is valid?",
        "answer": "We can not change the operator templates.",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["We can not change the operator templates."],
        "options": [
          "We can create a new C++ operator.",
          "We can change the precedence of the C++ operator.",
          "We can not change the operator templates.",
          "We can change the associativity of the C++ operators."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "c5fd49b6707f40d705d8093e",
        "question": "Which of the following is/are automatically added to every class, if we do not write our own?",
        "answer": "All of the above",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["All of the above"],
        "options": [
          "Copy Constructor",
          "Assignment Operator",
          "A constructor without any parameter",
          "All of the above"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "15f942a3b715c574f5cc5975",
        "question": "The if-else statement can be replaced by which operator?",
        "answer": "selective structure",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["selective structure"],
        "options": [
          "certain structure",
          "choosing structure",
          "selective structure",
          "None of the Above"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "81db990733e1f44272790df3",
        "question": "Which choice would be a recursive solution to the factorial n! problem?",
        "answer": "&shy;",
        "explanation": "```cpp\nvoid fact(int n) {\nif (n <= 0)\nreturn 0;\nelse\nreturn 1;\n}\n```\n```cpp\nint fact(int n) {\nif (n <= 0)\nreturn 1;\nelse\nreturn (fact(n) * (n-1));\n}\n```\n```cpp\nint fact(int n) {\nif (n >= 0)\nreturn 1;\nelse\nreturn (fact(n-1) * n);\n}\n```\n```cpp\nint fact(int n) {\nif (n <= 0)\nreturn 1;\nelse\nreturn (fact(n-1) * n);\n}\n```",
        "hint": null,
        "correctAnswer": ["&shy;"],
        "options": ["&shy;", "&shy;", "&shy;", "&shy;"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "c86198329a5ecc74b31338a1",
        "question": "A class destructor can be called when a variety of situations occur. Which choice is not one of those situations?",
        "answer": "The garbage collector detects that an object is no longer going to be used.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "The garbage collector detects that an object is no longer going to be used."
        ],
        "options": [
          "The program is terminated. This calls the destructor of static duration objects.",
          "The delete () function is called for an object pointer assigned with the new operator.",
          "The garbage collector detects that an object is no longer going to be used.",
          "An automatic storage duration object goes out of scope."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "c3ce80b656366b2e94b9e611",
        "question": "You are designing a foreign exchange payments system in C++, You need to model a transaction of a currency that has an integer as its quantity and a float as its price. You then want to declare an actual object of this type. How will you achieve this?",
        "answer": "A",
        "explanation": "```cpp\nstruct currencyDeal {\nfloat price;\nint quantity;\n};\ncurrencyDeal firstDeal;\n```\n```cpp\nunion currencyDeal {\nfloat price;\nint quantity;\n};\ncurrencyDeal firstDeal;\n```\n```cpp\nstruct currencyDeal {\nfloat price;\nint quantity;\n};\n```\n```cpp\nunion currencyDeal {\nfloat price;\nint quantity;\n};\n```",
        "hint": null,
        "correctAnswer": ["A"],
        "options": ["A", "B", "C", "D"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "f764c26369c116d4a352a78a",
        "question": "What will happen if you attempt to call this function with checkConcatThreshold(\"a\");?\n```cpp\nint checkConcatThreshold(string a, string b) {\n    return (a + b).length () > 120;\n}\n```",
        "answer": "A compilation error will occur.",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["A compilation error will occur."],
        "options": [
          "A compilation warning will occur and the second argument will be given a default value of b.",
          "A compilation warning will occur and the second argument will be given a default value of the empty string.",
          "A compilation error will occur.",
          "No compilation errors will occur and no compilation warnings will occur."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "cf3970aef60c022ed55af16b",
        "question": "You need to define a C++ lambda function. You want the function to have access to only the variables that are local to it. The function should receive a single parameter, and a name, and construct a simple greeting. How will you achieve this?",
        "answer": "C",
        "explanation": "```cpp\nauto myVeryFirstLambda = [=] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nmyVeryFirstLambda = [&] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nauto myVeryFirstLambda = [] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nmyVeryFirstLambda = [] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n[Reference](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160)",
        "hint": null,
        "correctAnswer": ["C"],
        "options": ["A", "B", "C", "D"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "bf21e6d951950cb48b77c37a",
        "question": "What is the value of X after running this code?\n```cpp\nint x=10, a=-3;\nX+=a;\n```",
        "answer": "7",
        "explanation": "**Explanation :** `+=` means increasing value. So `x += a` is equivalent to `x = x + a`",
        "hint": null,
        "correctAnswer": ["7"],
        "options": ["-3", "7", "13", "3"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "86a182d49df9a467081087e8",
        "question": "Once you are done writing to a file, what method will you call on the `ofstream` to notify the operating system?",
        "answer": "close()",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["close()"],
        "options": ["printout()", "close()", "destroy()", "flush()"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "18a45e0228c0052ce3bc2998",
        "question": "Which choice is not a C++ keyword?",
        "answer": "comPl",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["comPl"],
        "options": ["static_assert", "reinterpret_cast", "comPl", "alignas"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "8756e42147958e9eefc2b6c1",
        "question": "The size_in_bits function seems to take any type of parameter. This can be done by overloading the function, or by letting the compiler take care of it by writing a template. Which choice is an implementation of that template?\n```cpp\nint main()\n{\ncout \u00ab size_in_bits(21) \u00ab endl;\ncout \u00ab size_in_bits('f') \u00ab endl;\ncout \u00ab size_in_bits(32.1f) \u00ab endl;\ncout \u00ab size_in_bits(32.1) \u00ab endl;\nreturn 0;\n}\n```",
        "answer": "A; C",
        "explanation": "```cpp\ntemplate <typename T>\nsize_t size_in_bits(const T& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\ntemplate size_t size_in_bits(const {int,float,double,char,long}& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\ntemplate <typename T {int,float,double,char,long>\nsize_t size_in_bits(const T& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\nsize_t size_in_bits(void * a){\nreturn sizeof(a)*8;\n}\n```",
        "hint": null,
        "correctAnswer": ["A", "C"],
        "options": ["A", "B", "C", "D"],
        "nature": "ChooseMany",
        "attachments": []
      },
      {
        "id": "4909c1ff582e30a0e1375495",
        "question": "To use the keyboard as input the iostream library is included. To read input from files as input what library is needed?",
        "answer": "fstream",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["fstream"],
        "options": ["fstream", "cstdlib", "filestream", "iostream"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "e69290ea3af8b5b9903da547",
        "question": "What will this object-oriented program print?\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Vehicle {\npublic:\n    string fuel = \"none\";\n};\nclass MotorizedVehicle : public Vehicle {\npublic:\n    string fuel = \"fossil\";\n};\nclass NextgenMotorizedVehicle : public MotorizedVehicle {\npublic:\n    string fuel = \"hydrogen\";\n};\nint main() {\n    MotorizedVehicle aCar;\n    cout << aCar.fuel;\n    return 0;\n}\n```",
        "answer": "fossil",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["fossil"],
        "options": ["fossil", "fossil none", "hydrogen", "none"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "30daac78f4ccb78309679e87",
        "question": "The program below is handling a stack container. What is the output of running the program?\n```cpp\n#include <iostream>\n#include <stack>\nint main()\n{\n    std::stack<int> stack;\n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n    stack.pop();\n    stack.push(4);\n    stack.top();\n    stack.pop();\n    std::cout << stack.top();\n}\n```",
        "answer": "2",
        "explanation": "#Detailed explanation:\nNow here we are supposed to implement a stack data structure that follows the **FILO** or (First IN Last Out) principle,\n_stack.push()_ -> pushes an element into the from the end array.\n_stack.pop()_ -> removes an element from the end of the array.\n_stack.top()_ -> Just gives us the topmost element of the array.\nNow following the sequences of push and pop: **[1,2,3]** then pop function is used,\nThe newly formed array is: **[1,2,4]** then the top is used to retrieve the topmost element '4' then again the pop function is used which removes 4.\nthus, the resulting array is: 1,2.\nThen it prints the topmost element (ie: 2).",
        "hint": null,
        "correctAnswer": ["2"],
        "options": ["1", "2", "3", "4"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "9139191ec18a7d49590faf46",
        "question": "Which choice is a valid way to overload the ternary conditional operator?",
        "answer": "`The ternary operator is not overloadable.`",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/operators)",
        "hint": null,
        "correctAnswer": ["`The ternary operator is not overloadable.`"],
        "options": [
          "`void& operator ?:(const bool cond, const void& iftrue, const void& iffalse);`",
          "`The ternary operator is not overloadable.`",
          "`void& operator conditional(const bool cond, const void& iftrue, const void& iffalse);`",
          "`void* operator ?:(const bool cond, const void* iftrue, const void* iffalse);`"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "fa53fffe732c533547fa7fe2",
        "question": "Which class hierarchy represents an example of multilevel inheritance?",
        "answer": "In the same program, at different points, a given class derives individually from more than two different classes.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "In the same program, at different points, a given class derives individually from more than two different classes."
        ],
        "options": [
          "In the same program, at different points, a given class derives individually from more than one different class.",
          "A first-class derives directly, at the same time, from a second and third class.",
          "In the same program, at different points, a given class derives individually from more than two different classes.",
          "A first classderives from a second class, and that second class is already derived from a third class"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "f05172ed26a62d5e4e37aecb",
        "question": "Which of the following is the correct syntax to print the message in C++ language?",
        "answer": "cout <<\"Hello world!\";",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/io/cout)",
        "hint": null,
        "correctAnswer": ["cout <<\"Hello world!\";"],
        "options": [
          "Out <<\"Hello world!",
          "Cout << Hello world! ;",
          "cout <<\"Hello world!\";",
          "None of the above"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "2042b9693fe128d919da388d",
        "question": "Consider the following program. What will be the output/error?\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nbool compare(char c1, char c2){\nreturn tolower(c1) > tolower(c2);    //LINE-1\n}\nint main(){\nchar arr1[20] = \"C++ Program\", arr2[20] = \"C Program\";\ncout << lexicographical_compare(arr1, arr1+strlen(arr1), arr2, arr2+strlen(arr2),\ncompare);\nreturn 0;\n}\n```",
        "answer": "1",
        "explanation": "[Reference](https://www.geeksforgeeks.org/tolower-function-in-cpp/)",
        "hint": null,
        "correctAnswer": ["1"],
        "options": ["1", "0", "-1", "Compilation Error: function is not defined"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "bd51acd9b00b1132f1450f17",
        "question": "Consider the following code segment. Fill in the blank at LINE-1 so that the program will print \"not found\"?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint data[] = {1,2,3,4,5};\nint key = 5;\nif(binary_search(__________))    //LINE-1\ncout << \"found\";\nelse\ncout << \"not found\";\nreturn 0;\n}\n```",
        "answer": "&data[0], &data[4], key; data+1, data+4, key",
        "explanation": "[Reference](https://www.geeksforgeeks.org/binary-search-algorithms-the-c-standard-template-library-stl/)",
        "hint": null,
        "correctAnswer": ["&data[0], &data[4], key", "data+1, data+4, key"],
        "options": [
          "&data[0], &data[5], key",
          "data, data+5, key",
          "&data[0], &data[4], key",
          "data+1, data+4, key"
        ],
        "nature": "ChooseMany",
        "attachments": []
      },
      {
        "id": "60424f7c401642926180ec70",
        "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main () {\nint data[] = {50, 30, 40, 10, 20};\nsort (&data[1], &data[4]);\nfor (int i = 0; i < 5; i++)\ncout << data[i] << \" \";\nreturn 0;\n}\n```",
        "answer": "50 10 30 40 20",
        "explanation": "[Reference](https://cplusplus.com/reference/algorithm/sort/)",
        "hint": null,
        "correctAnswer": ["50 10 30 40 20"],
        "options": ["10 20 30 40 50", "10 30 40 50 20", "50 10 30 40 20", "50 10 20 30 40"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "58f81f8ecf33788ef41fd5c3",
        "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint element[5];\nfor(int i = 1; i <= 5; i++)\n*(element + i - 1) = i * 5;\nrotate(element, element + 4, element + 5);\nrotate(element, element + 1, element + 4);\nfor (int i = 0; i < 5; ++i)\ncout << element[i] << \" \";\nreturn 0;\n}\n```",
        "answer": "5 10 15 25 20",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/algorithm/rotate)",
        "hint": null,
        "correctAnswer": ["5 10 15 25 20"],
        "options": ["5 10 15 20 25", "5 10 15 25 20", "20 10 15 25 5", "25 5 10 15 20"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "0e8be47694caa5d73aacb699",
        "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nconst int size = 3, c = 65;\nvector<char> vc(size, \u2019A\u2019);\nfor (int i = 1; i <= 2; i++)\nvc.push_back(65 + i);\nvc.resize(10, 90);\nvc.resize(8);\nfor (int i = 0; i < vc.size(); i++)\ncout << vc[i] << \" \";\nreturn 0;\n}\n```",
        "answer": "A A A B C Z Z Z",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/container/vector)",
        "hint": null,
        "correctAnswer": ["A A A B C Z Z Z"],
        "options": ["A A A B C Z Z Z", "A A B B C Z Z Z", "A A A B C Z Z", "A A A B C Z Z Z Z"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "e8a6057e9a9df595ed29fd9b",
        "question": "Consider the following code segment. Choose the appropriate option to fill in the blank at LINE-1, such that the output of the code would be: a C++ Program.\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nint main(void) {\nstring s1 = \"C++ \";\nstring s2 = \"Program\";\n__________________;    //LINE-1\ncout << s1;\nreturn 0;\n}\n```",
        "answer": "s1 += s2; s1.append(s2)",
        "explanation": "[Reference](https://www.geeksforgeeks.org/stdstringappend-in-c/)",
        "hint": null,
        "correctAnswer": ["s1 += s2", "s1.append(s2)"],
        "options": ["s1 += s2", "strcat(s1, s2)", "s1.append(s2)", "s1.insert(s2)"],
        "nature": "ChooseMany",
        "attachments": []
      },
      {
        "id": "6d1e33c4ef33b235790c92e8",
        "question": "Consider the following code segment. Fill in the blank at LINE-1 such that the output is 5 2 3 4 5\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint data[] = { 1, 2, 3, 4, 5 };\nfor (int i = 0; i < 1; i++) {\nint j = data[i];\nreplace(data, data + 5, j, *(_________________));    //LINE-1\n}\nfor (int i = 0; i < 5; ++i)\ncout << data[i] << \" \";\nreturn 0;\n}\n```",
        "answer": "data + 4 - i",
        "explanation": "[Reference](https://www.geeksforgeeks.org/stdstringreplace-stdstringreplace_if-c/)",
        "hint": null,
        "correctAnswer": ["data + 4 - i"],
        "options": ["data + 4 - i", "data + 5 - i", "data + i - 4", "data + i - 5"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "4856bcb8b44089dccc58e6ff",
        "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\n#include <cstring>\n#include <stack>\nusing namespace std;\nint main(){\nchar str[10] = \"123456789\";\nstack<char> s1, s2;\nint i;\nfor(i = 0; i < strlen(str)/2; i++)\ns1.push(str[i]);\nfor(i=i-1; i < strlen(str); i++)\ns2.push(str[i]);\nwhile (!s1.empty()) {\ns2.push(s1.top()); s1.pop();\n}\nwhile (!s2.empty()) {\ncout << s2.top(); s2.pop();\n}\nreturn 0;\n}\n```",
        "answer": "1234987654",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/container/stack)",
        "hint": null,
        "correctAnswer": ["1234987654"],
        "options": ["1234987654", "123498765", "1234897654", "123459876"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "ba7f48ab9e8dd15fe0277157",
        "question": "Consider the following code segment. Which statement/statements is/are correct?\n```cpp\nint i = 5;\nconst int *p = &i;\nint * const q = &i;\nint const *r = &i;\nint const * const s = &i;\n*p = 10; //STMT-1\n*q = 10; //STMT-2\n*r = 10; //STMT-3\n*s = 10; //STMT-4\n```",
        "answer": "STMT-2",
        "explanation": "[Reference](https://www.geeksforgeeks.org/const-keyword-in-cpp/)",
        "hint": null,
        "correctAnswer": ["STMT-2"],
        "options": ["STMT-1", "STMT-2", "STMT-3", "STMT-4"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "cc695ff06a4d496bb477875d",
        "question": "Consider the following program. What will be the output/error(s)?\n```cpp\n#include <iostream>\nusing namespace std;\nchar add(char c1 = \u2019a\u2019) { return c1; }\nchar add(char c1 = \u2019a\u2019, char c2 = \u2019b\u2019) { return c1 + c2 - \u2019a\u2019;}\nchar add(char c1 = \u2019a\u2019, int d1 = 100){ return c1 + d1 - \u2019a\u2019; }\nchar add(char c1 = \u2019a\u2019, char c2 = \u2019b\u2019, char c3) { return c1 + c2 + c3 - \u2019a\u2019; }\nint main() {\nchar c = add(\u2019o\u2019, \u2019k\u2019);\ncout << c << endl;\nreturn 0;\n}\n```",
        "answer": "Compilation Error: default argument missing for \"char add(char, char, char)\"; Compilation Error: call of overload \"add(char, char)\" is ambiguous",
        "explanation": "[Reference](https://learn.microsoft.com/en-us/cpp/cpp/function-overloading?view=msvc-170)",
        "hint": null,
        "correctAnswer": [
          "Compilation Error: default argument missing for \"char add(char, char, char)\"",
          "Compilation Error: call of overload \"add(char, char)\" is ambiguous"
        ],
        "options": [
          "y",
          "z",
          "Compilation Error: default argument missing for \"char add(char, char, char)\"",
          "Compilation Error: call of overload \"add(char, char)\" is ambiguous"
        ],
        "nature": "ChooseMany",
        "attachments": []
      },
      {
        "id": "df4d7ef60fa3e113074dcc38",
        "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\nusing namespace std;\n#define SQR(x) (x)*(x)\nint main() {\nint a=3;\ncout << SQR(a++) << endl;\nreturn 0;\n}\n```",
        "answer": "12",
        "explanation": "[Reference](https://www.geeksforgeeks.org/output-of-the-program-use-macros-carefully/)",
        "hint": null,
        "correctAnswer": ["12"],
        "options": ["12", "25", "9", "16"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "0310eb3c0bbbfc822bb6b6be",
        "question": "Consider the following code segment. Which line/s will give you an error?\n```cpp\n#include<iostream>\n#define X 1\nusing namespace std;\nint main(){\nint i;\nconst int i1 = 2;\nconst int i2 = i1; //LINE-1\ni2 = X;\ni = i1;\ni1 = i;\nreturn 0;\n//LINE-2\n//LINE-3\n//LINE-4\n}\n```",
        "answer": "LINE-2; LINE-4",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["LINE-2", "LINE-4"],
        "options": ["LINE-1", "LINE-2", "LINE-3", "LINE-4"],
        "nature": "ChooseMany",
        "attachments": []
      },
      {
        "id": "eec1b82ccf42f0710d7f984b",
        "question": "Consider the following code segment. What will be the output/error?\n```cpp\n#include<iostream>\nusing namespace std;\nint main(){\nint a = 5;\nint &b = a+1;\na = a*b;\ncout << a << \" \" << b;\nreturn 0;\n}\n```",
        "answer": "Compilation Error: invalid initialization of non-const reference",
        "explanation": "#Detailed explanation:\nThe error is occurring because it is trying to create a reference to a temporary value. In the line int &b = a+1; we are attempting to create a reference b to the result of the expression a + 1, which is a temporary value. References must be bound to an actual object, not a temporary value or an expression that does not have a memory location.",
        "hint": null,
        "correctAnswer": ["Compilation Error: invalid initialization of non-const reference"],
        "options": [
          "36",
          "30",
          "25",
          "Compilation Error: invalid initialization of non-const reference"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "d5108549f2b425bc1e4658cc",
        "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\nusing namespace std;\nint& func(int& i) {     //LINE-1\nreturn i = i+5;\n}\nint main() {\nint x = 1, y = 2;\nint& z = func(x);\ncout << x << \" \" << z << \" \";\nfunc(x) = y;\ncout << x << \" \" << z;\nreturn 0;\n}\n```",
        "answer": "6 6 2 2",
        "explanation": "[Reference](https://www.ibm.com/docs/en/zos/2.4.0?topic=calls-pass-by-reference-c-only)",
        "hint": null,
        "correctAnswer": ["6 6 2 2"],
        "options": ["6 6 2 2", "6 6 7 7", "1 1 2 2", "1 1 7 7"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "e214e8c6caf5e911f33ae6be",
        "question": "Consider the following code segment. Choose the appropriate option to fill in the blanks at LINE-1, such that the output of the code would be: 300 20000.\n```cpp\n#include <iostream>\nusing namespace std;\nvoid compute(int n1, int n2, ________, ________){ //LINE-1\nn3 = n1 + n2;\n*n4 = n1 * n2;\n}\nint main(){\nint a = 100, b = 200, c = 0, d = 0;\ncompute(a, b, c, &d); //LINE-2\ncout << c << \", \";\ncout << d;\nreturn 0;\n}\n```",
        "answer": "int& n3, int \\*n4",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["int& n3, int \\*n4"],
        "options": [
          "int n3, int\\* n4",
          "int& n3, int \\*n4",
          "int* n3, int* n4",
          "int& n3, int& n4"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "18e787479f146a5f8bcc9282",
        "question": "Consider the following code segment. What will be the output/error?\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\nint a = 2, *b;\n*b = 5;\nint * const ptr;    // LINE-1\n// LINE-2\nptr = b;\ncout << *ptr;\nreturn 0;\n}\n```",
        "answer": "Compilation Error at LINE-1: uninitialized const \u2019ptr\u2019; Compilation Error at LINE-2: assignment of read-only variable \u2019ptr\u2019",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "Compilation Error at LINE-1: uninitialized const \u2019ptr\u2019",
          "Compilation Error at LINE-2: assignment of read-only variable \u2019ptr\u2019"
        ],
        "options": [
          "`<garbage value>`",
          "5",
          "Compilation Error at LINE-1: uninitialized const \u2019ptr\u2019",
          "Compilation Error at LINE-2: assignment of read-only variable \u2019ptr\u2019"
        ],
        "nature": "ChooseMany",
        "attachments": []
      },
      {
        "id": "75565f8b0975002d7d72e60e",
        "question": "Consider the following code segment. What will be the output/error?\n```cpp\n#include <iostream>\nusing namespace std;\nvoid fun(int a = 5) { cout << a << endl; }\n//LINE-1\nint fun(int x = 10) { cout << x << endl; return 0; }    //LINE-2\nint main() {\nfun();\nreturn 0;\n}\n```",
        "answer": "Compilation error at LINE-2: ambiguating new declaration of \u2019int fun(int)\u2019",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "Compilation error at LINE-2: ambiguating new declaration of \u2019int fun(int)\u2019"
        ],
        "options": [
          "5",
          "10",
          "5",
          "Compilation error at LINE-2: ambiguating new declaration of \u2019int fun(int)\u2019"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "9d564c97a6e66ee2f0334264",
        "question": "Consider the following code segment. Fill in the blank at LINE-1 such that the program will print 5 + i3\n```cpp\n#include<iostream>\nusing namespace std;\nstruct complex{\nint re, im;\nvoid show(){ cout << re << \" + i\" << im; }\n};\n______________________________________{ //Line-1\nc2.re = c1.re+c2.re;\nc2.im = c1.im+c2.im;\nreturn c2;\n}\nint main(){\nstruct complex c1={2,5},c2{3,-2};\nstruct complex t = c1 + c2;\nt.show();\nreturn 0;\n}\n```",
        "answer": "complex operator+(complex &c1, complex &c2)",
        "explanation": "[Reference](https://www.w3schools.com/cpp/cpp_structs.asp)",
        "hint": null,
        "correctAnswer": ["complex operator+(complex &c1, complex &c2)"],
        "options": [
          "complex operator+(complex &c1, complex &c2)",
          "complex operator+(const complex &c1, const complex &c2)",
          "operator+(complex &c1, complex &c2)",
          "complex +(complex &c1, complex &c2)"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "0e7c5e773800d06e4f5c08e2",
        "question": "Consider the following program. Which line/s will generate an error?\n```cpp\n#include<iostream>\nusing namespace std;\nclass myClass{\nint pra = 5;\npublic:\nint pub = 10;\nvoid set_pr(int x){ pra = x; }\nvoid set_pu(int x){ pub = x; }\n};\nint main(){\nmyClass m;\nint a, b;\na = m.pra; //LINE-1\nb = m.pub; //LINE-2\nm.set_pr(100); //LINE-3\nm.set_pu(200); //LINE-4\nreturn 0;\n}\n```",
        "answer": "LINE-1",
        "explanation": "[Reference](https://stackoverflow.com/questions/4855422/c-classes-public-private-and-protected)",
        "hint": null,
        "correctAnswer": ["LINE-1"],
        "options": ["LINE-1", "LINE-2", "LINE-3", "LINE-4"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "9b84051caf6c7654392a9b9d",
        "question": "Consider the following class. Fill in the blanks with proper access specifiers so that member y can be accessed from outside of the class but member x cannot be accessed.\n```cpp\nclass Test{\n________:\nint x;\n________:\nint y;\n/* Some more code */\n};\n```",
        "answer": "private, private",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["private, private"],
        "options": ["public, public", "public, private", "private, public", "private, private"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "14fe85ec4640c5c3ee82551c",
        "question": "Which C++ Standard did add in-class default member initializers?",
        "answer": "C++11",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["C++11"],
        "options": ["C++98", "C++11", "C++14", "C++17."],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "d365e8b193f5d3a86e2da366",
        "question": "Can you use auto type deduction for non-static data members?",
        "answer": "No",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["No"],
        "options": ["Yes, since C++11", "No", "Yes, since C++20"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "13f9b40ac6734b2fefa38798",
        "question": "Do you need to define a static inline data member in a cpp file?",
        "answer": "No, the definition happens at the same place where a static inline member is declared.",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/bit_field)",
        "hint": null,
        "correctAnswer": [
          "No, the definition happens at the same place where a static inline member is declared."
        ],
        "options": [
          "No, the definition happens at the same place where a static inline member is declared.",
          "Yes, the compiler needs the definition in a cpp file.",
          "Yes, the compiler needs a definition in all translation units that use this variable."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "36f44a6c1d24554f53e6cbe1",
        "question": "What's the output of the following code:\n```cpp\nstruct S {\n    int a { 10 };\n    int b { 42 };\n};\nS s { 1 };\nstd::cout << s.a << \", \" << s.b;\n```",
        "answer": "Output is: 1, 42",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["Output is: 1, 42"],
        "options": ["Output is: 1, 0", "Output is: 10, 42", "Output is: 1, 42"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "94a9d143fe998d3c3d2a93d9",
        "question": "Can a static inline variable be non-constant?",
        "answer": "Yes, it's just a regular variable.",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["Yes, it's just a regular variable."],
        "options": ["Yes, it's just a regular variable.", "No, inline variables must be constant."],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "45a702f6094acd343ea60140",
        "question": "Consider the following code:\n```cpp\nstruct C {\n    C(int x) : a(x) { }\n    int a { 10 };\n    int b { 42 };\n};\nC c(0);\n```",
        "answer": "C::a is initialized only once with 0 in the constructor.",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["C::a is initialized only once with 0 in the constructor."],
        "options": [
          "C::a is initialized twice. The first time, it's initialized with 10, and then the second time with 0 in the constructor.",
          "C::a is initialized only once with 0 in the constructor.",
          "The code doesn't compile because the compiler cannot decide how to initialize the C::a member.",
          "2 bytes"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "1164f1a7f076a65892ceab85",
        "question": "What happens when you throw an exception from a constructor?",
        "answer": "The object is considered \"partially created,\" and thus, the compiler won't call its destructor.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "The object is considered \"partially created,\" and thus, the compiler won't call its destructor."
        ],
        "options": [
          "The object is considered \"created\" so it will follow the regular lifetime of an object.",
          "The object is considered \"partially created,\" and thus, the compiler won't call its destructor.",
          "he compiler calls std::terminate as you cannot throw exceptions from constructors."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "afb1d8a90ce89588f7df995f",
        "question": "What happens when you compile this code?\n```cpp\nstruct Point { int x; int y; };\nPoint pt {.y = 10, .x = 11 };\nstd::cout << pt.x << \", \" << pt.y;\n```",
        "answer": "The code doesn't compile. Designators have to be in the same order as the data members in the Point class.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "The code doesn't compile. Designators have to be in the same order as the data members in the Point class."
        ],
        "options": [
          "The code doesn't compile. Designators have to be in the same order as the data members in the Point class.",
          "The code compiles and prints 11, 10.",
          "The code compiles and prints 10, 11."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "46fa3ab041c29c692914baea",
        "question": "Will this code work in C++11?\n```cpp\nstruct User { std::string name = \"unknown\"; unsigned age { 0 }; };\nUser u { \"John\", 101 };\n```",
        "answer": "The code compiles starting with C++14 mode.",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["The code compiles starting with C++14 mode."],
        "options": [
          "Yes, the code compiles in C++11 mode.",
          "The code compiles starting with C++14 mode.",
          "The code doesn't compile even in C++20."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "93abfc08b4a8d11cae1895f9",
        "question": "Assume you have a std::map<string, int> m;. Select the single true statement about the following loop:\n```cpp\nfor (const pair<string, int>& elem : m)\n```",
        "answer": "A The loop properly iterates over the map, creating no extra copies.",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["A The loop properly iterates over the map, creating no extra copies."],
        "options": [
          "A The loop properly iterates over the map, creating no extra copies.",
          "B The loop will create a copy of each element in the map as the type of elem mismatches.",
          "C The code won't compile as a const pair cannot bind to a map."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "9ae89ad4d90c30d048137ec1",
        "question": "Identify the correct extension of the user-defined header file in C++.",
        "answer": ".h",
        "explanation": null,
        "hint": null,
        "correctAnswer": [".h"],
        "options": [".cpp", ".hg", ".h", ".hf"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "22cba7e22e79d19f012bffc5",
        "question": "Identify the incorrect constructor type.\n```cpp\nauto x = 4000.22;\n```",
        "answer": "Friend Constructor",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["Friend Constructor"],
        "options": [
          "Friend Constructor",
          "Default Constructor",
          "Parameterised Constructor",
          "CopyConstructor"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "8587d7250f8d2963dd25e973",
        "question": "Which of the following data types is supported in C++ but not in C?",
        "answer": "bool",
        "explanation": "[Reference]: https://stackoverflow.com/questions/1608318/is-bool-a-native-c-type",
        "hint": null,
        "correctAnswer": ["bool"],
        "options": ["bool", "int", "double", "float"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "a231ec18c34d594afb2022c5",
        "question": "Identify the correct syntax for declaring arrays in C++.",
        "answer": "int arr[10]",
        "explanation": "[Reference]: (https://en.cppreference.com/w/cpp/language/array)",
        "hint": null,
        "correctAnswer": ["int arr[10]"],
        "options": ["int arr[10]", "array arr[10]", "array{10}", "int arr"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "0ebe8413f5add0989ae6c500",
        "question": "Size of wchat_t is.",
        "answer": "Depends on the number of bits in the system",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["Depends on the number of bits in the system"],
        "options": ["2", "4", "2 or 4", "Depends on the number of bits in the system"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "f1cb64f5e50901d40bad55ab",
        "question": "Which of the following loops is best when we know the number of iterations?",
        "answer": "for",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["for"],
        "options": ["while", "for", "do", "All of the above"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "c0a12db05d03ca8d284b3e26",
        "question": "Which keyword is used to define the macros in C++?",
        "answer": "#define",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["#define"],
        "options": ["#macro", "#define", "macro", "keyword"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "4708468f7b3f946b5e50d531",
        "question": "Which of the following operators should be preferred to overload as a global function rather than a member method?",
        "answer": "Comparison Operator",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["Comparison Operator"],
        "options": ["Postfix ++", "Comparison Operator", "Insertion Operator <<", "Prefix++"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "88d08bc7758ddbb9ddf36d05",
        "question": "How can we restrict the dynamic allocation of objects of a class using new?",
        "answer": "By making an empty private new and new[] operators",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["By making an empty private new and new[] operators"],
        "options": [
          "By overloading new operator",
          "By making an empty private new operator.",
          "By making an empty private new and new[] operators",
          "By overloading new operators and new[] operators"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "000f9192f6f0ce83ae4bd9a7",
        "question": "What is the time complexity of the below code?\n```cpp\nfor(int i=0;i<n;i++){\n   for(int j=0;j<n;j++){\n       cout<<\"hello\";\n    }\n}\n```",
        "answer": "O(n^2)",
        "explanation": "[Reference](<https://medium.com/enjoy-algorithm/analysis-of-loop-in-programming-cc9a644ef8cd#:~:text=At%20each%20step%20of%20the%20iteration%2C%20the%20nested%20loop%20is,%20%3D%20O(n%C2%B2)>)",
        "hint": null,
        "correctAnswer": ["O(n^2)"],
        "options": ["O(n^3)", "O(n^2)", "O(n)", "O(1)"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "201f6eb93de2425476399e2e",
        "question": "What is the output of the code given below?\n```cpp\nint a=10;\nint k=++a;\nint m=a++;\ncout<<k+m;\n```",
        "answer": "22",
        "explanation": "Both **++a** and **a++** increase the value of a by 1 (ie: 11) and hence k+m becomes 22.",
        "hint": null,
        "correctAnswer": ["22"],
        "options": ["20", "21", "22", "23"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "091e55afd2fbb7ec4e1c91d5",
        "question": "Which C++ construct is used for exception handling?",
        "answer": "try-catch",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["try-catch"],
        "options": ["try-catch", "if-else", "for loop", "switch-case"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "0fca68902b86d9217d8e8b77",
        "question": "What is the purpose of the `break` statement in a loop in C++?",
        "answer": "Terminate the loop",
        "explanation": "[Reference]: (https://www.tutorialspoint.com/cprogramming/c_break_statement.htm)",
        "hint": null,
        "correctAnswer": ["Terminate the loop"],
        "options": [
          "Exit the program",
          "Skip the current iteration and continue with the next one",
          "Terminate the loop",
          "Return a value"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "ed3f52a9b88618e52c36225d",
        "question": "In C++, what is the purpose of the `const` keyword when used with a variable?",
        "answer": "It makes the variable immutable",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["It makes the variable immutable"],
        "options": [
          "It makes the variable immutable",
          "It changes the data type",
          "It defines a constant function",
          "It makes the variable a pointer"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "e53b82a3ff66a34769abfc35",
        "question": "Which is more effective while calling the C++ functions??",
        "answer": "Call by reference",
        "explanation": "[Reference]: (https://www.algbly.com/More/MCQs/Cpp-mcq/Cpp-functions.html)",
        "hint": null,
        "correctAnswer": ["Call by reference"],
        "options": ["Call by reference", "Call by value", "Call by pointer", "Call by object"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "6dfe4bdfd0f9950cb40148ae",
        "question": "What will be the output of the following C++ program?\n```cpp\n#include <iostream>\nusing namespace std;\nclass A{\npublic:\n    A(){\n        cout<<\"Constructor called\\n\";\n       }\n    ~A(){\n        cout<<\"Destructor called\\n\";\n        }\n};\nint main(int argc, char const *argv[])\n{\n    A *a = new A[5];\n    delete[] a;\n    return 0;\n}\n```",
        "answer": "\u201cConstructor called\u201d five times and then \u201cDestructor called\u201d five times",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "\u201cConstructor called\u201d five times and then \u201cDestructor called\u201d five times"
        ],
        "options": [
          "Segmentation fault",
          "\u201cConstructor called\u201d five times and then \u201cDestructor called\u201d five times",
          "\u201cConstructor called\u201d five times and then \u201cDestructor called\u201d once",
          "Error"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "b27e920f93f91382625a472d",
        "question": "Which choice is _not_ related to declaring the member variable count as static in my_class?\n```cpp\nclass my_class{\n    public: static int count;\n}\n```",
        "answer": "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it."
        ],
        "options": [
          "All objects that try to access their count member variable actually refer to the only class-bound static count variable.",
          "The variable exists even when no objects of the class have been defined, so it can be modified at any point in the source code.",
          "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it.",
          "The variable is allocated only once, regardless of how many objects are instantiated, because it is bound to the class itself, not its instances."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "19db87edd1bd13cd4da28603",
        "question": "What is the purpose of the `constexpr` keyword in C++?",
        "answer": "`constexpr` is used to indicate that an expression can be evaluated at compile-time, making it suitable for use in constant expressions.",
        "explanation": "[Ref](https://learn.microsoft.com/en-us/cpp/cpp/constexpr-cpp?view=msvc-170#:~:text=constexpr%20indicates%20that%20the%20value,template%20arguments%20and%20array%20declarations.)",
        "hint": null,
        "correctAnswer": [
          "`constexpr` is used to indicate that an expression can be evaluated at compile-time, making it suitable for use in constant expressions."
        ],
        "options": [
          "It is used to define constants in C++.",
          "`constexpr` is used to specify that a variable is a constant pointer.",
          "`constexpr` is used to indicate that an expression can be evaluated at compile-time, making it suitable for use in constant expressions.",
          "It is a keyword used to create asynchronous functions."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "a58214addebf2b9faf27d972",
        "question": "What is a template metaprogram in C++?\n- Ref(https://www.geeksforgeeks.org/template-metaprogramming-in-c/)",
        "answer": "A template metaprogram is a compile-time computation, where templates and template specialization are used to perform computations at compile time.",
        "explanation": null,
        "hint": null,
        "correctAnswer": [
          "A template metaprogram is a compile-time computation, where templates and template specialization are used to perform computations at compile time."
        ],
        "options": [
          "A template metaprogram is a high-level programming language.",
          "It refers to metaprogramming that uses templates in C++.",
          "It's a type of user interface design pattern.",
          "A template metaprogram is a compile-time computation, where templates and template specialization are used to perform computations at compile time."
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "90e31e1dbeb315e76a81ca3a",
        "question": "Identify the correct example for a pre-increment operator.",
        "answer": "++i",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["++i"],
        "options": ["++i", "i++", "--i", "+i"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "2174fb6a180d8f76dc6fbf9a",
        "question": "What will be the output of following code?\n```cpp\n{% raw %}\nint matrix[3][3] = {{1, 2, 3},{4, 5, 6},{7, 8, 9}};\nfor(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n        int a = matrix[i][j];\n        matrix[i][j] = matrix[j][i];\n        matrix[j][i] = a;\n    }\n}\n{% endraw %}\n```",
        "answer": "Same matrix",
        "explanation": null,
        "hint": null,
        "correctAnswer": ["Same matrix"],
        "options": [
          "Transpose of matrix",
          "Same matrix",
          "Mirror image of Matrix",
          "Inverted matrix"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "3d1d630369a9837476c211c2",
        "question": "What is a race condition in C++?",
        "answer": "A condition where multiple threads access shared data concurrently, and the outcome depends on the timing of their execution",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/memory_model)",
        "hint": null,
        "correctAnswer": [
          "A condition where multiple threads access shared data concurrently, and the outcome depends on the timing of their execution"
        ],
        "options": [
          "A condition where the program runs faster than expected",
          "A condition where multiple threads access shared data concurrently, and the outcome depends on the timing of their execution",
          "A condition where two threads compete for CPU time",
          "A condition where a loop executes too quickly and needs to be slowed down"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "a47ef4dddd9e1f4ce0caba56",
        "question": "Consider the following code that has a race condition. What is the correct way to fix it?\n```cpp\n#include <thread>\n#include <vector>\nint counter = 0;\nvoid incrementCounter() {\n    for(int i = 0; i < 1000; i++) {\n        counter++;\n    }\n}\nint main() {\n    std::vector<std::thread> threads;\n    for(int i = 0; i < 10; i++) {\n        threads.push_back(std::thread(incrementCounter));\n    }\n    for(auto& t : threads) {\n        t.join();\n    }\n    return 0;\n}\n```",
        "answer": "Use `std::mutex` to lock/unlock around `counter++` in the critical section",
        "explanation": "[Reference](https://en.cppreference.com/w/cpp/thread/mutex)",
        "hint": null,
        "correctAnswer": [
          "Use `std::mutex` to lock/unlock around `counter++` in the critical section"
        ],
        "options": [
          "Add `volatile` keyword: `volatile int counter = 0;`",
          "Use `std::mutex` to lock/unlock around `counter++` in the critical section",
          "Use `std::this_thread::sleep_for()` to delay each increment",
          "Change `counter++` to `++counter` for atomic operation"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "a7f7ed656a36df336d05b0b8",
        "question": "Quel est le but de `std::move` en C++11 ?",
        "answer": "Convertir un objet en r\u00e9f\u00e9rence rvalue, permettant la s\u00e9mantique de d\u00e9placement",
        "explanation": "**Explication :**\n`std::move` est un cast qui produit une r\u00e9f\u00e9rence rvalue \u00e0 son argument, permettant aux ressources d'\u00eatre d\u00e9plac\u00e9es plut\u00f4t que copi\u00e9es. Il ne d\u00e9place rien lui-m\u00eame, mais permet l'appel des constructeurs de d\u00e9placement et des op\u00e9rateurs d'affectation de d\u00e9placement.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/utility/move)",
        "hint": null,
        "correctAnswer": [
          "Convertir un objet en r\u00e9f\u00e9rence rvalue, permettant la s\u00e9mantique de d\u00e9placement"
        ],
        "options": [
          "Copier un objet vers un nouvel emplacement",
          "Convertir un objet en r\u00e9f\u00e9rence rvalue, permettant la s\u00e9mantique de d\u00e9placement",
          "D\u00e9placer physiquement la m\u00e9moire d'une adresse \u00e0 une autre",
          "Supprimer un objet et en cr\u00e9er un nouveau"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "8cc4f4a63d764473f71f15fe",
        "question": "Quel est le r\u00e9sultat de ce code ?\n```cpp\n#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v1 = {1, 2, 3};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v1.size() << \" \" << v2.size();\n    return 0;\n}\n```",
        "answer": "0 3",
        "explanation": "**Explication :**\nApr\u00e8s `std::move(v1)`, v1 est dans un \u00e9tat valide mais non sp\u00e9cifi\u00e9. Typiquement, il devient vide (taille 0) et v2 prend possession des \u00e9l\u00e9ments.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/utility/move)",
        "hint": null,
        "correctAnswer": ["0 3"],
        "options": ["3 3", "0 3", "3 0", "Erreur de compilation"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "20852badf79b8f82e7a903fb",
        "question": "Qu'est-ce qu'une expression lambda en C++ ?",
        "answer": "Un objet fonction anonyme qui peut capturer des variables de sa port\u00e9e englobante",
        "explanation": "**Explication :**\nLes expressions lambda, introduites en C++11, permettent d'\u00e9crire des fonctions anonymes en ligne. Elles peuvent capturer des variables de la port\u00e9e environnante et sont souvent utilis\u00e9es avec les algorithmes STL.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/lambda)",
        "hint": null,
        "correctAnswer": [
          "Un objet fonction anonyme qui peut capturer des variables de sa port\u00e9e englobante"
        ],
        "options": [
          "Une fonction math\u00e9matique",
          "Un objet fonction anonyme qui peut capturer des variables de sa port\u00e9e englobante",
          "Une fonction template",
          "Une d\u00e9finition de macro"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "9a8e55b7901ef47df0a6c0fd",
        "question": "Que fait le mot-cl\u00e9 `auto` en C++11 ?",
        "answer": "D\u00e9duit automatiquement le type d'une variable \u00e0 partir de son initialiseur",
        "explanation": "**Explication :**\nLe mot-cl\u00e9 `auto` en C++11 permet la d\u00e9duction automatique du type \u00e0 partir de l'initialiseur, rendant le code plus concis et plus facile \u00e0 maintenir.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/auto)",
        "hint": null,
        "correctAnswer": [
          "D\u00e9duit automatiquement le type d'une variable \u00e0 partir de son initialiseur"
        ],
        "options": [
          "Donne \u00e0 une variable une dur\u00e9e de stockage automatique",
          "D\u00e9duit automatiquement le type d'une variable \u00e0 partir de son initialiseur",
          "Rend une fonction inline",
          "D\u00e9clare une variable globale"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "3340cdd907a86ebe6ba515e3",
        "question": "Quelle est la diff\u00e9rence entre `std::unique_ptr` et `std::shared_ptr` ?",
        "answer": "unique_ptr a une propri\u00e9t\u00e9 exclusive, shared_ptr permet plusieurs propri\u00e9taires",
        "explanation": "**Explication :**\n`std::unique_ptr` fournit une propri\u00e9t\u00e9 exclusive - un seul unique_ptr peut poss\u00e9der une ressource. `std::shared_ptr` utilise le comptage de r\u00e9f\u00e9rences pour permettre \u00e0 plusieurs shared_ptrs de poss\u00e9der la m\u00eame ressource.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/memory/unique_ptr)",
        "hint": null,
        "correctAnswer": [
          "unique_ptr a une propri\u00e9t\u00e9 exclusive, shared_ptr permet plusieurs propri\u00e9taires"
        ],
        "options": [
          "unique_ptr a une propri\u00e9t\u00e9 exclusive, shared_ptr permet plusieurs propri\u00e9taires",
          "unique_ptr est plus rapide mais moins s\u00fbr",
          "shared_ptr ne peut \u00eatre utilis\u00e9 qu'avec des classes",
          "Il n'y a pas de diff\u00e9rence"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "743af7080ffd126dec0ad60f",
        "question": "Qu'est-ce que RAII en C++ ?",
        "answer": "Resource Acquisition Is Initialization (L'acquisition de ressource est l'initialisation)",
        "explanation": "**Explication :**\nRAII est un idiome de programmation C++ o\u00f9 l'acquisition de ressource est li\u00e9e \u00e0 la dur\u00e9e de vie de l'objet. Les ressources sont acquises dans les constructeurs et lib\u00e9r\u00e9es dans les destructeurs, garantissant un nettoyage appropri\u00e9.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/raii)",
        "hint": null,
        "correctAnswer": [
          "Resource Acquisition Is Initialization (L'acquisition de ressource est l'initialisation)"
        ],
        "options": [
          "Random Access Iterator Interface",
          "Resource Acquisition Is Initialization (L'acquisition de ressource est l'initialisation)",
          "Recursive Algorithm Implementation Interface",
          "Runtime Allocation and Initialization"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "3ef8bfe122a34508fdaaa5c1",
        "question": "Quel est le r\u00e9sultat de ce code ?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    auto lambda = [x]() mutable { x += 10; return x; };\n    std::cout << lambda() << \" \" << x;\n    return 0;\n}\n```",
        "answer": "15 5",
        "explanation": "**Explication :**\nLa lambda capture x par valeur. Le mot-cl\u00e9 `mutable` permet de modifier la copie captur\u00e9e. Le x original reste inchang\u00e9.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/lambda)",
        "hint": null,
        "correctAnswer": ["15 5"],
        "options": ["5 5", "15 5", "15 15", "5 15"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "3bd8308d6abf53c24f318627",
        "question": "Qu'est-ce que `constexpr` en C++11 ?",
        "answer": "Sp\u00e9cifie qu'une fonction ou variable peut \u00eatre \u00e9valu\u00e9e au moment de la compilation",
        "explanation": "**Explication :**\n`constexpr` indique qu'une valeur ou fonction peut \u00eatre \u00e9valu\u00e9e au moment de la compilation, permettant le calcul et l'optimisation \u00e0 la compilation.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/constexpr)",
        "hint": null,
        "correctAnswer": [
          "Sp\u00e9cifie qu'une fonction ou variable peut \u00eatre \u00e9valu\u00e9e au moment de la compilation"
        ],
        "options": [
          "Une expression constante qui ne peut \u00eatre utilis\u00e9e qu'avec des entiers",
          "Sp\u00e9cifie qu'une fonction ou variable peut \u00eatre \u00e9valu\u00e9e au moment de la compilation",
          "Une macro pour d\u00e9finir des constantes",
          "Un mot-cl\u00e9 pour d\u00e9clarer des pointeurs const"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "7d46d8e9363851e014c6972d",
        "question": "Quel est le but de `std::forward` ?",
        "answer": "Pr\u00e9server la cat\u00e9gorie de valeur (lvalue/rvalue) d'un argument transmis",
        "explanation": "**Explication :**\n`std::forward` est utilis\u00e9 dans les fonctions template pour transmettre parfaitement les arguments tout en pr\u00e9servant leur cat\u00e9gorie de valeur, essentiel pour impl\u00e9menter le perfect forwarding.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/utility/forward)",
        "hint": null,
        "correctAnswer": [
          "Pr\u00e9server la cat\u00e9gorie de valeur (lvalue/rvalue) d'un argument transmis"
        ],
        "options": [
          "D\u00e9placer un objet vers l'avant en m\u00e9moire",
          "Pr\u00e9server la cat\u00e9gorie de valeur (lvalue/rvalue) d'un argument transmis",
          "It\u00e9rer vers l'avant dans un conteneur",
          "D\u00e9clarer une d\u00e9claration forward"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "01d25de6c5cd691c1204ea7f",
        "question": "Qu'est-ce qu'un template variadique ?",
        "answer": "Un template qui accepte un nombre variable de param\u00e8tres template",
        "explanation": "**Explication :**\nLes templates variadiques, introduits en C++11, permettent aux templates d'accepter un nombre quelconque d'arguments template, permettant une programmation g\u00e9n\u00e9rique flexible.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/parameter_pack)",
        "hint": null,
        "correctAnswer": ["Un template qui accepte un nombre variable de param\u00e8tres template"],
        "options": [
          "Un template avec des types de retour variables",
          "Un template qui accepte un nombre variable de param\u00e8tres template",
          "Un template qui peut \u00eatre instanci\u00e9 plusieurs fois",
          "Un template avec des param\u00e8tres optionnels"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "f27287fe8acfaf20bca4dde4",
        "question": "Que repr\u00e9sente `nullptr` ?",
        "answer": "Une constante de pointeur nul avec le type std::nullptr_t",
        "explanation": "**Explication :**\n`nullptr` est un mot-cl\u00e9 introduit en C++11 qui repr\u00e9sente un pointeur nul. Il est s\u00fbr au niveau du type contrairement \u00e0 NULL ou 0.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/nullptr)",
        "hint": null,
        "correctAnswer": ["Une constante de pointeur nul avec le type std::nullptr_t"],
        "options": [
          "Un caract\u00e8re nul",
          "Une constante de pointeur nul avec le type std::nullptr_t",
          "Une cha\u00eene vide",
          "Une valeur z\u00e9ro"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "bc337065470a06dfb063d629",
        "question": "Quel est le r\u00e9sultat de ce code ?\n```cpp\n#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> p1 = std::make_shared<int>(42);\n    std::shared_ptr<int> p2 = p1;\n    std::cout << p1.use_count();\n    return 0;\n}\n```",
        "answer": "2",
        "explanation": "**Explication :**\np1 et p2 partagent la propri\u00e9t\u00e9 du m\u00eame entier, donc le compteur de r\u00e9f\u00e9rences est 2.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/memory/shared_ptr)",
        "hint": null,
        "correctAnswer": ["2"],
        "options": ["1", "2", "42", "0"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "30b310173a11072c289a5a6c",
        "question": "Qu'est-ce que `std::optional` en C++17 ?",
        "answer": "Un wrapper qui peut ou non contenir une valeur",
        "explanation": "**Explication :**\n`std::optional` est une classe template qui repr\u00e9sente une valeur optionnelle - elle contient soit une valeur soit est vide, fournissant un moyen s\u00fbr au niveau du type pour repr\u00e9senter \"aucune valeur\".\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/utility/optional)",
        "hint": null,
        "correctAnswer": ["Un wrapper qui peut ou non contenir une valeur"],
        "options": [
          "Un param\u00e8tre optionnel dans une fonction",
          "Un wrapper qui peut ou non contenir une valeur",
          "Un template pour la compilation optionnelle",
          "Un mot-cl\u00e9 pour les types optionnels"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "2fb2fdb28ed5884ab5196467",
        "question": "Qu'est-ce que la liaison structur\u00e9e en C++17 ?\n```cpp\nauto [x, y, z] = std::make_tuple(1, 2, 3);\n```",
        "answer": "Une fonctionnalit\u00e9 qui d\u00e9compresse des objets de type tuple en variables individuelles",
        "explanation": "**Explication :**\nLes liaisons structur\u00e9es permettent de d\u00e9composer les objets en leurs \u00e9l\u00e9ments constitutifs, rendant le code plus lisible lors du travail avec des tuples, paires ou structures.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/structured_binding)",
        "hint": null,
        "correctAnswer": [
          "Une fonctionnalit\u00e9 qui d\u00e9compresse des objets de type tuple en variables individuelles"
        ],
        "options": [
          "Un moyen de lier des structures ensemble",
          "Une fonctionnalit\u00e9 qui d\u00e9compresse des objets de type tuple en variables individuelles",
          "Une m\u00e9thode pour cr\u00e9er des donn\u00e9es structur\u00e9es",
          "Une liaison pour les membres de struct"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "b067f55187b5e7c7bd24a8d4",
        "question": "Qu'est-ce que `std::string_view` en C++17 ?",
        "answer": "Une r\u00e9f\u00e9rence non propri\u00e9taire \u00e0 une cha\u00eene qui \u00e9vite la copie",
        "explanation": "**Explication :**\n`std::string_view` fournit une r\u00e9f\u00e9rence l\u00e9g\u00e8re et non propri\u00e9taire \u00e0 une cha\u00eene, \u00e9vitant les copies inutiles et am\u00e9liorant les performances.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/string/basic_string_view)",
        "hint": null,
        "correctAnswer": [
          "Une r\u00e9f\u00e9rence non propri\u00e9taire \u00e0 une cha\u00eene qui \u00e9vite la copie"
        ],
        "options": [
          "Une vue d'une cha\u00eene dans une interface graphique",
          "Une r\u00e9f\u00e9rence non propri\u00e9taire \u00e0 une cha\u00eene qui \u00e9vite la copie",
          "Une cha\u00eene qui ne peut \u00eatre que visualis\u00e9e, pas modifi\u00e9e",
          "Une classe de vue pour afficher des cha\u00eenes"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "53f2240bfa18c96ef1070445",
        "question": "Que sont les concepts en C++20 ?",
        "answer": "Des ensembles nomm\u00e9s d'exigences pour les param\u00e8tres template",
        "explanation": "**Explication :**\nLes concepts sont une fonctionnalit\u00e9 de C++20 qui permet de sp\u00e9cifier des contraintes sur les param\u00e8tres template, rendant le code template plus lisible et fournissant de meilleurs messages d'erreur.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/constraints)",
        "hint": null,
        "correctAnswer": [
          "Des ensembles nomm\u00e9s d'exigences pour les param\u00e8tres template"
        ],
        "options": [
          "Des id\u00e9es abstraites en programmation",
          "Des ensembles nomm\u00e9s d'exigences pour les param\u00e8tres template",
          "Des mod\u00e8les de conception conceptuels",
          "Des commentaires de documentation"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "29885665dde66717df6fcd39",
        "question": "Qu'est-ce que l'op\u00e9rateur de comparaison \u00e0 trois voies (<=>) en C++20 ?",
        "answer": "Un op\u00e9rateur qui retourne des informations d'ordre (inf\u00e9rieur, \u00e9gal, sup\u00e9rieur)",
        "explanation": "**Explication :**\nL'op\u00e9rateur vaisseau spatial (<=>) effectue une comparaison \u00e0 trois voies et retourne une cat\u00e9gorie d'ordre, simplifiant les d\u00e9finitions d'op\u00e9rateurs de comparaison.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/operator_comparison)",
        "hint": null,
        "correctAnswer": [
          "Un op\u00e9rateur qui retourne des informations d'ordre (inf\u00e9rieur, \u00e9gal, sup\u00e9rieur)"
        ],
        "options": [
          "Une comparaison de trois valeurs",
          "Un op\u00e9rateur qui retourne des informations d'ordre (inf\u00e9rieur, \u00e9gal, sup\u00e9rieur)",
          "Trois op\u00e9rateurs de comparaison s\u00e9par\u00e9s",
          "Une comparaison ternaire"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "a91c1c25286e36ad99a6dea4",
        "question": "Qu'est-ce que `std::span` en C++20 ?",
        "answer": "Une vue non propri\u00e9taire sur une s\u00e9quence contigu\u00eb d'objets",
        "explanation": "**Explication :**\n`std::span` fournit une vue sur une s\u00e9quence contigu\u00eb d'objets sans les poss\u00e9der, utile pour passer des donn\u00e9es de type tableau sans copie.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/container/span)",
        "hint": null,
        "correctAnswer": [
          "Une vue non propri\u00e9taire sur une s\u00e9quence contigu\u00eb d'objets"
        ],
        "options": [
          "Une mesure de temps",
          "Une vue non propri\u00e9taire sur une s\u00e9quence contigu\u00eb d'objets",
          "Une structure de donn\u00e9es d'arbre couvrant",
          "Un \u00e9l\u00e9ment span en HTML"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "7313983624a4c34bbc90ecf5",
        "question": "Quel est le r\u00e9sultat de ce code ?\n```cpp\n#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v = {1, 2, 3, 4, 5};\n    for (auto& x : v) {\n        x *= 2;\n    }\n    std::cout << v[2];\n    return 0;\n}\n```",
        "answer": "6",
        "explanation": "**Explication :**\nLa boucle for bas\u00e9e sur la plage avec `auto&` modifie chaque \u00e9l\u00e9ment sur place. v[2] (originellement 3) devient 6.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/range-for)",
        "hint": null,
        "correctAnswer": ["6"],
        "options": ["3", "6", "2", "12"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "1920d1d596a49f28701114ae",
        "question": "Qu'est-ce que `std::variant` en C++17 ?",
        "answer": "Une union s\u00fbre au niveau du type qui peut contenir un de plusieurs types",
        "explanation": "**Explication :**\n`std::variant` est une union s\u00fbre au niveau du type qui peut contenir une valeur de l'un des plusieurs types sp\u00e9cifi\u00e9s, fournissant une alternative plus s\u00fbre aux unions C.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/utility/variant)",
        "hint": null,
        "correctAnswer": [
          "Une union s\u00fbre au niveau du type qui peut contenir un de plusieurs types"
        ],
        "options": [
          "Une variable qui peut varier",
          "Une union s\u00fbre au niveau du type qui peut contenir un de plusieurs types",
          "Une variante d'une classe",
          "Un template de variable"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "c56f13c0d3a6887dd23ab76b",
        "question": "Qu'est-ce que `std::any` en C++17 ?",
        "answer": "Un conteneur s\u00fbr au niveau du type pour des valeurs uniques de n'importe quel type",
        "explanation": "**Explication :**\n`std::any` peut stocker une valeur unique de n'importe quel type copiable par construction, fournissant un stockage s\u00fbr au niveau du type avec v\u00e9rification de type \u00e0 l'ex\u00e9cution.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/utility/any)",
        "hint": null,
        "correctAnswer": [
          "Un conteneur s\u00fbr au niveau du type pour des valeurs uniques de n'importe quel type"
        ],
        "options": [
          "N'importe quel type de variable",
          "Un conteneur s\u00fbr au niveau du type pour des valeurs uniques de n'importe quel type",
          "Un type g\u00e9n\u00e9rique",
          "Un type optionnel"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "31c8f4faa8dffe9af67eb063",
        "question": "Quelle est la diff\u00e9rence entre `std::array` et les tableaux de style C ?",
        "answer": "std::array conna\u00eet sa taille et fournit des fonctions membres",
        "explanation": "**Explication :**\n`std::array` est un conteneur qui encapsule des tableaux de taille fixe, fournissant des informations sur la taille et l'interface de conteneur STL tout en maintenant les performances des tableaux de style C.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/container/array)",
        "hint": null,
        "correctAnswer": ["std::array conna\u00eet sa taille et fournit des fonctions membres"],
        "options": [
          "std::array conna\u00eet sa taille et fournit des fonctions membres",
          "std::array est plus lent",
          "Les tableaux de style C sont plus s\u00fbrs",
          "Il n'y a pas de diff\u00e9rence"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "1e69ca48a48169f45273a5b3",
        "question": "Qu'est-ce que le perfect forwarding ?",
        "answer": "La pr\u00e9servation de la cat\u00e9gorie de valeur des arguments lors de leur transmission \u00e0 une autre fonction",
        "explanation": "**Explication :**\nLe perfect forwarding utilise `std::forward` et des r\u00e9f\u00e9rences universelles pour passer des arguments \u00e0 une autre fonction tout en pr\u00e9servant leur cat\u00e9gorie de valeur (lvalue ou rvalue).\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/utility/forward)",
        "hint": null,
        "correctAnswer": [
          "La pr\u00e9servation de la cat\u00e9gorie de valeur des arguments lors de leur transmission \u00e0 une autre fonction"
        ],
        "options": [
          "La transmission sans erreurs",
          "La pr\u00e9servation de la cat\u00e9gorie de valeur des arguments lors de leur transmission \u00e0 une autre fonction",
          "Le passage rapide de param\u00e8tres",
          "La d\u00e9claration forward de fonctions"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "e5af42b9f67144aea585ac89",
        "question": "Quel est le r\u00e9sultat de ce code ?\n```cpp\n#include <iostream>\ntemplate<typename T>\nvoid func(T&& x) {\n    std::cout << std::is_lvalue_reference<T>::value;\n}\nint main() {\n    int a = 5;\n    func(a);\n    return 0;\n}\n```",
        "answer": "1",
        "explanation": "**Explication :**\nLorsqu'une lvalue est pass\u00e9e \u00e0 une r\u00e9f\u00e9rence universelle, T est d\u00e9duit comme une r\u00e9f\u00e9rence lvalue, donc `std::is_lvalue_reference<T>::value` est vrai (1).\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/reference)",
        "hint": null,
        "correctAnswer": ["1"],
        "options": ["1", "0", "5", "Erreur de compilation"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "ba9a67abc191114092a9235f",
        "question": "Qu'est-ce que `std::invoke` en C++17 ?",
        "answer": "Un utilitaire pour appeler n'importe quel objet appelable avec des arguments donn\u00e9s",
        "explanation": "**Explication :**\n`std::invoke` fournit un moyen uniforme d'appeler n'importe quel appelable (fonction, pointeur de fonction, fonction membre, foncteur) avec des arguments.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/utility/functional/invoke)",
        "hint": null,
        "correctAnswer": [
          "Un utilitaire pour appeler n'importe quel objet appelable avec des arguments donn\u00e9s"
        ],
        "options": [
          "Une fonction pour invoquer des programmes",
          "Un utilitaire pour appeler n'importe quel objet appelable avec des arguments donn\u00e9s",
          "Un op\u00e9rateur d'invocation de m\u00e9thode",
          "Un invocateur pour les constructeurs"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "043beff36fc581c66c63241d",
        "question": "Qu'est-ce que `if constexpr` en C++17 ?",
        "answer": "Une condition \u00e0 la compilation qui \u00e9limine les branches \u00e0 la compilation",
        "explanation": "**Explication :**\n`if constexpr` \u00e9value la condition \u00e0 la compilation et n'instancie que la branche prise, utile dans la m\u00e9taprogrammation template.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/if)",
        "hint": null,
        "correctAnswer": [
          "Une condition \u00e0 la compilation qui \u00e9limine les branches \u00e0 la compilation"
        ],
        "options": [
          "Une instruction if constante",
          "Une condition \u00e0 la compilation qui \u00e9limine les branches \u00e0 la compilation",
          "Une instruction if qui doit \u00eatre constante",
          "Une fonction constexpr avec if"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "599382629f503e2c80ecbcf8",
        "question": "Qu'est-ce qu'une expression de pliage en C++17 ?",
        "answer": "Un moyen d'appliquer un op\u00e9rateur binaire \u00e0 tous les \u00e9l\u00e9ments d'un paquet de param\u00e8tres",
        "explanation": "**Explication :**\nLes expressions de pliage fournissent une syntaxe concise pour appliquer des op\u00e9rateurs binaires aux paquets de param\u00e8tres dans les templates variadiques.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/fold)",
        "hint": null,
        "correctAnswer": [
          "Un moyen d'appliquer un op\u00e9rateur binaire \u00e0 tous les \u00e9l\u00e9ments d'un paquet de param\u00e8tres"
        ],
        "options": [
          "Une expression qui plie le code",
          "Un moyen d'appliquer un op\u00e9rateur binaire \u00e0 tous les \u00e9l\u00e9ments d'un paquet de param\u00e8tres",
          "Un algorithme de pliage",
          "Une expression pour plier des conteneurs"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "7bef424f015945cb9f2e32a1",
        "question": "Quel est le r\u00e9sultat de ce code ?\n```cpp\n#include <iostream>\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int* p = arr;\n    std::cout << *(p + 3);\n    return 0;\n}\n```",
        "answer": "4",
        "explanation": "**Explication :**\nArithm\u00e9tique de pointeur : p + 3 pointe vers le 4\u00e8me \u00e9l\u00e9ment (indice 3), qui est 4.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/operator_arithmetic)",
        "hint": null,
        "correctAnswer": ["4"],
        "options": ["1", "2", "3", "4"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "22ff05cdc46f01b2595e0685",
        "question": "Qu'est-ce que `std::filesystem` en C++17 ?",
        "answer": "Une biblioth\u00e8que pour effectuer des op\u00e9rations sur les syst\u00e8mes de fichiers et les chemins",
        "explanation": "**Explication :**\n`std::filesystem` fournit des facilit\u00e9s pour effectuer des op\u00e9rations sur les syst\u00e8mes de fichiers et leurs composants, tels que les chemins, fichiers r\u00e9guliers et r\u00e9pertoires.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/filesystem)",
        "hint": null,
        "correctAnswer": [
          "Une biblioth\u00e8que pour effectuer des op\u00e9rations sur les syst\u00e8mes de fichiers et les chemins"
        ],
        "options": [
          "Un pilote de syst\u00e8me de fichiers",
          "Une biblioth\u00e8que pour effectuer des op\u00e9rations sur les syst\u00e8mes de fichiers et les chemins",
          "Un syst\u00e8me de fichiers virtuel",
          "Une classe de flux de fichiers"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "9276cb23580621c9a2de695d",
        "question": "\u00c0 quoi sert `std::atomic` ?",
        "answer": "Aux op\u00e9rations thread-safe sur des variables partag\u00e9es sans verrous",
        "explanation": "**Explication :**\n`std::atomic` fournit des op\u00e9rations atomiques sur des variables partag\u00e9es, garantissant un acc\u00e8s thread-safe sans verrouillage explicite.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/atomic/atomic)",
        "hint": null,
        "correctAnswer": [
          "Aux op\u00e9rations thread-safe sur des variables partag\u00e9es sans verrous"
        ],
        "options": [
          "Aux calculs d'\u00e9nergie atomique",
          "Aux op\u00e9rations thread-safe sur des variables partag\u00e9es sans verrous",
          "Aux types de donn\u00e9es atomiques",
          "Aux op\u00e9rations indivisibles sur les atomes"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "ad9ca1d929e6f35fcb46e66e",
        "question": "Quelle est la diff\u00e9rence entre `std::mutex` et `std::recursive_mutex` ?",
        "answer": "recursive_mutex peut \u00eatre verrouill\u00e9 plusieurs fois par le m\u00eame thread",
        "explanation": "**Explication :**\n`std::recursive_mutex` permet au m\u00eame thread de le verrouiller plusieurs fois, tandis que `std::mutex` provoquerait un interblocage si le m\u00eame thread essayait de le verrouiller deux fois.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/thread/recursive_mutex)",
        "hint": null,
        "correctAnswer": [
          "recursive_mutex peut \u00eatre verrouill\u00e9 plusieurs fois par le m\u00eame thread"
        ],
        "options": [
          "recursive_mutex peut \u00eatre verrouill\u00e9 plusieurs fois par le m\u00eame thread",
          "mutex est plus rapide",
          "recursive_mutex est d\u00e9pr\u00e9ci\u00e9",
          "Il n'y a pas de diff\u00e9rence"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "02fd0a8486418dac44516cd5",
        "question": "Qu'est-ce que `std::future` en C++11 ?",
        "answer": "Un objet qui fournit l'acc\u00e8s au r\u00e9sultat d'une op\u00e9ration asynchrone",
        "explanation": "**Explication :**\n`std::future` est utilis\u00e9 pour r\u00e9cup\u00e9rer le r\u00e9sultat d'une op\u00e9ration asynchrone d\u00e9marr\u00e9e avec `std::async` ou `std::promise`.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/thread/future)",
        "hint": null,
        "correctAnswer": [
          "Un objet qui fournit l'acc\u00e8s au r\u00e9sultat d'une op\u00e9ration asynchrone"
        ],
        "options": [
          "Une version future de C++",
          "Un objet qui fournit l'acc\u00e8s au r\u00e9sultat d'une op\u00e9ration asynchrone",
          "Une classe bas\u00e9e sur le temps",
          "Une d\u00e9claration future"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "f72f6fa000b68d215ff59af6",
        "question": "Quel est le r\u00e9sultat de ce code ?\n```cpp\n#include <iostream>\nclass Base {\npublic:\n    virtual void show() { std::cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void show() override { std::cout << \"Derived\"; }\n};\nint main() {\n    Base* b = new Derived();\n    b->show();\n    delete b;\n    return 0;\n}\n```",
        "answer": "Derived",
        "explanation": "**Explication :**\nEn raison du polymorphisme de fonction virtuelle, la m\u00e9thode show() de la classe Derived est appel\u00e9e m\u00eame si le pointeur est de type Base\\*.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/virtual)",
        "hint": null,
        "correctAnswer": ["Derived"],
        "options": ["Base", "Derived", "Erreur de compilation", "Comportement ind\u00e9fini"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "6e8ef083cddebfea8480f56e",
        "question": "\u00c0 quoi sert `std::enable_if` ?",
        "answer": "Pour l'instanciation conditionnelle de template bas\u00e9e sur SFINAE",
        "explanation": "**Explication :**\n`std::enable_if` est utilis\u00e9 pour SFINAE (Substitution Failure Is Not An Error) pour activer ou d\u00e9sactiver conditionnellement les sp\u00e9cialisations de template.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/types/enable_if)",
        "hint": null,
        "correctAnswer": ["Pour l'instanciation conditionnelle de template bas\u00e9e sur SFINAE"],
        "options": [
          "\u00c0 activer les instructions if",
          "Pour l'instanciation conditionnelle de template bas\u00e9e sur SFINAE",
          "\u00c0 activer des fonctionnalit\u00e9s",
          "\u00c0 v\u00e9rifier si quelque chose est activ\u00e9"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "e20761c381d7c00e67d87010",
        "question": "Qu'est-ce que `std::tuple` en C++11 ?",
        "answer": "Une collection de taille fixe de valeurs h\u00e9t\u00e9rog\u00e8nes",
        "explanation": "**Explication :**\n`std::tuple` est une collection de taille fixe qui peut contenir des \u00e9l\u00e9ments de diff\u00e9rents types, g\u00e9n\u00e9ralisant `std::pair` \u00e0 n'importe quel nombre d'\u00e9l\u00e9ments.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/utility/tuple)",
        "hint": null,
        "correctAnswer": ["Une collection de taille fixe de valeurs h\u00e9t\u00e9rog\u00e8nes"],
        "options": [
          "Une paire de deux \u00e9l\u00e9ments",
          "Une collection de taille fixe de valeurs h\u00e9t\u00e9rog\u00e8nes",
          "Un triplet de valeurs",
          "Un tuple en math\u00e9matiques"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "03bf9bf46870462f53fb1a68",
        "question": "Quel est le r\u00e9sultat de ce code ?\n```cpp\n#include <iostream>\nint main() {\n    int x = 10;\n    int& ref = x;\n    ref = 20;\n    std::cout << x;\n    return 0;\n}\n```",
        "answer": "20",
        "explanation": "**Explication :**\nref est une r\u00e9f\u00e9rence \u00e0 x. Modifier ref modifie directement x, donc x devient 20.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/reference)",
        "hint": null,
        "correctAnswer": ["20"],
        "options": ["10", "20", "Erreur de compilation", "Ind\u00e9fini"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "d4b1005faf95eeaef47d5791",
        "question": "\u00c0 quoi sert `std::chrono` ?",
        "answer": "Aux utilitaires de temps incluant horloges, points temporels et dur\u00e9es",
        "explanation": "**Explication :**\n`std::chrono` est une biblioth\u00e8que pour les op\u00e9rations li\u00e9es au temps, fournissant des horloges, points temporels et dur\u00e9es avec s\u00e9curit\u00e9 de type.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/chrono)",
        "hint": null,
        "correctAnswer": [
          "Aux utilitaires de temps incluant horloges, points temporels et dur\u00e9es"
        ],
        "options": [
          "\u00c0 l'ordonnancement chronologique",
          "Aux utilitaires de temps incluant horloges, points temporels et dur\u00e9es",
          "Aux fonctions de chronom\u00e8tre",
          "\u00c0 la gestion des maladies chroniques"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "1d5ba0bb3b2dc444c45945c9",
        "question": "Qu'est-ce que `std::regex` en C++11 ?",
        "answer": "Une biblioth\u00e8que pour la correspondance de motifs d'expressions r\u00e9guli\u00e8res",
        "explanation": "**Explication :**\n`std::regex` fournit un support d'expressions r\u00e9guli\u00e8res pour la correspondance de motifs et le traitement de texte en C++.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/regex)",
        "hint": null,
        "correctAnswer": [
          "Une biblioth\u00e8que pour la correspondance de motifs d'expressions r\u00e9guli\u00e8res"
        ],
        "options": [
          "Un moteur d'expression r\u00e9guli\u00e8re",
          "Une biblioth\u00e8que pour la correspondance de motifs d'expressions r\u00e9guli\u00e8res",
          "Un outil de remplacement de texte",
          "Un formateur de cha\u00eenes"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "b2b6820379de6b0abfdcf278",
        "question": "Qu'est-ce que `std::initializer_list` ?",
        "answer": "Un objet proxy l\u00e9ger pour acc\u00e9der aux tableaux de const T",
        "explanation": "**Explication :**\n`std::initializer_list` permet aux fonctions d'accepter des listes de valeurs entre accolades, permettant une syntaxe d'initialisation uniforme.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/utility/initializer_list)",
        "hint": null,
        "correctAnswer": ["Un objet proxy l\u00e9ger pour acc\u00e9der aux tableaux de const T"],
        "options": [
          "Une liste d'initialisateurs",
          "Un objet proxy l\u00e9ger pour acc\u00e9der aux tableaux de const T",
          "Une fonction d'initialisation",
          "Un constructeur de liste"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "08c0d27537471963776418bd",
        "question": "Quel est le r\u00e9sultat de ce code ?\n```cpp\n#include <iostream>\nint main() {\n    const int x = 10;\n    int* p = const_cast<int*>(&x);\n    *p = 20;\n    std::cout << x;\n    return 0;\n}\n```",
        "answer": "10 (comportement ind\u00e9fini)",
        "explanation": "**Explication :**\nCeci est un comportement ind\u00e9fini. Modifier un objet const via const_cast conduit \u00e0 des r\u00e9sultats impr\u00e9visibles. Le compilateur peut optimiser en se basant sur l'hypoth\u00e8se const.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/const_cast)",
        "hint": null,
        "correctAnswer": ["10 (comportement ind\u00e9fini)"],
        "options": ["10 (comportement ind\u00e9fini)", "20", "Erreur de compilation", "0"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "199614f8889bcc1f50d686d8",
        "question": "Qu'est-ce que `std::function` en C++11 ?",
        "answer": "Un wrapper de fonction polymorphe \u00e0 usage g\u00e9n\u00e9ral",
        "explanation": "**Explication :**\n`std::function` est un wrapper avec effacement de type qui peut stocker n'importe quel objet appelable (fonction, lambda, foncteur) avec une signature sp\u00e9cifique.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/utility/functional/function)",
        "hint": null,
        "correctAnswer": ["Un wrapper de fonction polymorphe \u00e0 usage g\u00e9n\u00e9ral"],
        "options": [
          "Une d\u00e9claration de fonction",
          "Un wrapper de fonction polymorphe \u00e0 usage g\u00e9n\u00e9ral",
          "Un pointeur de fonction",
          "Une biblioth\u00e8que de programmation fonctionnelle"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "51adabf9b1abd8e2d3af8cc7",
        "question": "\u00c0 quoi sert `std::bind` ?",
        "answer": "\u00c0 cr\u00e9er un nouvel appelable en liant des arguments \u00e0 une fonction",
        "explanation": "**Explication :**\n`std::bind` cr\u00e9e un nouvel objet fonction en liant certains arguments \u00e0 une fonction, utile pour l'application partielle de fonction.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/utility/functional/bind)",
        "hint": null,
        "correctAnswer": [
          "\u00c0 cr\u00e9er un nouvel appelable en liant des arguments \u00e0 une fonction"
        ],
        "options": [
          "\u00c0 lier des variables ensemble",
          "\u00c0 cr\u00e9er un nouvel appelable en liant des arguments \u00e0 une fonction",
          "\u00c0 lier des classes",
          "\u00c0 lier de la m\u00e9moire"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "faa8183ee2de6ff43598e690",
        "question": "Sur quoi est bas\u00e9 `std::unordered_map` ?",
        "answer": "Table de hachage",
        "explanation": "**Explication :**\n`std::unordered_map` est impl\u00e9ment\u00e9 en utilisant une table de hachage, fournissant un temps de recherche moyen O(1) compar\u00e9 \u00e0 O(log n) pour `std::map`.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/container/unordered_map)",
        "hint": null,
        "correctAnswer": ["Table de hachage"],
        "options": [
          "Arbre de recherche binaire",
          "Table de hachage",
          "Liste cha\u00een\u00e9e",
          "Tableau"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "cbb35cb554718d976e1a38ee",
        "question": "Quel est le r\u00e9sultat de ce code ?\n```cpp\n#include <iostream>\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    std::cout << sizeof(arr) / sizeof(arr[0]);\n    return 0;\n}\n```",
        "answer": "5",
        "explanation": "**Explication :**\nsizeof(arr) donne le nombre total d'octets, sizeof(arr[0]) donne les octets par \u00e9l\u00e9ment. La division donne le nombre d'\u00e9l\u00e9ments : 5.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/sizeof)",
        "hint": null,
        "correctAnswer": ["5"],
        "options": ["4", "5", "20", "1"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "fc5692d64a9053ad02ecc4ec",
        "question": "Qu'est-ce que `std::make_unique` en C++14 ?",
        "answer": "Une fonction pour cr\u00e9er des objets std::unique_ptr",
        "explanation": "**Explication :**\n`std::make_unique` est une fonction utilitaire qui cr\u00e9e et retourne un `std::unique_ptr`, fournissant s\u00e9curit\u00e9 d'exception et syntaxe plus claire.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique)",
        "hint": null,
        "correctAnswer": ["Une fonction pour cr\u00e9er des objets std::unique_ptr"],
        "options": [
          "Un g\u00e9n\u00e9rateur d'identifiant unique",
          "Une fonction pour cr\u00e9er des objets std::unique_ptr",
          "Un v\u00e9rificateur d'unicit\u00e9",
          "Un cr\u00e9ateur de valeur unique"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "9904974700d22f88515bce54",
        "question": "Qu'est-ce que `std::exchange` en C++14 ?",
        "answer": "Remplace une valeur et retourne l'ancienne valeur de mani\u00e8re atomique",
        "explanation": "**Explication :**\n`std::exchange` remplace la valeur d'un objet et retourne son ancienne valeur en une seule op\u00e9ration.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/utility/exchange)",
        "hint": null,
        "correctAnswer": [
          "Remplace une valeur et retourne l'ancienne valeur de mani\u00e8re atomique"
        ],
        "options": [
          "Un programme d'\u00e9change de valeurs",
          "Remplace une valeur et retourne l'ancienne valeur de mani\u00e8re atomique",
          "Un op\u00e9rateur d'\u00e9change",
          "Une fonction de swap"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "33299bc8e967bcbf6811352a",
        "question": "Qu'est-ce que `std::apply` en C++17 ?",
        "answer": "Invoque un appelable avec un tuple d'arguments",
        "explanation": "**Explication :**\n`std::apply` invoque un objet appelable avec un tuple d'arguments, d\u00e9compressant le tuple en arguments de fonction.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/utility/apply)",
        "hint": null,
        "correctAnswer": ["Invoque un appelable avec un tuple d'arguments"],
        "options": [
          "Un lanceur d'application",
          "Invoque un appelable avec un tuple d'arguments",
          "Une fonction d'application",
          "Un applicateur de fonction"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "e45feeef53d8fc6db248ba52",
        "question": "Quel est le r\u00e9sultat de ce code ?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    int y = ++x + x++;\n    std::cout << y;\n    return 0;\n}\n```",
        "answer": "Comportement ind\u00e9fini",
        "explanation": "**Explication :**\nModifier x plusieurs fois entre des points de s\u00e9quence conduit \u00e0 un comportement ind\u00e9fini. Le r\u00e9sultat est impr\u00e9visible.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/eval_order)",
        "hint": null,
        "correctAnswer": ["Comportement ind\u00e9fini"],
        "options": ["11", "12", "Comportement ind\u00e9fini", "13"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "773f179791079e8c960ddfca",
        "question": "Qu'est-ce que `std::decay` en C++11 ?",
        "answer": "Applique les conversions tableau-vers-pointeur, fonction-vers-pointeur et retire les qualificateurs cv",
        "explanation": "**Explication :**\n`std::decay` applique des transformations de type similaires \u00e0 ce qui se passe lors du passage d'arguments par valeur.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/types/decay)",
        "hint": null,
        "correctAnswer": [
          "Applique les conversions tableau-vers-pointeur, fonction-vers-pointeur et retire les qualificateurs cv"
        ],
        "options": [
          "Une fonction de d\u00e9croissance",
          "Applique les conversions tableau-vers-pointeur, fonction-vers-pointeur et retire les qualificateurs cv",
          "Un marqueur de d\u00e9pr\u00e9ciation",
          "Une constante de d\u00e9croissance"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "b2a0f88073678d0313e2330b",
        "question": "Qu'est-ce que `std::conditional` en C++11 ?",
        "answer": "Choisit un type ou un autre bas\u00e9 sur un bool\u00e9en \u00e0 la compilation",
        "explanation": "**Explication :**\n`std::conditional` est une m\u00e9tafonction qui s\u00e9lectionne l'un de deux types bas\u00e9 sur une condition bool\u00e9enne \u00e0 la compilation.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/types/conditional)",
        "hint": null,
        "correctAnswer": [
          "Choisit un type ou un autre bas\u00e9 sur un bool\u00e9en \u00e0 la compilation"
        ],
        "options": [
          "Une instruction conditionnelle",
          "Choisit un type ou un autre bas\u00e9 sur un bool\u00e9en \u00e0 la compilation",
          "Un op\u00e9rateur conditionnel",
          "Un v\u00e9rificateur de condition"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "8ad968efdd7abf767e234433",
        "question": "\u00c0 quoi sert `std::is_same` ?",
        "answer": "\u00c0 v\u00e9rifier si deux types sont identiques \u00e0 la compilation",
        "explanation": "**Explication :**\n`std::is_same` est un trait de type qui v\u00e9rifie si deux types sont identiques \u00e0 la compilation.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/types/is_same)",
        "hint": null,
        "correctAnswer": [
          "\u00c0 v\u00e9rifier si deux types sont identiques \u00e0 la compilation"
        ],
        "options": [
          "\u00c0 v\u00e9rifier si les valeurs sont identiques",
          "\u00c0 v\u00e9rifier si deux types sont identiques \u00e0 la compilation",
          "\u00c0 comparer des objets",
          "\u00c0 v\u00e9rifier la similitude"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "cce785b4af0dcad2ef4171b2",
        "question": "Quel est le r\u00e9sultat de ce code ?\n```cpp\n#include <iostream>\nint main() {\n    int x = 10;\n    int* p = &x;\n    int** pp = &p;\n    std::cout << **pp;\n    return 0;\n}\n```",
        "answer": "10",
        "explanation": "**Explication :**\npp est un pointeur vers un pointeur. \\*\\*pp d\u00e9r\u00e9f\u00e9rence deux fois pour obtenir la valeur de x, qui est 10.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/pointer)",
        "hint": null,
        "correctAnswer": ["10"],
        "options": ["10", "Adresse de x", "Adresse de p", "Erreur de compilation"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "09e527693c660a0bd8d5c317",
        "question": "\u00c0 quoi sert `std::remove_if` ?",
        "answer": "\u00c0 supprimer les \u00e9l\u00e9ments d'une plage qui satisfont un pr\u00e9dicat",
        "explanation": "**Explication :**\n`std::remove_if` supprime les \u00e9l\u00e9ments d'une plage qui satisfont un pr\u00e9dicat donn\u00e9, utilis\u00e9 avec erase pour une suppression r\u00e9elle.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/algorithm/remove)",
        "hint": null,
        "correctAnswer": [
          "\u00c0 supprimer les \u00e9l\u00e9ments d'une plage qui satisfont un pr\u00e9dicat"
        ],
        "options": [
          "\u00c0 supprimer les instructions if",
          "\u00c0 supprimer les \u00e9l\u00e9ments d'une plage qui satisfont un pr\u00e9dicat",
          "\u00c0 supprimer conditionnellement des fichiers",
          "\u00c0 supprimer des conditions"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "94ffc4cfde90b43649988971",
        "question": "\u00c0 quoi sert `std::transform` ?",
        "answer": "\u00c0 appliquer une fonction \u00e0 une plage et stocker les r\u00e9sultats dans une autre plage",
        "explanation": "**Explication :**\n`std::transform` applique une fonction donn\u00e9e \u00e0 une plage d'\u00e9l\u00e9ments et stocke le r\u00e9sultat dans une autre plage.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/algorithm/transform)",
        "hint": null,
        "correctAnswer": [
          "\u00c0 appliquer une fonction \u00e0 une plage et stocker les r\u00e9sultats dans une autre plage"
        ],
        "options": [
          "\u00c0 transformer le code",
          "\u00c0 appliquer une fonction \u00e0 une plage et stocker les r\u00e9sultats dans une autre plage",
          "\u00c0 transformer les types",
          "\u00c0 effectuer des transformations"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "e88ffae03634793982434507",
        "question": "\u00c0 quoi sert `std::accumulate` ?",
        "answer": "\u00c0 calculer la somme ou plier une plage d'\u00e9l\u00e9ments",
        "explanation": "**Explication :**\n`std::accumulate` calcule la somme d'une plage d'\u00e9l\u00e9ments ou applique une op\u00e9ration binaire pour plier la plage.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/algorithm/accumulate)",
        "hint": null,
        "correctAnswer": ["\u00c0 calculer la somme ou plier une plage d'\u00e9l\u00e9ments"],
        "options": [
          "\u00c0 accumuler des erreurs",
          "\u00c0 calculer la somme ou plier une plage d'\u00e9l\u00e9ments",
          "\u00c0 accumuler des donn\u00e9es",
          "\u00c0 additionner des nombres"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "81521bf9db021d188db0b3bd",
        "question": "Quel est le r\u00e9sultat de ce code ?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    int y = 10;\n    int z = x > y ? x : y;\n    std::cout << z;\n    return 0;\n}\n```",
        "answer": "10",
        "explanation": "**Explication :**\nL'op\u00e9rateur ternaire v\u00e9rifie si x > y. Comme c'est faux, z est assign\u00e9 y, qui est 10.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/language/operator_other)",
        "hint": null,
        "correctAnswer": ["10"],
        "options": ["5", "10", "1", "0"],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "3bab0f3c0f1840d3d2b9f83a",
        "question": "\u00c0 quoi sert `std::copy` ?",
        "answer": "\u00c0 copier des \u00e9l\u00e9ments d'une plage \u00e0 une autre",
        "explanation": "**Explication :**\n`std::copy` copie les \u00e9l\u00e9ments d'une plage source vers une plage de destination.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/algorithm/copy)",
        "hint": null,
        "correctAnswer": ["\u00c0 copier des \u00e9l\u00e9ments d'une plage \u00e0 une autre"],
        "options": [
          "\u00c0 copier des fichiers",
          "\u00c0 copier des \u00e9l\u00e9ments d'une plage \u00e0 une autre",
          "\u00c0 dupliquer des objets",
          "\u00c0 copier de la m\u00e9moire"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "38f55db2a1f5e5fa466fedcb",
        "question": "\u00c0 quoi sert `std::find` ?",
        "answer": "\u00c0 trouver la premi\u00e8re occurrence d'une valeur dans une plage",
        "explanation": "**Explication :**\n`std::find` recherche la premi\u00e8re occurrence d'une valeur dans une plage et retourne un it\u00e9rateur vers celle-ci.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/algorithm/find)",
        "hint": null,
        "correctAnswer": ["\u00c0 trouver la premi\u00e8re occurrence d'une valeur dans une plage"],
        "options": [
          "\u00c0 trouver des fichiers",
          "\u00c0 trouver la premi\u00e8re occurrence d'une valeur dans une plage",
          "\u00c0 rechercher des motifs",
          "\u00c0 localiser des objets"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "b294b798eb7ebff1edd6c8b3",
        "question": "Sur quoi est bas\u00e9 `std::sort` ?",
        "answer": "Introsort (hybride de quicksort, heapsort et tri par insertion)",
        "explanation": "**Explication :**\n`std::sort` utilise typiquement introsort, qui combine quicksort, heapsort et tri par insertion pour des performances optimales.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/algorithm/sort)",
        "hint": null,
        "correctAnswer": ["Introsort (hybride de quicksort, heapsort et tri par insertion)"],
        "options": [
          "Tri \u00e0 bulles",
          "Introsort (hybride de quicksort, heapsort et tri par insertion)",
          "Tri fusion uniquement",
          "Tri par s\u00e9lection"
        ],
        "nature": "ChooseOne",
        "attachments": []
      },
      {
        "id": "0ab48bba18e988876eef4882",
        "question": "Quel est le r\u00e9sultat de ce code ?\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\nint main() {\n    std::vector<int> v = {5, 2, 8, 1, 9};\n    std::sort(v.begin(), v.end());\n    std::cout << v[2];\n    return 0;\n}\n```",
        "answer": "5",
        "explanation": "**Explication :**\nApr\u00e8s le tri, le vecteur devient {1, 2, 5, 8, 9}. v[2] est le troisi\u00e8me \u00e9l\u00e9ment, qui est 5.\n[R\u00e9f\u00e9rence](https://en.cppreference.com/w/cpp/algorithm/sort)",
        "hint": null,
        "correctAnswer": ["5"],
        "options": ["8", "2", "5", "1"],
        "nature": "ChooseOne",
        "attachments": []
      }
    ]
  },
  "meta": {
    "source": "c++/c++-quiz-fr.md",
    "language": "fr",
    "generatedAt": "2025-12-09T14:56:14.106436+00:00",
    "warnings": ["Question 42 has no marked correct answers", "Question 42 has no options"]
  }
}
