{
  "quizz": {
    "id": "72f5aa2d090f4b90bc8be471",
    "slug": "c-plus-plus",
    "createdById": "cmiz68drf00004eqsc3izonqy",
    "sets": [
      {
        "id": "72f5aa2d090f4b90bc8be471-ch",
        "language": "ch",
        "title": "C++",
        "description": "Seeded from c++/c++-quiz-ch.md",
        "questions": [
          {
            "id": "891c03b52efea45d1f9c63d2",
            "question": "这段代码的输出是什么？\n```cpp\nvector<int> v(22);\nbool b = (v[6]);\nprintf(\"%d\", !b);\n```",
            "answer": "1",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["False", "0", "1", "此代码有错误。"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ac22cdcc3e1818a35dc5b70d",
            "question": "以下哪项是使用这一行被认为是不良实践的原因？（_备选_：为什么使用这一行被认为是不良实践？）\n```cpp\nusing namespace std;\n```",
            "answer": "如果代码使用了两个不同库中定义的具有相同原型但可能具有不同实现的函数，则会因歧义而发生编译错误。",
            "explanation": "[参考](https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/)",
            "hint": null,
            "correctAnswer": [
              "如果代码使用了两个不同库中定义的具有相同原型但可能具有不同实现的函数，则会因歧义而发生编译错误。"
            ],
            "options": [
              "由于导入了所有符号，编译后的代码总是更大。",
              "如果代码使用了两个不同库中定义的具有相同原型但可能具有不同实现的函数，则会因歧义而发生编译错误。",
              "它会自动包含标准库中的所有头文件（cstdint、cstdlib、cstdio、iostream等）。",
              "它会导致编译器强制排他性地包含属于标准库的头文件，当包含不同的头文件时会产生编译错误。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "754a0a6f2bee1eb2bcd5efba",
            "question": "child_t 类型的变量在内存中可能占用的最小大小是多少？\n```cpp\ntypedef struct{\n    unsigned int  age    : 4;\n    unsigned char gender : 1;\n    unsigned int  size   : 2;\n}child_t;\n```",
            "answer": "1字节。",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": ["1字节。"],
            "options": ["7位。", "25字节。", "1位。", "1字节。"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "575bcbf2ed4d745b39a36343",
            "question": "执行代码后，向量v1和v2是什么？\n```cpp\nstd::vector<int> v1{1,2,3},v2;\nv2=v1;\nv1.push_back(4);\nv2.push_back(5);\n```",
            "answer": "v1:{1,2,3,4}; v2:{1,2,3,5};",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["v1:{1,2,3,4}; v2:{1,2,3,5};"],
            "options": [
              "错误",
              "v1:{1,2,3,4}; v2:{5};",
              "v1:{1,2,3,4,5}; v2:{1,2,3,4,5};",
              "v1:{1,2,3,4}; v2:{1,2,3,5};"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "de2f98928c48c73074f2323f",
            "question": "关于指针和迭代器之间的区别，以下哪项是正确的陈述？",
            "answer": "递增迭代器总是意味着访问容器中的下一个元素（如果有的话），无论容器是什么。递增指针意味着指向内存中的下一个元素，不一定是下一个元素。",
            "explanation": "[参考](https://stackoverflow.com/a/31128162)",
            "hint": null,
            "correctAnswer": [
              "递增迭代器总是意味着访问容器中的下一个元素（如果有的话），无论容器是什么。递增指针意味着指向内存中的下一个元素，不一定是下一个元素。"
            ],
            "options": [
              "虽然指针是保存内存地址的变量，但迭代器是用于遍历容器的通用函数。此函数允许程序员在遍历容器时实现读写代码。",
              "递增迭代器总是意味着访问容器中的下一个元素（如果有的话），无论容器是什么。递增指针意味着指向内存中的下一个元素，不一定是下一个元素。",
              "指针是保存内存地址的变量，而迭代器是引用数组中偏移量的无符号整数。",
              "所有迭代器都是用指针实现的，所以所有迭代器都是指针，但并非所有指针都是迭代器。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e23331e0ce40646071e4a87c",
            "question": "u1 占用的存储空间是多少？\n```cpp\nunion {\n    uint16_t a;\n    uint32_t b;\n    int8_t c;\n} u1;\n```",
            "answer": "4字节",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/language/union)",
            "hint": null,
            "correctAnswer": ["4字节"],
            "options": ["4字节", "7字节", "8字节", "2字节"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "db5dc1a87fc710e1b732f1ab",
            "question": "以下哪个运算符可以被重载？",
            "answer": "`new`",
            "explanation": "[参考](https://www.tutorialspoint.com/operators-that-cannot-be-overloaded-in-cplusplus)",
            "hint": null,
            "correctAnswer": ["`new`"],
            "options": ["`?:`", "`new`", "`::`", "`.`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "eccdfa35c91748cc1b1f1f1d",
            "question": "运行此代码后，v1和v2指向的向量的内容是什么？\n```cpp\nstd:: vector<int> *v1 = new std::vector<int>({1,2,3});\nstd:: vector<int> *v2;\nv2=v1;\nv1->push_back(4);\nv2->push_back(5);\n```",
            "answer": "`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`",
            "explanation": "v1和v2指向同一个向量。",
            "hint": null,
            "correctAnswer": ["`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`"],
            "options": [
              "`*v1:{1,2,3,4}; *v2:{5};`",
              "`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`",
              "错误",
              "`*v1:{1,2,3,4}; *v2:{1,2,3,5};`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "45d7731a52f92436cf266e60",
            "question": "以下哪项不是类和结构体之间的区别？",
            "answer": "模板类型参数可以用类声明，但不能用struct关键字声明。",
            "explanation": "模板可以与类和结构体一起使用\n[参考](https://docs.microsoft.com/en-us/cpp/cpp/struct-cpp?view=msvc-170)\n[参考](https://www.fluentcpp.com/2017/06/13/the-real-difference-between-struct-class/)",
            "hint": null,
            "correctAnswer": ["模板类型参数可以用类声明，但不能用struct关键字声明。"],
            "options": [
              "因为结构体是C编程语言的一部分，所以C和C++结构体之间存在一些复杂性。类则没有这种情况。",
              "类可以有成员函数；结构体是私有的。",
              "结构体成员的默认访问说明符是公共的，而类成员的默认访问说明符是私有的。",
              "模板类型参数可以用类声明，但不能用struct关键字声明。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1c39f44c69734455f099345e",
            "question": "假设您需要保留一个数据结构，其中包含基于星期几访问某些资源的权限，但您不能为每天使用bool变量。您需要每周一天使用一位。以下哪项是此应用程序位字段结构的正确实现？",
            "answer": "A",
            "explanation": "```cpp\ntypedef struct {\nint sunday:1;\nint monday:1;\n// 更多天数\nint friday:1;\nint saturday:1;\n} weekdays;\n```\n```cpp\ntypedef char[7]: weekdays;\n```\n```cpp\ntypedef struct {\nbit sunday:1;\nbit monday:1;\n// 更多天数\nbit friday:1;\nbit saturday:1;\n} weekdays;\n```\n```cpp\ntypedef struct {\nbit sunday;\nbit monday;\n// 更多天数\nbit friday;\nbit saturday;\n} weekdays;\n```\n[参考](https://en.cppreference.com/w/cpp/language/bit_field) _注意_：正确的语法是每个变量的大小为1位。`bit`不是C++中的类型。",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0867ce929cf19fb6282664aa",
            "question": "什么是左值？",
            "answer": "它是一个位置值，意味着适合赋值给指针或引用的内存地址。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["它是一个位置值，意味着适合赋值给指针或引用的内存地址。"],
            "options": [
              "它是一个常量表达式，意味着由常量和操作组成的表达式。",
              "它是一个表示具有地址的对象的表达式。",
              "它是一个适合在二元操作中作为左侧操作数的表达式。",
              "它是一个位置值，意味着适合赋值给指针或引用的内存地址。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2da50203d92eea43f241dc0d",
            "question": "自动类型说明符在这行代码中做什么（自C++11起）？\n```cpp\nauto x = 4000.22;\n```",
            "answer": "它指定x的类型将从初始化器推导出来 - 在这种情况下是double。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["它指定x的类型将从初始化器推导出来 - 在这种情况下是double。"],
            "options": [
              "它指定x的类型将从初始化器推导出来 - 在这种情况下是double。",
              "它指定x的类型是自动的，这意味着它可以在整个程序中分配不同类型的数据。",
              "它指定x是一个具有自动存储期的变量。",
              "它指定如果x需要更多空间，将为x分配更多内存，避免由于溢出而导致的数据丢失。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6f4a6cca08999e393a0a9158",
            "question": "类模板是什么？",
            "answer": "用泛型编程范式编写的类，用类型参数而不是特定类型指定行为。",
            "explanation": "[参考](https://www.mygreatlearning.com/blog/templates-in-cpp/)",
            "hint": null,
            "correctAnswer": ["用泛型编程范式编写的类，用类型参数而不是特定类型指定行为。"],
            "options": [
              "用泛型编程范式编写的类，用类型参数而不是特定类型指定行为。",
              "用于继承和多态性的空白超类。",
              "仅由成员变量组成的类，没有构造函数、析构函数或成员函数。",
              "类的骨架源代码，程序员必须填写特定部分以定义使用的数据类型和算法。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8b969a08b0ea38dff186f7cf",
            "question": "三元运算符等价于这段代码片段？\n```cpp\nif(x)\n    y=a;\nelse\n    y=b;\n```",
            "answer": "`y=x?a:b;`",
            "explanation": "[参考](https://www.w3schools.com/cpp/cpp_conditions_shorthand.asp)",
            "hint": null,
            "correctAnswer": ["`y=x?a:b;`"],
            "options": ["`y=a?b:x;`", "`y=if(x?a:b);`", "`y=(x&a)?a:(x&b)?b:0;`", "`y=x?a:b;`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "71050221719e907f9e862ff8",
            "question": "下面给出的代码的输出是什么？\n```cpp\n#include <iostream>\nint main(){\n    int x=10, y=20;\n    std::cout << \"x = \" << x++ << \" and y = \" << --y << std::endl;\n    std::cout << \"x = \" << x-- << \" and y = \" << ++y << std::endl;\n    return(0);\n}\n```",
            "answer": "`x = 10 and y = 19`",
            "explanation": "`x = 11 and y = 19`\n`x = 10 and y = 20`\n`x = 11 and y = 20`\n`x = 10 and y = 19`",
            "hint": null,
            "correctAnswer": ["`x = 10 and y = 19`"],
            "options": [
              "`x = 10 and y = 20`",
              "`x = 11 and y = 19`",
              "`x = 10 and y = 19`",
              "`x = 11 and y = 20`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c3c59a104b07d198590bf612",
            "question": "范围for循环中括号之间由冒号分隔的两部分的含义是什么？",
            "answer": "第一个是一个变量声明，将保存序列中的元素。第二个是要遍历的序列。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["第一个是一个变量声明，将保存序列中的元素。第二个是要遍历的序列。"],
            "options": [
              "第一个是一个变量声明，将保存序列中的元素。第二个是要遍历的序列。",
              "第一个是迭代器，第二个是要添加到迭代器的增量值。",
              "第一个是迭代变量。第二个是一个`std::pair`，指定变量将在其中迭代的范围（开始和结束）。",
              "第一个是容器对象。第二个是一个`std::pair`，指定将在循环内访问元素的范围（开始和结束）。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fae4c36d3b3cedf0daac68bf",
            "question": "下面给出的代码的输出是什么？\n```cpp\nint8_t a=200;\nuint8_t b=100;\nif(a>b)\n    std::cout<<\"greater\";\nelse\n    std::cout<<\"less\";\n```",
            "answer": "less",
            "explanation": "注意：下面问题的变体。",
            "hint": null,
            "correctAnswer": ["less"],
            "options": [
              "没有输出，因为在比较int8_t和uint8_t时会发生异常。",
              "greater",
              "less",
              "没有输出，因为存在编译器错误。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4711645e727edb7d9b436603",
            "question": "这段代码块的输出是什么？\n```cpp\nint8_t a=200;\nuint8_t b=100;\nstd::cout<<\"a=\"<<(int)a;\nstd::cout<<\", b=\"<<(int)b;\n```",
            "answer": "a=-56, b=100",
            "explanation": "注意：从'int'到'int8_t'（又名'signed char'）的隐式转换将值从200更改为-56",
            "hint": null,
            "correctAnswer": ["a=-56, b=100"],
            "options": ["a=-56, b=100", "a=-55, b=100", "a=200, b=-156", "a=200, b=100"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fc754f74370216ca8817e906",
            "question": "执行此代码片段后的输出是什么？\n```cpp\nint x=5, y=2;\nif(x & y) {\n    /*_part A_*/\n}\nelse {\n    /*_part B_*/\n}\n```",
            "answer": "部分B执行，因为(x & y)的结果为0，即假。",
            "explanation": "[参考](https://stackoverflow.com/questions/63867765/dont-understand-why-if-5-2-is-false)",
            "hint": null,
            "correctAnswer": ["部分B执行，因为(x & y)的结果为0，即假。"],
            "options": [
              "部分A执行，因为x==5（真）且y==2（真），因此AND操作评估为真。",
              "部分B执行，因为(x & y)的结果为0，即假。",
              "部分A执行，因为(x & y)的结果为非零值，即真。",
              "部分B执行，因为语句(x & y)无效，因此为假。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d8e3e519a2652a93c20d0981",
            "question": "`get_length`函数的有效定义是什么，该函数返回以空字符结尾的字符串的长度？",
            "answer": "A",
            "explanation": "```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str[count++]);\nreturn count-1;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str!=NULL){\ncount++;\nstr++;\n}\nreturn count;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile((*str)++)\ncount++;\nreturn count;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str++)\ncount++;\nreturn count;\n}\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "994ec5efa366e923f4b6970f",
            "question": "哪个STL类最适合实现始终排序的数据集合，以便pop操作始终获得元素中最大的元素？假设您只对push和pop操作感兴趣。",
            "answer": "`std::priority_queue`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`std::priority_queue`"],
            "options": ["`std::list`", "`std::vector`", "`std::priority_queue`", "`std::map`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8173b5b1e5814bec75145d63",
            "question": "for循环中括号之间由分号分隔的三个部分的含义是什么？",
            "answer": "第一个是初始化块，第二个是迭代条件，第三个是增量块。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["第一个是初始化块，第二个是迭代条件，第三个是增量块。"],
            "options": [
              "第一个是迭代变量名称，第二个是迭代次数，第三个是所需的增量或减量（用带符号整数指定）。",
              "第一个是初始化块，第二个是迭代条件，第三个是增量块。",
              "第一个是迭代变量，第二个是它应该操作的容器，第三个是随时中止的退出条件。",
              "第一个是迭代变量名称，第二个是迭代变量的起始值，第三个是停止值（最后一个值加一）。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d1492bd966a48c8636627827",
            "question": "这段代码打印什么？\n```cpp\nint i = 0;\nprintf(\"%d\", i++);\nprintf(\"%d\", i--);\nprintf(\"%d\", ++i);\nprintf(\"%d\", --i);\n```",
            "answer": "0,1,1,0",
            "explanation": "[参考](https://www.geeksforgeeks.org/pre-increment-and-post-increment-in-c/)",
            "hint": null,
            "correctAnswer": ["0,1,1,0"],
            "options": ["0,1,1,0", "0,1,0,1", "0,0,1,0", "1,0,1,0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "17cd77fd0d1fdff1e333885e",
            "question": "关于名为`ptr`的变量，以下哪项是正确的？\n```cpp\nvoid *ptr;\n```",
            "answer": "它是一个指向没有特定类型的值的指针，因此可以转换为指向任何类型。",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/language/pointer)",
            "hint": null,
            "correctAnswer": ["它是一个指向没有特定类型的值的指针，因此可以转换为指向任何类型。"],
            "options": [
              "它是一个初始化为NULL的指针。",
              "它是一个指向void函数的指针。",
              "该声明会导致编译器错误，因为指针必须指定类型。",
              "它是一个指向没有特定类型的值的指针，因此可以转换为指向任何类型。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2d1bb8d169f06af1b8b5bc5d",
            "question": "下面给出的代码的输出是什么？\n```cpp\nint c=3; char d='A';\nstd::printf(\"c is %d and d is %c\",c,d);\n```",
            "answer": "c is 3 and d is A",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["c is 3 and d is A"],
            "options": [
              "c is d and d is c",
              "c is A and d is 3",
              "c is 3 and d is A",
              "c is c and d is d"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9a8dd847c6a20504ea99411f",
            "question": "这段代码的输出是什么？\n```cpp\nprintf(\"1/2 = %f\",(float)(1/2));\n```",
            "answer": "1/2 = 0.000000",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["1/2 = 0.000000"],
            "options": ["1/2 = 0.499999", "1/2 = 0", "1/2 = 0.000000", "1/2 = 0.5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2e4b28439a4fc5c3dc052a93",
            "question": "公共类成员和私有类成员之间的区别是什么？",
            "answer": "公共成员可以被任何函数访问。私有成员只能被同一类的成员函数和类的友元访问。",
            "explanation": "[参考](https://www.geeksforgeeks.org/difference-between-public-and-private-in-c-with-example/)",
            "hint": null,
            "correctAnswer": [
              "公共成员可以被任何函数访问。私有成员只能被同一类的成员函数和类的友元访问。"
            ],
            "options": [
              "公共成员与全局变量相同，因此代码的每个部分都可以访问它们。私有成员与自动变量相同，因此只有它们的类可以访问它们。",
              "公共成员对任何运行的应用程序都是可访问的。私有成员仅对实例化对象的应用程序可访问。",
              "公共成员将在多线程环境中编译为共享变量。私有成员将编译为线程局部变量。",
              "公共成员可以被任何函数访问。私有成员只能被同一类的成员函数和类的友元访问。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "393dea1510f3e52a19f9c0d1",
            "question": "执行此代码后`x`的值是多少？\n```cpp\nint x=10, a=-3;\nx+=a;\n```",
            "answer": "7",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["7"],
            "options": ["3", "7", "-3", "13"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "dcee6f2e8d3d1a40fc4a0266",
            "question": "以下哪项陈述是正确的？",
            "answer": "C++支持多重继承。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C++支持多重继承。"],
            "options": [
              "只有类才能有成员变量和方法。",
              "C++支持多重继承。",
              "C++只支持单继承。",
              "只有结构体可以继承。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1f1b2b7a6ffd56728ca41a3b",
            "question": "考虑一个指向void的指针，名为`ptr`，它已设置为指向浮点变量`g`。以下哪个选择是解引用`ptr`以将其指向的值分配给程序后面的float变量`f`的有效方法？\n```cpp\nfloat g;\nvoid *ptr=&g;\n```",
            "answer": "`float f=*(float *)ptr;`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`float f=*(float *)ptr;`"],
            "options": [
              "`float f=*(float)ptr;`",
              "`float f=(float *)ptr;`",
              "`float f=(float)*ptr;`",
              "`float f=*(float *)ptr;`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a7c50d96eae67ec7f2d2f3ef",
            "question": "`.*`运算符是什么，它做什么？",
            "answer": "它是指向成员运算符的指针，它允许您通过指向该特定类成员的指针访问对象的成员。",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/language/operator_member_access)",
            "hint": null,
            "correctAnswer": [
              "它是指向成员运算符的指针，它允许您通过指向该特定类成员的指针访问对象的成员。"
            ],
            "options": [
              "它与类成员访问运算符或箭头运算符`(->)`相同，它允许您通过指向对象的指针访问对象的成员。",
              "它是指向成员运算符的指针，它允许您通过指向该特定类成员的指针访问对象的成员。",
              "它是带有运算符地址的成员访问，它返回类或结构成员的地址。",
              "它是成员访问运算符`(.)`和解引用运算符`(*)`的组合，因此它允许您访问成员指针指向的对象。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e878bde77ef92fbc48d9cacb",
            "question": "对于这些声明，哪个选择显示了四种等效的方法来将字符串中的字符\"y\"分配给char变量c？\n```cpp\nchar buff[50] = \"strings as arrays of characters are fun!\"\nchar *str = buff+11;\nchar c;\n```",
            "answer": "C",
            "explanation": "```cpp\nc = buff[16];\nc = str[5];\nc = *(buff+16);\nc = *(str+5);\n```\n```cpp\nc = *(buff[15]);\nc = *(str[4]);\nc = buff+15;\nc = str+4;\n```\n```cpp\nc = buff[15];\nc = str[4];\nc = *(buff+15);\nc = *(str+4);\n```\n```cpp\nc = *(buff[16]);\nc = *(str[5]);\nc = buff+16;\nc = str+5;\n```",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a6bc47c65e4405b81db0c409",
            "question": "从Animal类派生的名为Dog的类的正确声明是哪个选择？\n```cpp\nclass Animal{\n    //....\n}\n```",
            "answer": "B",
            "explanation": "```cpp\nclass Dog :: public Animal {\n//....\n};\n```\n```cpp\nclass Dog : public Animal {\n//....\n};\n```\n```cpp\npublic class Animal :: Dog {\n//....\n};\n```\n```cpp\npublic class Dog extends Animal {\n//....\n};\n```",
            "hint": null,
            "correctAnswer": ["B"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4852c1a631dd4eae09862dea",
            "question": "下面给出的代码的输出是什么？\n```cpp\n#include <cstdio>\nusing namespace std;\nint main(){\n    char c = 255;\n    if(c>10)\n        printf(\"c = %i, which is greater than 10\", c);\n    else\n        printf(\"c = %i, which is less than 10\", c);\n    return 0;\n}\n```",
            "answer": "c = -1, which is less than 10",
            "explanation": "从技术上讲，`char`是`signed`还是`unsigned`是实现定义的；\n在后一种情况下，第二个答案是正确的。\n[参考](https://en.cppreference.com/w/cpp/language/types)",
            "hint": null,
            "correctAnswer": ["c = -1, which is less than 10"],
            "options": [
              "c = -1, which is less than 10",
              "c = 255, which is greater than 10",
              "c = -1, which is greater than 10",
              "c = 255, which is less than 10"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "daefd993b12befe472e4880b",
            "question": "C++代码如何调用C函数？",
            "answer": "使用extern \"C\"",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["使用extern \"C\""],
            "options": ["直接调用C代码", "C++无法调用C函数", "使用extern \"C\"", "导入C源代码"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5b9275075c3485dabdc94dbb",
            "question": "以下哪个选择不是包含x和y坐标作为整数的结构的有效类型定义，并且可以完全按照为名为`center`的变量所示的方式使用？\n```cpp\ncoord center;\ncenter.x = 5;\ncenter.y = 3;\n```",
            "answer": "A",
            "explanation": "```cpp\ntypedef struct coord {\nint x;\nint y;\n};\n```\n```cpp\ntypedef struct coord {\nint x;\nint y;\n} coord;\n```\n```cpp\ntypedef struct {\nint x;\nint y;\n} coord;\n```\n```cpp\nstruct coord {\nint x;\nint y;\n};\ntypedef struct coord coord;\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f51f3298de5095b17106c36c",
            "question": "以下哪个选择不会产生与此代码片段相同的输出？假设变量`i`不会在代码的其他地方使用。\n```cpp\nfor (i=1;i<10;i++){\n    cout<<i<<endl;\n}\n```",
            "answer": "A",
            "explanation": "```cpp\ni=1;\nwhile(i<10){\ncout<<++i<<endl;\n}\n```\n```cpp\nfor (int i:{1,2,3,4,5,6,7,8,9}) {\ncout<<i<<endl;\n}\n```\n```cpp\ni = 1;\ndo {\ncout<<i++<<endl;\n} while(i<10);\n```\n```cpp\ni = 1;\nloop:\ncout<<i++<<endl;\nif(i<10) goto loop;\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c47a7ff7345776a2eff5e1c6",
            "question": "main.cpp文件的这一部分做什么？\n```cpp\n#include \"library.h\"\n```",
            "answer": "它导致用源文件library.h的整个内容替换`#include`指令。这类似于将library.h复制粘贴到main.cpp中的操作。",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "它导致用源文件library.h的整个内容替换`#include`指令。这类似于将library.h复制粘贴到main.cpp中的操作。"
            ],
            "options": [
              "它导致工具链编译library.h的所有内容，以便在最终应用程序需要时其可执行代码可用。",
              "它为源文件main.cpp中使用的所有数据和函数的声明和定义挑选library.h，最后用这些声明和定义替换`#include`指令。",
              "它通知链接器，源文件main.cpp中使用的某些函数或数据包含在library.h中，以便它们可以在运行时调用。这也称为动态链接。",
              "它导致用源文件library.h的整个内容替换`#include`指令。这类似于将library.h复制粘贴到main.cpp中的操作。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "648f6123d6ac5445a641b158",
            "question": "考虑`is_even`的这个函数声明，它接受一个整数，如果参数是偶数则返回true，否则返回false。以下哪些声明是该函数的重载版本的正确声明，以支持浮点数和数字的字符串表示？\n```cpp\nbool is_even(int);\n```",
            "answer": "A",
            "explanation": "```cpp\nbool is_even(float f);\nbool is_even(char *str);\n```\n```cpp\nbool is_even(float f);\nbool is_even(char str);\n```\n```cpp\nbool is_even_float(float f);\nbool is_even_str(char *str);\n```\n```cpp\nfloat is_even(float f);\nchar *is_even(char *str);\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "53bf02aff143ce9b4a2ee355",
            "question": "以下哪个选择是头文件`my_library.h`的包含保护？",
            "answer": "B",
            "explanation": "```cpp\n#ifdef MY_LIBRARY_H\n#define MY_LIBRARY_H\n// my_library.h content\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#ifndef MY_LIBRARY_H\n#define MY_LIBRARY_H\n// my_library.h content\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#ifdef MY_LIBRARY_H\n#undef MY_LIBRARY_H\n// my_library.h content\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#define MY_LIBRARY_H\n#include MY_LIBRARY_H\n// my_library.h content\n#undef MY_LIBRARY_H\n```",
            "hint": null,
            "correctAnswer": ["B"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "53dc6e84f9577b3dd562d143",
            "question": "使用C++11之前的编译器时，这个定义有什么问题？\n```cpp\nstd::vector<std::vector<int>> thematrix;\n```",
            "answer": "`>>`被解析为右移运算符，因此导致编译错误。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`>>`被解析为右移运算符，因此导致编译错误。"],
            "options": [
              "它没有任何问题。",
              "`std::vector`不能包含更多`std::vector`容器作为其元素。",
              "正确的语法应该是：`std::vector[std::vector[int]] thematrix;`",
              "`>>`被解析为右移运算符，因此导致编译错误。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "81add4aa8ef92faf29c08113",
            "question": "下面的语句等价于什么？",
            "answer": null,
            "explanation": null,
            "hint": null,
            "correctAnswer": [],
            "options": [],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2f30e964d80c669ecafef670",
            "question": "b. 该语句等价于什么？\n```cpp\nsprite->x\n```",
            "answer": "`(*sprite).x`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`(*sprite).x`"],
            "options": ["`sprite.x`", "`sprite.*x`", "`(*sprite).x`", "`*sprite.x`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8ccf3bf6cb44555d480ffbf8",
            "question": "考虑一个名为`complexNumber`的类。以下哪段代码将产生等效的对象？\n```cpp\ncomplexNumber(float real, float im)\n: real_part(real),\n im_part(im){}\n```",
            "answer": "C",
            "explanation": "```cpp\ncomplexNumber(float real, float im) {\nthis->real = real_part;\nthis->im = im_part;\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part(real);\nthis->im_part(im);\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part = real;\nthis->im_part = im;\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part = &real;\nthis->im_part = &im;\n}\n```",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b94d70699afbf6bde50454fc",
            "question": "执行此代码片段的结果是什么？\n```cpp\nbool x=true, y=false;\nif (~x || y) {\n    /*part A*/\n} else {\n    /*part B*/\n}\n```",
            "answer": "部分A执行，因为`~x`不为零，意味着真。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["部分A执行，因为`~x`不为零，意味着真。"],
            "options": [
              "部分A执行，因为如果`y==false`，表达式`(~x || y)`总是为真。",
              "部分B执行，因为语句`(~x || y)`无效，因此为假。",
              "部分A执行，因为`~x`不为零，意味着真。",
              "部分B执行，因为`~x`为假且`y`为假，因此OR操作评估为假。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "dccd12b77c10a8060fa7864e",
            "question": "这段代码的输出是什么？\n```cpp\nint32_t nums[3]={2,4,3};\nstd::cout << ( nums[0] << nums[1] << nums[2] );\n```",
            "answer": "256",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["256"],
            "options": [
              "输出是`nums[0]`、`nums[1]`和`nums[2]`的地址，按顺序，没有空格。",
              "256",
              "`0`",
              "`243`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "de0d8f46bc726d82639c2b32",
            "question": "这段代码的输出是什么？\n```cpp\nfloat values[5]={0.54f, 2.71828f, 3.14159f, 5.499999f, 10.0f};\nfor(auto f:values)\n    printf(\"%i \",(int)(f+0.5f));\n```",
            "answer": "`1 3 3 5 10`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`1 3 3 5 10`"],
            "options": [
              "`0.54 2.71828 3.14159 5.499999 10.0`",
              "`1 3 4 6 11`",
              "`0 2 3 5 10`",
              "`1 3 3 5 10`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d7f73d9d06281fc52636a600",
            "question": "以下哪个STL类最适合实现电话簿？假设每个条目包含一个姓名和一个电话号码，没有重复项，并且您希望按姓名查找。",
            "answer": "`std::map`",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/container/map)",
            "hint": null,
            "correctAnswer": ["`std::map`"],
            "options": ["`std::priority_queue`", "`std::list`", "`std::vector`", "`std::map`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "efe0d015283db28e8e1ca716",
            "question": "这个程序做什么？\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\nint main(){\n    ifstream file1(\"text1.txt\", ios::binary);\n    ofstream file2(\"text2.txt\", ios::binary);\n    file2 << file1.rdbuf();\n}\n```",
            "answer": "它将text1.txt的内容复制到text2.txt中 - 即，它创建text1.txt的副本，命名为text2.txt。",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/header/fstream)",
            "hint": null,
            "correctAnswer": [
              "它将text1.txt的内容复制到text2.txt中 - 即，它创建text1.txt的副本，命名为text2.txt。"
            ],
            "options": [
              "它将text1.txt重命名为text2.txt。",
              "它创建一个名为text2.txt的目录并将text1.txt移动到那里。",
              "它将text1.txt的内容复制到text2.txt中 - 即，它创建text1.txt的副本，命名为text2.txt。",
              "它将text1.txt的内容追加到text2.txt中 - 即，用text2.txt和text1.txt的连接替换text2.txt的内容。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3c5261a617b15b5b3c134774",
            "question": "以下哪项不是将my_class的成员变量`count`声明为static的结果？/ 备选：将成员变量`count`声明为static时，以下哪项陈述是正确的？\n```cpp\nclass my_class {\n    public: static int count;\n}\n```",
            "answer": "该变量不能被同一应用程序或线程中代码的任何部分修改。但是，其他线程可以修改它。",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/language/static)",
            "hint": null,
            "correctAnswer": [
              "该变量不能被同一应用程序或线程中代码的任何部分修改。但是，其他线程可以修改它。"
            ],
            "options": [
              "该变量不能被同一应用程序或线程中代码的任何部分修改。但是，其他线程可以修改它。",
              "即使没有定义类的对象，该变量也存在，因此可以在源代码的任何位置修改。",
              "该变量只分配一次，无论实例化多少个对象，因为它绑定到类本身，而不是其实例。",
              "所有尝试访问其count成员变量的对象实际上都引用唯一的类绑定静态count变量。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b1b871bb96d0ec422cfc27a8",
            "question": "源代码中表示为`0.44`的常量的假定类型是什么？",
            "answer": "double",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["double"],
            "options": ["double", "long float", "long double", "float"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e165407056b01ab605a112af",
            "question": "如下所示，删除`my_object`的适当方法是什么？\n```cpp\nmy_class *my_object = new my_class();\n```",
            "answer": "`delete(my_object);`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`delete(my_object);`"],
            "options": [
              "`delete(my_object);`",
              "`free(my_object);`",
              "垃圾收集器最终会销毁该对象。",
              "退出作用域将销毁该对象。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2e5ca22c62127e58efd952f0",
            "question": "对于名为`grades`的对象指针，调用`count`成员函数的正确方法是什么？\n```cpp\nclass my_array{\n    public:\n        int count();\n};  // ... more members above\nint main(){\n    my_array *grades = new my_array();\n};  // ... more code above\n```",
            "answer": "`grades->count();`",
            "explanation": "[参考](https://en.cppreference.com/w/c/language/operator_member_access)",
            "hint": null,
            "correctAnswer": ["`grades->count();`"],
            "options": [
              "`grades.count();`",
              "`my_array->count();`",
              "`grades->count();`",
              "`my_array.count();`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e433b1cfccd71b9365207e7b",
            "question": "这段代码的输出是什么？\n```cpp\nint i0=4, i1=6, i2=8;\nint& nums[3]={i2,i0,i1};\nstd::cout<<nums[0]<<nums[1]<<nums[2];\n```",
            "answer": "没有输出。代码导致编译器错误，因为`nums`是引用数组，这是非法的。",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/language/array)",
            "hint": null,
            "correctAnswer": ["没有输出。代码导致编译器错误，因为`nums`是引用数组，这是非法的。"],
            "options": [
              "没有输出。代码导致编译器错误，因为`nums`是引用数组，这是非法的。",
              "846",
              "输出是i2、i0和i1的地址，按顺序，没有空格。",
              "468"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6e249eefcffe9d3388bfa50c",
            "question": "这段代码会导致编译器错误吗？如果是，为什么；如果不是，`child_t`是什么？\n```cpp\ntypedef struct{\n    unsigned int  age    : 4;\n    unsigned char gender : 1;\n    char                 : 0;\n    unsigned int  size   : 2;\n}child_t;\n```",
            "answer": "否，`child_t`是一个定义为具有位字段的结构的类型。它在第一个字节中有4位用于年龄和1位用于性别，在第二个字节中有2位用于大小。",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": [
              "否，`child_t`是一个定义为具有位字段的结构的类型。它在第一个字节中有4位用于年龄和1位用于性别，在第二个字节中有2位用于大小。"
            ],
            "options": [
              "是的，它导致编译器错误，因为冒号字符不允许在结构定义中使用。",
              "否，`child_t`是一个定义为具有位字段的结构的类型。它在第一个字节中有4位用于年龄和1位用于性别，在第二个字节中有2位用于大小。",
              "是的，它导致编译器错误，因为有一个未命名的字段。",
              "是的，它导致编译器错误，因为一个字段的大小定义为0。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "176a67f6e30893b3c51bcf12",
            "question": "这个表达式等价于什么？\n```cpp\nA->B\n```",
            "answer": "`(*A).B`",
            "explanation": "注意：下面问题的简化变体。",
            "hint": null,
            "correctAnswer": ["`(*A).B`"],
            "options": ["`*(A.B)`", "`B=A`", "`(*A).B`", "`&A.B`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6e67fcd21f0e1d9f4c0caee0",
            "question": "这个表达式等价于什么？\n```cpp\nA->B->C->D\n```",
            "answer": "`*(*((*A).B).C).D`",
            "explanation": "**注意：**上面问题的更复杂变体。",
            "hint": null,
            "correctAnswer": ["`*(*((*A).B).C).D`"],
            "options": ["`A.B.C.D`", "`*A.*B.*C.*D`", "`&A.&B.&C.&D`", "`*(*((*A).B).C).D`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b00d8523e0994d25adaa1b92",
            "question": "这个函数做什么？\n```cpp\nauto buff = new char[50];\nstd::memset(buff,20,50);\n```",
            "answer": "它将值20写入从buff到buff+49的每个内存地址。",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/string/byte/memset)",
            "hint": null,
            "correctAnswer": ["它将值20写入从buff到buff+49的每个内存地址。"],
            "options": [
              "它声明一个名为buff的内存缓冲区，从地址20开始到地址70结束。",
              "它设置名为buffer的数组中从索引20到索引50的所有位。",
              "它将值20写入从buff到buff+49的每个内存地址。",
              "它声明一个名为buff的内存缓冲区，从地址20开始到地址50结束。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ab37467cc4b486f8cbe3175d",
            "question": "考虑一个名为`CustomData`的类。以下哪个选择是作为类成员重载后缀`++`运算符的正确声明语法？",
            "answer": "`CustomData operator++(int);`",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/language/operators)",
            "hint": null,
            "correctAnswer": ["`CustomData operator++(int);`"],
            "options": [
              "`CustomData& operator++();`",
              "`void operator++(CustomData);`",
              "`CustomData operator++(CustomData);`",
              "`CustomData operator++(int);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4de0fc23b795a1c0e1869e29",
            "question": "您想要对下面声明的my_array进行排序。使用lambda表达式作为比较函数调用std::sort的正确方法是哪个？\n```cpp\nstd::array<uint32_t, 50> my_array;\n```",
            "answer": "A",
            "explanation": "```cpp\nstd::sort(my_array.begin(), my_array.end(),\n[](uint32_t a, uint32_t b) {\nreturn a < b;\n})\n```\n```cpp\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n}\nstd::sort(my_array.begin(), my_array.end(), lambda);\n```\n```cpp\nstd::sort(my_array.begin(), my_array.end(),\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n})\n```\n```cpp\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n}\nstd::sort(my_array.begin(), my_array.end(), &lambda);\n```\n[参考](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160)",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e43396ad1e02cb942dc6ca46",
            "question": "使用std::mutex::try_lock()实现函数std::mutex::lock()的最合理的实现是哪个选择？",
            "answer": "A",
            "explanation": "```cpp\nvoid std::mutex::lock(){\nwhile(!this->try_lock());\n}\n```\n```cpp\nvoid std::mutex::lock(){\nreturn (this->try_lock());\n}\n```\n```cpp\nvoid std::mutex::lock(){\nwhile(1)\nthis->try_lock();\n}\n```\n```cpp\nvoid std::mutex::lock(){\nwhile(this->try_lock());\n}\n```\n注意：下面问题的变体。",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "dc2fc352242ed9a707efe2ac",
            "question": "这两个函数之间的主要区别是什么？\n```cpp\nstd::mutex::lock()\nstd::mutex::try_lock()\n```",
            "answer": "两者都尝试获取锁，但如果互斥锁不可用，`lock()`会阻塞，而`try_lock()`会返回互斥锁是否可用。",
            "explanation": "注意：上面问题的变体。\n[参考](https://en.cppreference.com/w/cpp/thread/mutex/try_lock)",
            "hint": null,
            "correctAnswer": [
              "两者都尝试获取锁，但如果互斥锁不可用，`lock()`会阻塞，而`try_lock()`会返回互斥锁是否可用。"
            ],
            "options": [
              "`lock()`比`try_lock()`具有更高的特权。这意味着使用`lock()`获取互斥锁的机会更大。",
              "两者都尝试获取锁，但如果互斥锁不可用，`lock()`会阻塞，而`try_lock()`会返回互斥锁是否可用。",
              "`lock()`强制抢占，而`try_lock()`建议抢占。",
              "如果互斥锁不可用，`try_lock()`会返回相应的代码，而`lock()`会从当前拥有它的线程中抢夺互斥锁。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "41df16a106695725cfe9c55a",
            "question": "析构函数的目的是什么？",
            "answer": "它允许程序员编写必要的代码，在删除对象本身之前释放对象获取的资源。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["它允许程序员编写必要的代码，在删除对象本身之前释放对象获取的资源。"],
            "options": [
              "它允许程序员编写必要的代码，在删除对象本身之前释放对象获取的资源。",
              "它删除一个对象。析构函数的一个例子是`delete()`函数。",
              "它终止程序。这可以作为常规函数调用或异常实现。",
              "C++中没有析构函数。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1e3414f46c680602097fd595",
            "question": "将参数声明为`const`引用而不是将其声明为常规对象的一个好处是什么？\n```cpp\nint calculateMedian(const my_array& a)\n```",
            "answer": "`const`限定符禁止代码修改参数，因此程序员可以确保源对象将保持不变。/ 备选：参数作为引用传递，因此如果传递的my_array对象很大，程序将需要更少的时间和内存。",
            "explanation": "[参考](https://stackoverflow.com/a/2627179/10773894)",
            "hint": null,
            "correctAnswer": [
              "`const`限定符禁止代码修改参数，因此程序员可以确保源对象将保持不变。/ 备选：参数作为引用传递，因此如果传递的my_array对象很大，程序将需要更少的时间和内存。"
            ],
            "options": [
              "实际上，对象不能作为常规变量传递，因为它们需要构造函数调用。因此，`const`引用是将类实例传递给函数的唯一方法。",
              "没有好处，因为引用和对象被视为同一事物。",
              "`const`限定符禁止代码修改参数，因此程序员可以确保源对象将保持不变。/ 备选：参数作为引用传递，因此如果传递的my_array对象很大，程序将需要更少的时间和内存。",
              "参数作为引用传递，因此函数接收可以修改而不影响原始变量的副本。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9c6c4c8c30590fdb0a8e1c23",
            "question": "什么是包含保护？",
            "answer": "一个预处理器语句，防止源文件在项目中被多次包含",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["一个预处理器语句，防止源文件在项目中被多次包含"],
            "options": [
              "一个预处理器指令，防止包含#ifdef、#ifndef或#elif指令的行中的不一致行为",
              "一个编译器选项，防止用户代码包含其他库",
              "一个预处理器语句，防止源文件在项目中被多次包含",
              "一个向项目添加安全功能（如互斥锁、看门狗定时器和断言）的库"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c788da93ce0791d5c851ad0b",
            "question": "名为Sprite的类的默认构造函数的正确声明是什么？",
            "answer": "A",
            "explanation": "```cpp\npublic: Sprite();\n```\n```cpp\nprivate: void Sprite();\n```\n```cpp\npublic: void Sprite();\n```\n```cpp\nprivate: Sprite();\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7fad0b7b180a8fa0c871d29f",
            "question": "头文件中这一行的目的是什么？\n```cpp\n#pragma once\n```",
            "answer": "使编译器只解析一次该头文件，即使它在源中被多次包含",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/preprocessor/impl)",
            "hint": null,
            "correctAnswer": ["使编译器只解析一次该头文件，即使它在源中被多次包含"],
            "options": [
              "限制其内容仅用于一个源文件",
              "告诉编译器此头文件中包含的类或类型只能实例化一个变量",
              "通过确保此头文件中包含的代码只需要一次编译器传递来帮助编译器更快地完成",
              "使编译器只解析一次该头文件，即使它在源中被多次包含"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "87e2cdb8be04dec275e80378",
            "question": "double类型的变量是什么？",
            "answer": "浮点数",
            "explanation": "[参考](https://www.educba.com/c-plus-plus-double/)",
            "hint": null,
            "correctAnswer": ["浮点数"],
            "options": ["2元组", "整数", "浮点数", "超过255个字符的字符串"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fffb3b5ca94f6e27c5cce8b8",
            "question": "除了将位向左移动之外，<<运算符还用于什么？",
            "answer": "将字符插入输出流，如std::cout。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["将字符插入输出流，如std::cout。"],
            "options": [
              "将字符串中的字符向左移动。",
              "将字符插入输出流，如std::cout。",
              "将浮点数比较为小于。",
              "将变量分配给引用。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "381a243a304566ca0ea7799d",
            "question": "为什么要指定指针的类型而不是使用`void *`（它可以作为指向任何类型的指针）？",
            "answer": "编译器需要数据类型以知道为指针分配多少内存，因为不同的数据类型需要不同的指针长度。",
            "explanation": "[参考](https://stackoverflow.com/questions/9802585/why-is-the-data-type-needed-in-pointer-declarations)",
            "hint": null,
            "correctAnswer": [
              "编译器需要数据类型以知道为指针分配多少内存，因为不同的数据类型需要不同的指针长度。"
            ],
            "options": [
              "编译器需要数据类型以确保指针不会用于非法的不可指向类型，如函数、标签、指针和引用。",
              "`void *`不适用于任何类型。语言不允许将void以外的任何内容分配给指向`void *`的指针。",
              "编译器需要数据类型以知道为指针分配多少内存，因为不同的数据类型需要不同的指针长度。",
              "是的，它导致编译器错误，因为一个字段的大小定义为0。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b7ad90f958469d562d4f10fd",
            "question": "这段代码有什么问题？\n```cpp\n#include <iostream>\nchar str[20];\nint main(){\n    std::cout << \"What's your name? \";\n    str << std::cin\n    std::cout << \"Hello, \" << str;\n    return 0;\n}\n```",
            "answer": "输入运算符流被反转了。它应该从`std::cin`开始，然后流(>>)到`str`中。",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "输入运算符流被反转了。它应该从`std::cin`开始，然后流(>>)到`str`中。"
            ],
            "options": [
              "main函数应该有void返回类型。",
              "`std::cin`和`std::cout`无效。字符输入和输出流的正确名称是`cin`和`cout`。",
              "应该使用`str`的地址。即`&str`而不是`str`。",
              "输入运算符流被反转了。它应该从`std::cin`开始，然后流(>>)到`str`中。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "835a6787765dc675439c41a3",
            "question": "当放置在有效的执行上下文中时，哪个语句将从堆中动态分配内存以存储值为11的整数？",
            "answer": "`int* anInt = new int(11);`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`int* anInt = new int(11);`"],
            "options": [
              "`int anInt = new int(11);`",
              "`int* anInt = new int[11];`",
              "`int anInt = new int[11];`",
              "`int* anInt = new int(11);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "873d5b0efa12c3823bd65c54",
            "question": "以下哪项最好地描述了`long`类型？",
            "answer": "至少32位的整数",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["至少32位的整数"],
            "options": ["至少32位的整数", "超过255个字符的字符串", "指针", "64位浮点数"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ad43b6f3e2badc89aa1bf939",
            "question": "以下哪种类型的功能最接近类？",
            "answer": "`struct`",
            "explanation": "[参考](https://en.cppreference.com/w/c/language/struct)",
            "hint": null,
            "correctAnswer": ["`struct`"],
            "options": ["`struct`", "`union`", "`enum`", "`namespace`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fcfd6fbc6b68099addbe5013",
            "question": "给定映射中的这些记录，您将如何将键\"Sinead\"的值更新为22？\n![image](images/Q79.png)",
            "answer": "`marks[\"Sinead\"] = 22`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`marks[\"Sinead\"] = 22`"],
            "options": [
              "`marks[\"Sinead\"] = 22`",
              "`marks[\"Sinead\"].22`",
              "`marks[\"Sinead\"] -> 22`",
              "`marks[\"Sinead\"].value = 22`"
            ],
            "nature": "ChooseOne",
            "attachments": [
              {
                "id": "53ba69d6b3f0f93ed52762f7",
                "url": "/Users/arslankaleem/Workspace/Junk/linkedin-skill-assessments-quizzes/c++/images/Q79.png",
                "type": "question"
              }
            ],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e6e840ffff0c6f57b5089c75",
            "question": "为什么std::sort可以接收函数对象作为其参数之一？",
            "answer": "`std::sort函数是一个模板。程序员可以自由地在函数对象中输入排序算法作为参数。`",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "`std::sort函数是一个模板。程序员可以自由地在函数对象中输入排序算法作为参数。`"
            ],
            "options": [
              "`std::sort函数是一个模板。程序员可以自由地在函数对象中输入排序算法作为参数。`",
              "`实际上，std::sort只接受一个参数，即要排序的容器。`",
              "`std::sort在模板容器上操作。编译器不知道如何关系比较它包含的值，因此必须提供一个函数来进行比较。`",
              "`std::sort将使用参数函数作为错误处理程序。如果发生错误，将调用该函数。`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d46a985da21169775fe1af97",
            "question": "当您执行此代码片段时会发生什么？\n```\n#include <iostream>\nint main() {\nfloat a = 5.51;\nint b = static_cast<int>(a);\nstd::cout << b;\n}\n```",
            "answer": "`5将在标准输出上打印，不会生成编译警告。`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`5将在标准输出上打印，不会生成编译警告。`"],
            "options": [
              "`6将在标准输出上打印，不会生成编译警告。`",
              "`5将在标准输出上打印，不会生成编译警告。`",
              "`6将在标准输出上打印，会生成编译警告。`",
              "`5将在标准输出上打印，会生成编译警告。`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "758169550916bbf7d3cf9e87",
            "question": "哪个访问说明符不允许从类外部访问类成员，但允许派生类访问它们？",
            "answer": "protected",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["protected"],
            "options": ["guarded", "protected", "public", "private"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9e003200465babbb34a639d5",
            "question": "UNIX上C++程序的默认可执行文件生成是\\_",
            "answer": "a.out",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["a.out"],
            "options": ["a.exe", "a", "a.out", "out.a"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "66f22238670b84fdf8ae4d53",
            "question": "以下程序的输出是什么？\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\n  int a=1;\n  cout<<(a++)*(++a)<<endl;\n  return 0;\n}\n```",
            "answer": "3",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["3"],
            "options": ["1", "2", "3", "6"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "269a2aaa737d6c14bade4d3d",
            "question": "cout和cin中的\"c\"代表什么？",
            "answer": "character（字符）",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["character（字符）"],
            "options": [
              "compiler（编译器）",
              "console（控制台）",
              "character（字符）",
              "standard namespace（标准命名空间）"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "071a36d961b65854de352775",
            "question": "tellp()的用途是什么？",
            "answer": "当前输出指针位置",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["当前输出指针位置"],
            "options": [
              "当前输入指针位置",
              "当前输出指针位置",
              "最后输入指针位置",
              "最后输出指针位置"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0086acf8c4448264d62f52d7",
            "question": "什么是回调函数？",
            "answer": "指向函数的指针",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["指向函数的指针"],
            "options": ["指向指针的指针", "指向函数的指针", "用于指针的函数", "用于类的函数"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "99c63dd94d91698ac33c4a84",
            "question": "在C++中输出\"Hello World\"的正确语法是什么？",
            "answer": "`cout << \"Hello World\";`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`cout << \"Hello World\";`"],
            "options": [
              "`cout << \"Hello World\";`",
              "`System.out.println(\"Hello World\");`",
              "`print(\"Hello World\");`",
              "`Console.WriteLine(\"Hello World\");`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fc35bddb2e02b67a643bca95",
            "question": "C++中有多少类别的迭代器？",
            "answer": "5",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["4", "3", "7", "5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3856388c32f4c3cbad875da2",
            "question": "C++中基类的含义是什么？",
            "answer": "另一个类从这个类继承",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["另一个类从这个类继承"],
            "options": [
              "它继承其他类",
              "它有一个指针变量",
              "它是声明的第一个类",
              "另一个类从这个类继承"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "78c0f59c8ed01563e64a6562",
            "question": "C++对象的大小以 ** 大小的倍数表示，char的大小是 **。",
            "answer": "char, 1",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["char, 1"],
            "options": ["char, 4", "float, 8", "int, 1", "char, 1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9072a4a4312b3557b69bd97d",
            "question": "关于实现的实现相关方面可以在哪里找到",
            "answer": "`<limits>`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`<limits>`"],
            "options": ["`<numeric>`", "`<limit>`", "`<limits>`", "`<implementation>`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "741ec5ea41724e3b7b724f2e",
            "question": "什么是默认构造函数？",
            "answer": "可以不带参数使用的构造函数",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["可以不带参数使用的构造函数"],
            "options": [
              "可以不带参数使用的构造函数",
              "没有返回值的构造函数",
              "由多个类使用的构造函数",
              "初始化类的所有成员的构造函数"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d541aa82b84d47365424b304",
            "question": "在保护头文件时，为什么要使用'#pragma once'而不是'include'保护？",
            "answer": "包含保护使用宏来实现单一包含，但编译器无法阻止程序员在其他地方定义该宏，这将导致根本没有包含",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "包含保护使用宏来实现单一包含，但编译器无法阻止程序员在其他地方定义该宏，这将导致根本没有包含"
            ],
            "options": [
              "没有理由选择，因为它们的目的不同",
              "包含保护使用宏来实现单一包含，但编译器无法阻止程序员在其他地方定义该宏，这将导致根本没有包含",
              "'#pragma once'保证头代码永远不会被更改，因为它由编译器强制执行",
              "包含保护引用文件系统中的头文件，而不是代码，因此如果头文件在项目中存在多次，它们没有帮助。'#pragma once'没有这个问题"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3aac56deb041701cd54fbe5e",
            "question": "以下哪个陈述是有效的？",
            "answer": "我们不能改变运算符模板。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["我们不能改变运算符模板。"],
            "options": [
              "我们可以创建一个新的C++运算符。",
              "我们可以改变C++运算符的优先级。",
              "我们不能改变运算符模板。",
              "我们可以改变C++运算符的结合性。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "de1e202db733b4a700d6048d",
            "question": "以下哪些会自动添加到每个类中，如果我们不编写自己的？",
            "answer": "以上所有",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["以上所有"],
            "options": ["拷贝构造函数", "赋值运算符", "没有任何参数的构造函数", "以上所有"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a0c4c7b62a1d238f0e66de27",
            "question": "if-else语句可以被哪个运算符替换？",
            "answer": "选择结构",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["选择结构"],
            "options": ["某种结构", "选择结构", "选择结构", "以上都不是"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6605f17ff7187f4eea0d0b3a",
            "question": "以下哪个选择是阶乘n!问题的递归解决方案？",
            "answer": "&shy;",
            "explanation": "```cpp\nvoid fact(int n) {\nif (n <= 0)\nreturn 0;\nelse\nreturn 1;\n}\n```\n```cpp\nint fact(int n) {\nif (n <= 0)\nreturn 1;\nelse\nreturn (fact(n) * (n-1));\n}\n```\n```cpp\nint fact(int n) {\nif (n >= 0)\nreturn 1;\nelse\nreturn (fact(n-1) * n);\n}\n```\n```cpp\nint fact(int n) {\nif (n <= 0)\nreturn 1;\nelse\nreturn (fact(n-1) * n);\n}\n```",
            "hint": null,
            "correctAnswer": ["&shy;"],
            "options": ["&shy;", "&shy;", "&shy;", "&shy;"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "85e9748e6ef0b1f85c36db90",
            "question": "当发生各种情况时，可以调用类析构函数。以下哪个选择不是这些情况之一？",
            "answer": "垃圾收集器检测到不再使用对象。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["垃圾收集器检测到不再使用对象。"],
            "options": [
              "程序终止。这会调用静态持续时间对象的析构函数。",
              "为使用new运算符分配的对象指针调用delete()函数。",
              "垃圾收集器检测到不再使用对象。",
              "自动存储期对象超出作用域。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b3ac93dbd1f4e5e509227306",
            "question": "您正在用C++设计外汇支付系统，您需要对具有整数作为数量和浮点数作为价格的货币交易进行建模。然后您想声明此类型的实际对象。您将如何实现这一点？",
            "answer": "A",
            "explanation": "```cpp\nstruct currencyDeal {\nfloat price;\nint quantity;\n};\ncurrencyDeal firstDeal;\n```\n```cpp\nunion currencyDeal {\nfloat price;\nint quantity;\n};\ncurrencyDeal firstDeal;\n```\n```cpp\nstruct currencyDeal {\nfloat price;\nint quantity;\n};\n```\n```cpp\nunion currencyDeal {\nfloat price;\nint quantity;\n};\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c13626b531ea4907a46bd2a3",
            "question": "如果您尝试使用checkConcatThreshold(\"a\");调用此函数，会发生什么？\n```cpp\nint checkConcatThreshold(string a, string b) {\n    return (a + b).length () > 120;\n}\n```",
            "answer": "将发生编译错误。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["将发生编译错误。"],
            "options": [
              "将发生编译警告，第二个参数将被赋予默认值b。",
              "将发生编译警告，第二个参数将被赋予空字符串的默认值。",
              "将发生编译错误。",
              "不会发生编译错误，也不会发生编译警告。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "665b338e5f13cde9c4a45a30",
            "question": "您需要定义一个C++ lambda函数。您希望该函数只能访问其本地的变量。该函数应接收单个参数和一个名称，并构建一个简单的问候语。您将如何实现这一点？",
            "answer": "C",
            "explanation": "```cpp\nauto myVeryFirstLambda = [=] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nmyVeryFirstLambda = [&] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nauto myVeryFirstLambda = [] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nmyVeryFirstLambda = [] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n[参考](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160)",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "05b2c021ab8aed2d7211ab01",
            "question": "运行此代码后X的值是多少？\n```cpp\nint x=10, a=-3;\nX+=a;\n```",
            "answer": "7",
            "explanation": "**解释：**`+=`表示增加值。所以`x += a`等价于`x = x + a`",
            "hint": null,
            "correctAnswer": ["7"],
            "options": ["-3", "7", "13", "3"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "58c7b175e1ad9b9f377711f1",
            "question": "完成写入文件后，您将在`ofstream`上调用什么方法来通知操作系统？",
            "answer": "close()",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["close()"],
            "options": ["printout()", "close()", "destroy()", "flush()"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d16b219284b73a50ab1212f3",
            "question": "以下哪个选择不是C++关键字？",
            "answer": "comPl",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["comPl"],
            "options": ["static_assert", "reinterpret_cast", "comPl", "alignas"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c3b5e06e768aee89325c62f5",
            "question": "size_in_bits函数似乎可以接受任何类型的参数。这可以通过重载函数或让编译器通过编写模板来处理它来实现。以下哪个选择是该模板的实现？\n```cpp\nint main()\n{\ncout « size_in_bits(21) « endl;\ncout « size_in_bits('f') « endl;\ncout « size_in_bits(32.1f) « endl;\ncout « size_in_bits(32.1) « endl;\nreturn 0;\n}\n```",
            "answer": "A; C",
            "explanation": "```cpp\ntemplate <typename T>\nsize_t size_in_bits(const T& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\ntemplate size_t size_in_bits(const {int,float,double,char,long}& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\ntemplate <typename T {int,float,double,char,long>\nsize_t size_in_bits(const T& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\nsize_t size_in_bits(void * a){\nreturn sizeof(a)*8;\n}\n```",
            "hint": null,
            "correctAnswer": ["A", "C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4ae43dc8d9610edc42aaf35e",
            "question": "要使用键盘作为输入，需要包含iostream库。要从文件读取输入作为输入，需要什么库？",
            "answer": "fstream",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["fstream"],
            "options": ["fstream", "cstdlib", "filestream", "iostream"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6600b586b630ea3abb1be976",
            "question": "这个面向对象的程序将打印什么？\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Vehicle {\npublic:\n\tstring fuel = \"none\";\n};\nclass MotorizedVehicle : public Vehicle {\npublic:\n\tstring fuel = \"fossil\";\n};\nclass NextgenMotorizedVehicle : public MotorizedVehicle {\npublic:\n\tstring fuel = \"hydrogen\";\n};\nint main() {\n\tMotorizedVehicle aCar;\n\tcout << aCar.fuel;\n\treturn 0;\n}\n```",
            "answer": "fossil",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["fossil"],
            "options": ["fossil", "fossil none", "hydrogen", "none"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ae71dea4cbecba586b361f02",
            "question": "下面的程序正在处理一个栈容器。运行程序的输出是什么？\n```cpp\n#include <iostream>\n#include <stack>\nint main()\n{\n\tstd::stack<int> stack;\n\tstack.push(1);\n\tstack.push(2);\n\tstack.push(3);\n\tstack.pop();\n\tstack.push(4);\n\tstack.top();\n\tstack.pop();\n\tstd::cout << stack.top();\n}\n```",
            "answer": "2",
            "explanation": "#详细解释：\n现在我们应该实现一个遵循**FILO**或（先进后出）原则的栈数据结构，\n_stack.push()_ -> 从数组末尾推入元素。\n_stack.pop()_ -> 从数组末尾移除元素。\n_stack.top()_ -> 只给我们数组的最顶层元素。\n现在遵循push和pop的顺序：**[1,2,3]** 然后使用pop函数，\n新形成的数组是：**[1,2,4]** 然后使用top检索最顶层的元素'4'，然后再次使用pop函数，该函数删除4。\n因此，结果数组是：1,2。\n然后它打印最顶层的元素（即：2）。",
            "hint": null,
            "correctAnswer": ["2"],
            "options": ["1", "2", "3", "4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3d1638d6b780a353a71e537a",
            "question": "以下哪个选择是重载三元条件运算符的有效方法？",
            "answer": "`三元运算符不可重载。`",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/language/operators)",
            "hint": null,
            "correctAnswer": ["`三元运算符不可重载。`"],
            "options": [
              "`void& operator ?:(const bool cond, const void& iftrue, const void& iffalse);`",
              "`三元运算符不可重载。`",
              "`void& operator conditional(const bool cond, const void& iftrue, const void& iffalse);`",
              "`void* operator ?:(const bool cond, const void* iftrue, const void* iffalse);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5eb91416e77ebe4cafe1d203",
            "question": "哪个类层次结构代表多级继承的示例？",
            "answer": "在同一程序中，在不同的点，给定的类分别从两个以上的不同类派生。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["在同一程序中，在不同的点，给定的类分别从两个以上的不同类派生。"],
            "options": [
              "在同一程序中，在不同的点，给定的类分别从多个不同的类派生。",
              "第一类同时直接从第二和第三类派生。",
              "在同一程序中，在不同的点，给定的类分别从两个以上的不同类派生。",
              "第一个类从第二个类派生，第二个类已经从第三个类派生"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e4187da8a84e84904cb4e281",
            "question": "以下哪个是在C++语言中打印消息的正确语法？",
            "answer": "cout <<\"Hello world!\";",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/io/cout)",
            "hint": null,
            "correctAnswer": ["cout <<\"Hello world!\";"],
            "options": [
              "Out <<\"Hello world!",
              "Cout << Hello world! ;",
              "cout <<\"Hello world!\";",
              "以上都不是"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "47786528aac3cdbf20f533b7",
            "question": "考虑以下程序。输出/错误是什么？\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nbool compare(char c1, char c2){\nreturn tolower(c1) > tolower(c2);    //LINE-1\n}\nint main(){\nchar arr1[20] = \"C++ Program\", arr2[20] = \"C Program\";\ncout << lexicographical_compare(arr1, arr1+strlen(arr1), arr2, arr2+strlen(arr2),\ncompare);\nreturn 0;\n}\n```",
            "answer": "1",
            "explanation": "[参考](https://www.geeksforgeeks.org/tolower-function-in-cpp/)",
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["1", "0", "-1", "编译错误：函数未定义"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d8c1dd256002fc906c2c8862",
            "question": "考虑以下代码段。在LINE-1处填空，使程序打印\"not found\"？\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint data[] = {1,2,3,4,5};\nint key = 5;\nif(binary_search(__________))    //LINE-1\ncout << \"found\";\nelse\ncout << \"not found\";\nreturn 0;\n}\n```",
            "answer": "&data[0], &data[4], key; data+1, data+4, key",
            "explanation": "[参考](https://www.geeksforgeeks.org/binary-search-algorithms-the-c-standard-template-library-stl/)",
            "hint": null,
            "correctAnswer": ["&data[0], &data[4], key", "data+1, data+4, key"],
            "options": [
              "&data[0], &data[5], key",
              "data, data+5, key",
              "&data[0], &data[4], key",
              "data+1, data+4, key"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "023325ca82d1f2853600be2f",
            "question": "考虑以下代码段。输出是什么？\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main () {\nint data[] = {50, 30, 40, 10, 20};\nsort (&data[1], &data[4]);\nfor (int i = 0; i < 5; i++)\ncout << data[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "50 10 30 40 20",
            "explanation": "[参考](https://cplusplus.com/reference/algorithm/sort/)",
            "hint": null,
            "correctAnswer": ["50 10 30 40 20"],
            "options": ["10 20 30 40 50", "10 30 40 50 20", "50 10 30 40 20", "50 10 20 30 40"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0df02179b8d067bdbc2288ae",
            "question": "考虑以下代码段。输出是什么？\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint element[5];\nfor(int i = 1; i <= 5; i++)\n*(element + i - 1) = i * 5;\nrotate(element, element + 4, element + 5);\nrotate(element, element + 1, element + 4);\nfor (int i = 0; i < 5; ++i)\ncout << element[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "5 10 15 25 20",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/algorithm/rotate)",
            "hint": null,
            "correctAnswer": ["5 10 15 25 20"],
            "options": ["5 10 15 20 25", "5 10 15 25 20", "20 10 15 25 5", "25 5 10 15 20"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "aacf9e26ca7b36d1714cf5dd",
            "question": "考虑以下代码段。输出是什么？\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nconst int size = 3, c = 65;\nvector<char> vc(size, 'A');\nfor (int i = 1; i <= 2; i++)\nvc.push_back(65 + i);\nvc.resize(10, 90);\nvc.resize(8);\nfor (int i = 0; i < vc.size(); i++)\ncout << vc[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "A A A B C Z Z Z",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/container/vector)",
            "hint": null,
            "correctAnswer": ["A A A B C Z Z Z"],
            "options": ["A A A B C Z Z Z", "A A B B C Z Z Z", "A A A B C Z Z", "A A A B C Z Z Z Z"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "27aaa3e6338174e2376b5aec",
            "question": "考虑以下代码段。选择适当的选项填写LINE-1处的空白，使代码的输出为：a C++ Program。\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nint main(void) {\nstring s1 = \"C++ \";\nstring s2 = \"Program\";\n__________________;    //LINE-1\ncout << s1;\nreturn 0;\n}\n```",
            "answer": "s1 += s2; s1.append(s2)",
            "explanation": "[参考](https://www.geeksforgeeks.org/stdstringappend-in-c/)",
            "hint": null,
            "correctAnswer": ["s1 += s2", "s1.append(s2)"],
            "options": ["s1 += s2", "strcat(s1, s2)", "s1.append(s2)", "s1.insert(s2)"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "165b9c8450e24ead470be0de",
            "question": "考虑以下代码段。在LINE-1处填空，使输出为5 2 3 4 5\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint data[] = { 1, 2, 3, 4, 5 };\nfor (int i = 0; i < 1; i++) {\nint j = data[i];\nreplace(data, data + 5, j, *(_________________));    //LINE-1\n}\nfor (int i = 0; i < 5; ++i)\ncout << data[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "data + 4 - i",
            "explanation": "[参考](https://www.geeksforgeeks.org/stdstringreplace-stdstringreplace_if-c/)",
            "hint": null,
            "correctAnswer": ["data + 4 - i"],
            "options": ["data + 4 - i", "data + 5 - i", "data + i - 4", "data + i - 5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7ba78ec33b835afe5a32ed99",
            "question": "考虑以下代码段。输出是什么？\n```cpp\n#include <iostream>\n#include <cstring>\n#include <stack>\nusing namespace std;\nint main(){\nchar str[10] = \"123456789\";\nstack<char> s1, s2;\nint i;\nfor(i = 0; i < strlen(str)/2; i++)\ns1.push(str[i]);\nfor(i=i-1; i < strlen(str); i++)\ns2.push(str[i]);\nwhile (!s1.empty()) {\ns2.push(s1.top()); s1.pop();\n}\nwhile (!s2.empty()) {\ncout << s2.top(); s2.pop();\n}\nreturn 0;\n}\n```",
            "answer": "1234987654",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/container/stack)",
            "hint": null,
            "correctAnswer": ["1234987654"],
            "options": ["1234987654", "123498765", "1234897654", "123459876"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "49fffbed84b7a381235c9fb3",
            "question": "考虑以下代码段。以下哪个/哪些语句是正确的？\n```cpp\nint i = 5;\nconst int *p = &i;\nint * const q = &i;\nint const *r = &i;\nint const * const s = &i;\n*p = 10; //STMT-1\n*q = 10; //STMT-2\n*r = 10; //STMT-3\n*s = 10; //STMT-4\n```",
            "answer": "STMT-2",
            "explanation": "[参考](https://www.geeksforgeeks.org/const-keyword-in-cpp/)",
            "hint": null,
            "correctAnswer": ["STMT-2"],
            "options": ["STMT-1", "STMT-2", "STMT-3", "STMT-4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e8cc540b017995688faf4928",
            "question": "考虑以下程序。输出/错误是什么？\n```cpp\n#include <iostream>\nusing namespace std;\nchar add(char c1 = 'a') { return c1; }\nchar add(char c1 = 'a', char c2 = 'b') { return c1 + c2 - 'a';}\nchar add(char c1 = 'a', int d1 = 100){ return c1 + d1 - 'a'; }\nchar add(char c1 = 'a', char c2 = 'b', char c3) { return c1 + c2 + c3 - 'a'; }\nint main() {\nchar c = add('o', 'k');\ncout << c << endl;\nreturn 0;\n}\n```",
            "answer": "编译错误：\"char add(char, char, char)\"缺少默认参数; 编译错误：重载\"add(char, char)\"的调用不明确",
            "explanation": "[参考](https://learn.microsoft.com/en-us/cpp/cpp/function-overloading?view=msvc-170)",
            "hint": null,
            "correctAnswer": [
              "编译错误：\"char add(char, char, char)\"缺少默认参数",
              "编译错误：重载\"add(char, char)\"的调用不明确"
            ],
            "options": [
              "y",
              "z",
              "编译错误：\"char add(char, char, char)\"缺少默认参数",
              "编译错误：重载\"add(char, char)\"的调用不明确"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "427009bdacf87272e4e23ed4",
            "question": "考虑以下代码段。输出是什么？\n```cpp\n#include <iostream>\nusing namespace std;\n#define SQR(x) (x)*(x)\nint main() {\nint a=3;\ncout << SQR(a++) << endl;\nreturn 0;\n}\n```",
            "answer": "12",
            "explanation": "[参考](https://www.geeksforgeeks.org/output-of-the-program-use-macros-carefully/)",
            "hint": null,
            "correctAnswer": ["12"],
            "options": ["12", "25", "9", "16"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "562d759ac07e2fcef755ff2f",
            "question": "考虑以下代码段。哪一行/哪些行会给您一个错误？\n```cpp\n#include<iostream>\n#define X 1\nusing namespace std;\nint main(){\nint i;\nconst int i1 = 2;\nconst int i2 = i1; //LINE-1\ni2 = X;\ni = i1;\ni1 = i;\nreturn 0;\n//LINE-2\n//LINE-3\n//LINE-4\n}\n```",
            "answer": "LINE-2; LINE-4",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["LINE-2", "LINE-4"],
            "options": ["LINE-1", "LINE-2", "LINE-3", "LINE-4"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4f13982eecbfb568295c0065",
            "question": "考虑以下代码段。输出/错误是什么？\n```cpp\n#include<iostream>\nusing namespace std;\nint main(){\nint a = 5;\nint &b = a+1;\na = a*b;\ncout << a << \" \" << b;\nreturn 0;\n}\n```",
            "answer": "编译错误：非const引用的无效初始化",
            "explanation": "#详细解释：\n发生错误是因为它试图创建对临时值的引用。在int &b = a+1;行中，我们试图创建对表达式a + 1结果的引用b，这是一个临时值。引用必须绑定到实际对象，而不是临时值或没有内存位置的表达式。",
            "hint": null,
            "correctAnswer": ["编译错误：非const引用的无效初始化"],
            "options": ["36", "30", "25", "编译错误：非const引用的无效初始化"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2f1ab8d81b7991ec7826d7c3",
            "question": "考虑以下代码段。输出是什么？\n```cpp\n#include <iostream>\nusing namespace std;\nint& func(int& i) {     //LINE-1\nreturn i = i+5;\n}\nint main() {\nint x = 1, y = 2;\nint& z = func(x);\ncout << x << \" \" << z << \" \";\nfunc(x) = y;\ncout << x << \" \" << z;\nreturn 0;\n}\n```",
            "answer": "6 6 2 2",
            "explanation": "[参考](https://www.ibm.com/docs/en/zos/2.4.0?topic=calls-pass-by-reference-c-only)",
            "hint": null,
            "correctAnswer": ["6 6 2 2"],
            "options": ["6 6 2 2", "6 6 7 7", "1 1 2 2", "1 1 7 7"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c77e107ef3dff546ac263fef",
            "question": "考虑以下代码段。选择适当的选项填写LINE-1处的空白，使代码的输出为：300 20000。\n```cpp\n#include <iostream>\nusing namespace std;\nvoid compute(int n1, int n2, ________, ________){  //LINE-1\nn3 = n1 + n2;\n*n4 = n1 * n2;\n}\nint main(){\nint a = 100, b = 200, c = 0, d = 0;\ncompute(a, b, c, &d); //LINE-2\ncout << c << \", \";\ncout << d;\nreturn 0;\n}\n```",
            "answer": "int& n3, int \\*n4",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["int& n3, int \\*n4"],
            "options": [
              "int n3, int\\* n4",
              "int& n3, int \\*n4",
              "int* n3, int* n4",
              "int& n3, int& n4"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "01a52eb348c8b2accdc0fde6",
            "question": "考虑以下代码段。输出/错误是什么？\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\nint a = 2, *b;\n*b = 5;\nint * const ptr;    // LINE-1\n// LINE-2\nptr = b;\ncout << *ptr;\nreturn 0;\n}\n```",
            "answer": "LINE-1的编译错误：未初始化的const 'ptr'; LINE-2的编译错误：对只读变量'ptr'的赋值",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "LINE-1的编译错误：未初始化的const 'ptr'",
              "LINE-2的编译错误：对只读变量'ptr'的赋值"
            ],
            "options": [
              "`<垃圾值>`",
              "5",
              "LINE-1的编译错误：未初始化的const 'ptr'",
              "LINE-2的编译错误：对只读变量'ptr'的赋值"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "62ca7e3adfc0c0f4f4fc1742",
            "question": "考虑以下代码段。输出/错误是什么？\n```cpp\n#include <iostream>\nusing namespace std;\nvoid fun(int a = 5) { cout << a << endl; }\n//LINE-1\nint fun(int x = 10) { cout << x << endl; return 0; }    //LINE-2\nint main() {\nfun();\nreturn 0;\n}\n```",
            "answer": "LINE-2的编译错误：'int fun(int)'的新声明产生歧义",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["LINE-2的编译错误：'int fun(int)'的新声明产生歧义"],
            "options": ["5", "10", "5", "LINE-2的编译错误：'int fun(int)'的新声明产生歧义"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2fa29d6a73c2eb4878417cbb",
            "question": "考虑以下代码段。在LINE-1处填空，使程序打印5 + i3\n```cpp\n#include<iostream>\nusing namespace std;\nstruct complex{\nint re, im;\nvoid show(){ cout << re << \" + i\" << im; }\n};\n______________________________________{ //Line-1\nc2.re = c1.re+c2.re;\nc2.im = c1.im+c2.im;\nreturn c2;\n}\nint main(){\nstruct complex c1={2,5},c2{3,-2};\nstruct complex t = c1 + c2;\nt.show();\nreturn 0;\n}\n```",
            "answer": "complex operator+(complex &c1, complex &c2)",
            "explanation": "[参考](https://www.w3schools.com/cpp/cpp_structs.asp)",
            "hint": null,
            "correctAnswer": ["complex operator+(complex &c1, complex &c2)"],
            "options": [
              "complex operator+(complex &c1, complex &c2)",
              "complex operator+(const complex &c1, const complex &c2)",
              "operator+(complex &c1, complex &c2)",
              "complex +(complex &c1, complex &c2)"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4323a0644968b5b6afa86597",
            "question": "考虑以下程序。哪一行/哪些行会产生错误？\n```cpp\n#include<iostream>\nusing namespace std;\nclass myClass{\nint pra = 5;\npublic:\nint pub = 10;\nvoid set_pr(int x){ pra = x; }\nvoid set_pu(int x){ pub = x; }\n};\nint main(){\nmyClass m;\nint a, b;\na = m.pra; //LINE-1\nb = m.pub; //LINE-2\nm.set_pr(100); //LINE-3\nm.set_pu(200); //LINE-4\nreturn 0;\n}\n```",
            "answer": "LINE-1",
            "explanation": "[参考](https://stackoverflow.com/questions/4855422/c-classes-public-private-and-protected)",
            "hint": null,
            "correctAnswer": ["LINE-1"],
            "options": ["LINE-1", "LINE-2", "LINE-3", "LINE-4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "afad3f97bc91a993e0aea943",
            "question": "考虑以下类。用适当的访问说明符填空，使成员y可以从类外部访问，但成员x不能被访问。\n```cpp\nclass Test{\n________:\nint x;\n________:\nint y;\n/* Some more code */\n};\n```",
            "answer": "private, private",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["private, private"],
            "options": ["public, public", "public, private", "private, public", "private, private"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "98b18ede9265160dc7de8f4e",
            "question": "哪个C++标准添加了类内默认成员初始化器？",
            "answer": "C++11",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C++11"],
            "options": ["C++98", "C++11", "C++14", "C++17."],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "31209ebfe20732e225359077",
            "question": "您可以对非静态数据成员使用auto类型推导吗？",
            "answer": "否",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["否"],
            "options": ["是的，自C++11起", "否", "是的，自C++20起"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0bac5e363ae95bbf6f6ea7d4",
            "question": "您需要在cpp文件中定义静态内联数据成员吗？",
            "answer": "否，定义发生在声明静态内联成员的同一位置。",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": ["否，定义发生在声明静态内联成员的同一位置。"],
            "options": [
              "否，定义发生在声明静态内联成员的同一位置。",
              "是的，编译器需要cpp文件中的定义。",
              "是的，编译器需要在使用此变量的所有翻译单元中进行定义。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d395c3a65e0cf2f100936178",
            "question": "以下代码的输出是什么：\n```cpp\nstruct S {\n    int a { 10 };\n    int b { 42 };\n};\nS s { 1 };\nstd::cout << s.a << \", \" << s.b;\n```",
            "answer": "输出是：1, 42",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["输出是：1, 42"],
            "options": ["输出是：1, 0", "输出是：10, 42", "输出是：1, 42"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9067c08676d85a286144bc6a",
            "question": "静态内联变量可以是非常量的吗？",
            "answer": "是的，它只是一个普通变量。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["是的，它只是一个普通变量。"],
            "options": ["是的，它只是一个普通变量。", "否，内联变量必须是常量。"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bdb415c921845868514cddd5",
            "question": "考虑以下代码：\n```cpp\nstruct C {\n    C(int x) : a(x) { }\n    int a { 10 };\n    int b { 42 };\n};\nC c(0);\n```",
            "answer": "C::a仅在构造函数中用0初始化一次。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C::a仅在构造函数中用0初始化一次。"],
            "options": [
              "C::a初始化两次。第一次用10初始化，然后在构造函数中用0第二次初始化。",
              "C::a仅在构造函数中用0初始化一次。",
              "代码无法编译，因为编译器无法决定如何初始化C::a成员。",
              "2字节"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bfa6d2960ca96f0727a9e1c0",
            "question": "从构造函数抛出异常时会发生什么？",
            "answer": "对象被视为\"部分创建\"，因此编译器不会调用其析构函数。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["对象被视为\"部分创建\"，因此编译器不会调用其析构函数。"],
            "options": [
              "对象被视为\"已创建\"，因此它将遵循对象的常规生命周期。",
              "对象被视为\"部分创建\"，因此编译器不会调用其析构函数。",
              "编译器调用std::terminate，因为您不能从构造函数抛出异常。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e8fcad8c4a46ff22b72dd543",
            "question": "编译此代码时会发生什么？\n```cpp\nstruct Point { int x; int y; };\nPoint pt {.y = 10, .x = 11 };\nstd::cout << pt.x << \", \" << pt.y;\n```",
            "answer": "代码无法编译。指示符必须与Point类中的数据成员顺序相同。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["代码无法编译。指示符必须与Point类中的数据成员顺序相同。"],
            "options": [
              "代码无法编译。指示符必须与Point类中的数据成员顺序相同。",
              "代码编译并打印11, 10。",
              "代码编译并打印10, 11。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cc346c00f319524ee2bfbd75",
            "question": "此代码在C++11中能工作吗？\n```cpp\nstruct User { std::string name = \"unknown\"; unsigned age { 0 }; };\nUser u { \"John\", 101 };\n```",
            "answer": "代码从C++14模式开始编译。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["代码从C++14模式开始编译。"],
            "options": [
              "是的，代码在C++11模式下编译。",
              "代码从C++14模式开始编译。",
              "即使在C++20中，代码也无法编译。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "84e82059bb79fb6e343aafe4",
            "question": "假设您有一个std::map<string, int> m;。选择关于以下循环的单个正确陈述：\n```cpp\nfor (const pair<string, int>& elem : m)\n```",
            "answer": "A 循环正确地迭代映射，不创建额外的副本。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["A 循环正确地迭代映射，不创建额外的副本。"],
            "options": [
              "A 循环正确地迭代映射，不创建额外的副本。",
              "B 循环将创建映射中每个元素的副本，因为elem的类型不匹配。",
              "C 代码无法编译，因为const pair无法绑定到映射。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c1e3381b467bb51dfb867e47",
            "question": "识别C++中用户定义头文件的正确扩展名。",
            "answer": ".h",
            "explanation": null,
            "hint": null,
            "correctAnswer": [".h"],
            "options": [".cpp", ".hg", ".h", ".hf"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "391ba68b0b535fbfaf037230",
            "question": "识别不正确的构造函数类型。\n```cpp\nauto x = 4000.22;\n```",
            "answer": "友元构造函数",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["友元构造函数"],
            "options": ["友元构造函数", "默认构造函数", "参数化构造函数", "拷贝构造函数"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d37b62666bede94553ecdea8",
            "question": "以下哪种数据类型在C++中支持但在C中不支持？",
            "answer": "bool",
            "explanation": "[参考]: https://stackoverflow.com/questions/1608318/is-bool-a-native-c-type",
            "hint": null,
            "correctAnswer": ["bool"],
            "options": ["bool", "int", "double", "float"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7cdbb88b663f242b470cd1d5",
            "question": "识别在C++中声明数组的正确语法。",
            "answer": "int arr[10]",
            "explanation": "[参考]: (https://en.cppreference.com/w/cpp/language/array)",
            "hint": null,
            "correctAnswer": ["int arr[10]"],
            "options": ["int arr[10]", "array arr[10]", "array{10}", "int arr"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5b7d62e02ca1d05654edbaf9",
            "question": "wchat_t的大小是。",
            "answer": "取决于系统中的位数",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["取决于系统中的位数"],
            "options": ["2", "4", "2或4", "取决于系统中的位数"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a7a59aae0a909992d7cbb3fc",
            "question": "当我们知道迭代次数时，以下哪个循环最好？",
            "answer": "for",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["for"],
            "options": ["while", "for", "do", "以上所有"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "10c357fe86a1da85bc4d0822",
            "question": "在C++中使用哪个关键字来定义宏？",
            "answer": "#define",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["#define"],
            "options": ["#macro", "#define", "macro", "keyword"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "343a7267fe0cfd16d9d28b2e",
            "question": "以下哪个运算符应该优先作为全局函数而不是成员方法进行重载？",
            "answer": "比较运算符",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["比较运算符"],
            "options": ["后缀++", "比较运算符", "插入运算符<<", "前缀++"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0df9b9bfd9fe812ef1ed6d4b",
            "question": "我们如何限制使用new动态分配类的对象？",
            "answer": "通过创建空的私有new和new[]运算符",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["通过创建空的私有new和new[]运算符"],
            "options": [
              "通过重载new运算符",
              "通过创建一个空的私有new运算符。",
              "通过创建空的私有new和new[]运算符",
              "通过重载new运算符和new[]运算符"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "eef8c005bc4ac5d70adc673d",
            "question": "下面代码的时间复杂度是多少？\n```cpp\nfor(int i=0;i<n;i++){\n   for(int j=0;j<n;j++){\n       cout<<\"hello\";\n    }\n}\n```",
            "answer": "O(n^2)",
            "explanation": "[参考](<https://medium.com/enjoy-algorithm/analysis-of-loop-in-programming-cc9a644ef8cd#:~:text=At%20each%20step%20of%20the%20iteration%2C%20the%20nested%20loop%20is,%20%3D%20O(n%C2%B2)>)",
            "hint": null,
            "correctAnswer": ["O(n^2)"],
            "options": ["O(n^3)", "O(n^2)", "O(n)", "O(1)"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "739d3aeb4545e0a9f768e7fb",
            "question": "下面给出的代码的输出是什么？\n```cpp\nint a=10;\nint k=++a;\nint m=a++;\ncout<<k+m;\n```",
            "answer": "22",
            "explanation": "**++a**和**a++**都将a的值增加1（即：11），因此k+m变为22。",
            "hint": null,
            "correctAnswer": ["22"],
            "options": ["20", "21", "22", "23"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9fb33106bb0b74ba0e8b49c6",
            "question": "哪个C++构造用于异常处理？",
            "answer": "try-catch",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["try-catch"],
            "options": ["try-catch", "if-else", "for循环", "switch-case"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0148e5093008f485878e0eba",
            "question": "C++中循环中`break`语句的目的是什么？",
            "answer": "终止循环",
            "explanation": "[参考]: (https://www.tutorialspoint.com/cprogramming/c_break_statement.htm)",
            "hint": null,
            "correctAnswer": ["终止循环"],
            "options": ["退出程序", "跳过当前迭代并继续下一次迭代", "终止循环", "返回一个值"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4ae72dcba5e05240e46a850b",
            "question": "在C++中，当与变量一起使用时，`const`关键字的目的是什么？",
            "answer": "它使变量不可变",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["它使变量不可变"],
            "options": [
              "它使变量不可变",
              "它改变数据类型",
              "它定义一个常量函数",
              "它使变量成为指针"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ae479b0b366a3717f6acef18",
            "question": "调用C++函数时哪个更有效？",
            "answer": "引用调用",
            "explanation": "[参考]: (https://www.algbly.com/More/MCQs/Cpp-mcq/Cpp-functions.html)",
            "hint": null,
            "correctAnswer": ["引用调用"],
            "options": ["引用调用", "值调用", "指针调用", "对象调用"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "58508c5c62122044e4b2ed51",
            "question": "以下C++程序的输出是什么？\n```cpp\n#include <iostream>\nusing namespace std;\nclass A{\npublic:\n\tA(){\n\t\tcout<<\"Constructor called\\n\";\n\t   }\n\t~A(){\n\t\tcout<<\"Destructor called\\n\";\n\t    }\n};\nint main(int argc, char const *argv[])\n{\n\tA *a = new A[5];\n\tdelete[] a;\n\treturn 0;\n}\n```",
            "answer": "\"Constructor called\"五次，然后\"Destructor called\"五次",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["\"Constructor called\"五次，然后\"Destructor called\"五次"],
            "options": [
              "段错误",
              "\"Constructor called\"五次，然后\"Destructor called\"五次",
              "\"Constructor called\"五次，然后\"Destructor called\"一次",
              "错误"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5fdfed89337b55adb0ecff34",
            "question": "以下哪个选择与将my_class中的成员变量count声明为static无关？\n```cpp\nclass my_class{\n    public: static int count;\n}\n```",
            "answer": "该变量不能被同一应用程序或线程中代码的任何部分修改。但是，其他线程可以修改它。",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "该变量不能被同一应用程序或线程中代码的任何部分修改。但是，其他线程可以修改它。"
            ],
            "options": [
              "所有尝试访问其count成员变量的对象实际上都引用唯一的类绑定静态count变量。",
              "即使没有定义类的对象，该变量也存在，因此可以在源代码的任何位置修改。",
              "该变量不能被同一应用程序或线程中代码的任何部分修改。但是，其他线程可以修改它。",
              "该变量只分配一次，无论实例化多少个对象，因为它绑定到类本身，而不是其实例。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b851d4802eaaaad62a163fff",
            "question": "C++中`constexpr`关键字的目的是什么？",
            "answer": "`constexpr`用于指示表达式可以在编译时求值，使其适合在常量表达式中使用。",
            "explanation": "[参考](https://learn.microsoft.com/en-us/cpp/cpp/constexpr-cpp?view=msvc-170#:~:text=constexpr%20indicates%20that%20the%20value,template%20arguments%20and%20array%20declarations.)",
            "hint": null,
            "correctAnswer": [
              "`constexpr`用于指示表达式可以在编译时求值，使其适合在常量表达式中使用。"
            ],
            "options": [
              "它用于在C++中定义常量。",
              "`constexpr`用于指定变量是常量指针。",
              "`constexpr`用于指示表达式可以在编译时求值，使其适合在常量表达式中使用。",
              "它是用于创建异步函数的关键字。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "96fdaaa03f5c19a88c5855e6",
            "question": "C++中的模板元程序是什么？\n- 参考(https://www.geeksforgeeks.org/template-metaprogramming-in-c/)",
            "answer": "模板元程序是编译时计算，其中模板和模板特化用于在编译时执行计算。",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["模板元程序是编译时计算，其中模板和模板特化用于在编译时执行计算。"],
            "options": [
              "模板元程序是一种高级编程语言。",
              "它指的是在C++中使用模板的元编程。",
              "它是一种用户界面设计模式。",
              "模板元程序是编译时计算，其中模板和模板特化用于在编译时执行计算。"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "018eaafae11c50d6dd5add71",
            "question": "识别前增量运算符的正确示例。",
            "answer": "++i",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["++i"],
            "options": ["++i", "i++", "--i", "+i"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9e3172161bb6a36e3b06996b",
            "question": "以下代码的输出是什么？\n```cpp\n{% raw %}\nint matrix[3][3] = {{1, 2, 3},{4, 5, 6},{7, 8, 9}};\nfor(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n        int a = matrix[i][j];\n        matrix[i][j] = matrix[j][i];\n        matrix[j][i] = a;\n    }\n}\n{% endraw %}\n```",
            "answer": "相同的矩阵",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["相同的矩阵"],
            "options": ["矩阵的转置", "相同的矩阵", "矩阵的镜像", "倒置矩阵"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2d01a766d84653f3bd97d38d",
            "question": "C++中的竞态条件是什么？",
            "answer": "多个线程并发访问共享数据，结果取决于它们执行的时间的条件",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/language/memory_model)",
            "hint": null,
            "correctAnswer": ["多个线程并发访问共享数据，结果取决于它们执行的时间的条件"],
            "options": [
              "程序运行速度比预期快的条件",
              "多个线程并发访问共享数据，结果取决于它们执行的时间的条件",
              "两个线程竞争CPU时间的条件",
              "循环执行太快需要减速的条件"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "758989c77a67653ec4728fe0",
            "question": "考虑以下具有竞态条件的代码。修复它的正确方法是什么？\n```cpp\n#include <thread>\n#include <vector>\nint counter = 0;\nvoid incrementCounter() {\n    for(int i = 0; i < 1000; i++) {\n        counter++;\n    }\n}\nint main() {\n    std::vector<std::thread> threads;\n    for(int i = 0; i < 10; i++) {\n        threads.push_back(std::thread(incrementCounter));\n    }\n    for(auto& t : threads) {\n        t.join();\n    }\n    return 0;\n}\n```",
            "answer": "使用`std::mutex`在关键部分的`counter++`周围锁定/解锁",
            "explanation": "[参考](https://en.cppreference.com/w/cpp/thread/mutex)",
            "hint": null,
            "correctAnswer": ["使用`std::mutex`在关键部分的`counter++`周围锁定/解锁"],
            "options": [
              "添加`volatile`关键字：`volatile int counter = 0;`",
              "使用`std::mutex`在关键部分的`counter++`周围锁定/解锁",
              "使用`std::this_thread::sleep_for()`延迟每次增量",
              "将`counter++`更改为`++counter`以实现原子操作"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "414f4d3fab39982752cc5721",
            "question": "C++11中`std::move`的作用是什么？",
            "answer": "将对象转换为右值引用，启用移动语义",
            "explanation": "**解释：**\n`std::move`是一个转换函数，它产生其参数的右值引用，允许资源被移动而不是复制。它本身并不实际移动任何东西，但使移动构造函数和移动赋值运算符能够被调用。\n[参考](https://en.cppreference.com/w/cpp/utility/move)",
            "hint": null,
            "correctAnswer": ["将对象转换为右值引用，启用移动语义"],
            "options": [
              "将对象复制到新位置",
              "将对象转换为右值引用，启用移动语义",
              "物理上将内存从一个地址移动到另一个地址",
              "删除对象并创建新对象"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7ba21c6c851ec0baf816d4bf",
            "question": "这段代码的输出是什么？\n```cpp\n#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v1 = {1, 2, 3};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v1.size() << \" \" << v2.size();\n    return 0;\n}\n```",
            "answer": "0 3",
            "explanation": "**解释：**\n在`std::move(v1)`之后，v1处于有效但未指定的状态。通常情况下，它会变为空（大小为0），而v2接管这些元素的所有权。\n[参考](https://en.cppreference.com/w/cpp/utility/move)",
            "hint": null,
            "correctAnswer": ["0 3"],
            "options": ["3 3", "0 3", "3 0", "编译错误"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c6ac71148bea0df0ba7ef281",
            "question": "C++中的lambda表达式是什么？",
            "answer": "可以从其封闭作用域捕获变量的匿名函数对象",
            "explanation": "**解释：**\nLambda表达式是C++11引入的特性，允许你编写内联匿名函数。它们可以捕获周围作用域的变量，通常与STL算法一起使用。\n[参考](https://en.cppreference.com/w/cpp/language/lambda)",
            "hint": null,
            "correctAnswer": ["可以从其封闭作用域捕获变量的匿名函数对象"],
            "options": [
              "数学函数",
              "可以从其封闭作用域捕获变量的匿名函数对象",
              "模板函数",
              "宏定义"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0ab3b4485ad2c8c62fea610f",
            "question": "C++11中`auto`关键字的作用是什么？",
            "answer": "从初始化器自动推导变量的类型",
            "explanation": "**解释：**\nC++11中的`auto`关键字能够从初始化器自动推导类型，使代码更简洁、更易于维护。\n[参考](https://en.cppreference.com/w/cpp/language/auto)",
            "hint": null,
            "correctAnswer": ["从初始化器自动推导变量的类型"],
            "options": [
              "使变量具有自动存储期",
              "从初始化器自动推导变量的类型",
              "使函数内联",
              "声明全局变量"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8c0d8480be6d8987d91839a5",
            "question": "`std::unique_ptr`和`std::shared_ptr`之间有什么区别？",
            "answer": "unique_ptr具有独占所有权，shared_ptr允许多个所有者",
            "explanation": "**解释：**\n`std::unique_ptr`提供独占所有权——只有一个unique_ptr可以拥有一个资源。`std::shared_ptr`使用引用计数允许多个shared_ptr拥有同一资源。\n[参考](https://en.cppreference.com/w/cpp/memory/unique_ptr)",
            "hint": null,
            "correctAnswer": ["unique_ptr具有独占所有权，shared_ptr允许多个所有者"],
            "options": [
              "unique_ptr具有独占所有权，shared_ptr允许多个所有者",
              "unique_ptr更快但不太安全",
              "shared_ptr只能用于类",
              "没有区别"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "edcc067ff99a61bb8aae8cc2",
            "question": "C++中的RAII是什么？",
            "answer": "资源获取即初始化",
            "explanation": "**解释：**\nRAII是C++编程惯用法，资源获取与对象生命周期绑定。资源在构造函数中获取，在析构函数中释放，确保正确清理。\n[参考](https://en.cppreference.com/w/cpp/language/raii)",
            "hint": null,
            "correctAnswer": ["资源获取即初始化"],
            "options": [
              "随机访问迭代器接口",
              "资源获取即初始化",
              "递归算法实现接口",
              "运行时分配和初始化"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "662f0dc7d9cafeb59136eeb5",
            "question": "这段代码的输出是什么？\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    auto lambda = [x]() mutable { x += 10; return x; };\n    std::cout << lambda() << \" \" << x;\n    return 0;\n}\n```",
            "answer": "15 5",
            "explanation": "**解释：**\nlambda按值捕获x。`mutable`关键字允许修改捕获的副本。原始的x保持不变。\n[参考](https://en.cppreference.com/w/cpp/language/lambda)",
            "hint": null,
            "correctAnswer": ["15 5"],
            "options": ["5 5", "15 5", "15 15", "5 15"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f040f8bbe945270c8cdda127",
            "question": "C++11中的`constexpr`是什么？",
            "answer": "指定函数或变量可以在编译时求值",
            "explanation": "**解释：**\n`constexpr`表示值或函数可以在编译时求值，实现编译时计算和优化。\n[参考](https://en.cppreference.com/w/cpp/language/constexpr)",
            "hint": null,
            "correctAnswer": ["指定函数或变量可以在编译时求值"],
            "options": [
              "只能用于整数的常量表达式",
              "指定函数或变量可以在编译时求值",
              "定义常量的宏",
              "声明常量指针的关键字"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ccd657fb97d3c1aa7499c1b9",
            "question": "`std::forward`的目的是什么？",
            "answer": "保留转发参数的值类别（左值/右值）",
            "explanation": "**解释：**\n`std::forward`在模板函数中使用，用于完美转发参数同时保留其值类别，这对实现完美转发至关重要。\n[参考](https://en.cppreference.com/w/cpp/utility/forward)",
            "hint": null,
            "correctAnswer": ["保留转发参数的值类别（左值/右值）"],
            "options": [
              "在内存中向前移动对象",
              "保留转发参数的值类别（左值/右值）",
              "向前遍历容器",
              "声明前向声明"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ce84e0c42ce9e85e2b5e13ed",
            "question": "什么是可变参数模板？",
            "answer": "接受可变数量模板参数的模板",
            "explanation": "**解释：**\n可变参数模板是C++11引入的特性，允许模板接受任意数量的模板参数，实现灵活的泛型编程。\n[参考](https://en.cppreference.com/w/cpp/language/parameter_pack)",
            "hint": null,
            "correctAnswer": ["接受可变数量模板参数的模板"],
            "options": [
              "具有不同返回类型的模板",
              "接受可变数量模板参数的模板",
              "可以多次实例化的模板",
              "具有可选参数的模板"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "49b44211c7b5c1479cda0306",
            "question": "`nullptr`代表什么？",
            "answer": "类型为std::nullptr_t的空指针常量",
            "explanation": "**解释：**\n`nullptr`是C++11引入的关键字，代表空指针。它是类型安全的，不同于NULL或0。\n[参考](https://en.cppreference.com/w/cpp/language/nullptr)",
            "hint": null,
            "correctAnswer": ["类型为std::nullptr_t的空指针常量"],
            "options": ["空字符", "类型为std::nullptr_t的空指针常量", "空字符串", "零值"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2e9174c90f309ce4ae6610b6",
            "question": "这段代码的输出是什么？\n```cpp\n#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> p1 = std::make_shared<int>(42);\n    std::shared_ptr<int> p2 = p1;\n    std::cout << p1.use_count();\n    return 0;\n}\n```",
            "answer": "2",
            "explanation": "**解释：**\np1和p2共享同一个整数的所有权，因此引用计数为2。\n[参考](https://en.cppreference.com/w/cpp/memory/shared_ptr)",
            "hint": null,
            "correctAnswer": ["2"],
            "options": ["1", "2", "42", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "db330c25439c4fa39e6b1df1",
            "question": "C++17中的`std::optional`是什么？",
            "answer": "可能包含或不包含值的包装器",
            "explanation": "**解释：**\n`std::optional`是一个模板类，表示可选值——它要么包含一个值，要么为空，提供类型安全的方式来表示\"无值\"。\n[参考](https://en.cppreference.com/w/cpp/utility/optional)",
            "hint": null,
            "correctAnswer": ["可能包含或不包含值的包装器"],
            "options": [
              "函数中的可选参数",
              "可能包含或不包含值的包装器",
              "可选编译的模板",
              "可选类型的关键字"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6e541d30694765d6e260fb2a",
            "question": "C++17中的结构化绑定是什么？\n```cpp\nauto [x, y, z] = std::make_tuple(1, 2, 3);\n```",
            "answer": "将类似元组的对象解包为单个变量的特性",
            "explanation": "**解释：**\n结构化绑定允许将对象分解为其组成元素，使处理元组、对或结构体时代码更易读。\n[参考](https://en.cppreference.com/w/cpp/language/structured_binding)",
            "hint": null,
            "correctAnswer": ["将类似元组的对象解包为单个变量的特性"],
            "options": [
              "将结构绑定在一起的方法",
              "将类似元组的对象解包为单个变量的特性",
              "创建结构化数据的方法",
              "结构成员的绑定"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "29a785e3b22d9a44cfa3a66a",
            "question": "C++17中的`std::string_view`是什么？",
            "answer": "避免复制的字符串非拥有引用",
            "explanation": "**解释：**\n`std::string_view`提供对字符串的轻量级非拥有引用，避免不必要的复制并提高性能。\n[参考](https://en.cppreference.com/w/cpp/string/basic_string_view)",
            "hint": null,
            "correctAnswer": ["避免复制的字符串非拥有引用"],
            "options": [
              "GUI中字符串的视图",
              "避免复制的字符串非拥有引用",
              "只能查看不能修改的字符串",
              "用于显示字符串的视图类"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f076fc26ca25206441b32209",
            "question": "C++20中的concepts是什么？",
            "answer": "模板参数的命名需求集",
            "explanation": "**解释：**\nConcepts是C++20特性，允许你为模板参数指定约束，使模板代码更易读并提供更好的错误消息。\n[参考](https://en.cppreference.com/w/cpp/language/constraints)",
            "hint": null,
            "correctAnswer": ["模板参数的命名需求集"],
            "options": ["编程中的抽象概念", "模板参数的命名需求集", "概念设计模式", "文档注释"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "70c2c57b73b4ba9687ba55e2",
            "question": "C++20中的三路比较运算符（<=>）是什么？",
            "answer": "返回排序信息（小于、等于、大于）的运算符",
            "explanation": "**解释：**\n飞船运算符（<=>）执行三路比较并返回排序类别，简化了比较运算符的定义。\n[参考](https://en.cppreference.com/w/cpp/language/operator_comparison)",
            "hint": null,
            "correctAnswer": ["返回排序信息（小于、等于、大于）的运算符"],
            "options": [
              "三个值的比较",
              "返回排序信息（小于、等于、大于）的运算符",
              "三个独立的比较运算符",
              "三元比较"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7c4b804929dad72768b5a072",
            "question": "C++20中的`std::span`是什么？",
            "answer": "连续对象序列的非拥有视图",
            "explanation": "**解释：**\n`std::span`提供对连续对象序列的视图而不拥有它们，用于在不复制的情况下传递类数组数据。\n[参考](https://en.cppreference.com/w/cpp/container/span)",
            "hint": null,
            "correctAnswer": ["连续对象序列的非拥有视图"],
            "options": [
              "时间跨度测量",
              "连续对象序列的非拥有视图",
              "生成树数据结构",
              "HTML中的span元素"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b33cdc50fe34d9748d46c5db",
            "question": "这段代码的输出是什么？\n```cpp\n#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v = {1, 2, 3, 4, 5};\n    for (auto& x : v) {\n        x *= 2;\n    }\n    std::cout << v[2];\n    return 0;\n}\n```",
            "answer": "6",
            "explanation": "**解释：**\n带有`auto&`的基于范围的for循环就地修改每个元素。v[2]（原本是3）变为6。\n[参考](https://en.cppreference.com/w/cpp/language/range-for)",
            "hint": null,
            "correctAnswer": ["6"],
            "options": ["3", "6", "2", "12"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2ca867d58e240302a75fdafa",
            "question": "C++17中的`std::variant`是什么？",
            "answer": "可以保存几种类型之一的类型安全联合",
            "explanation": "**解释：**\n`std::variant`是类型安全的联合，可以保存几种指定类型之一的值，提供比C联合更安全的替代方案。\n[参考](https://en.cppreference.com/w/cpp/utility/variant)",
            "hint": null,
            "correctAnswer": ["可以保存几种类型之一的类型安全联合"],
            "options": [
              "可以变化的变量",
              "可以保存几种类型之一的类型安全联合",
              "类的变体",
              "变量模板"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e0e10d1344d99dd6971120f1",
            "question": "C++17中的`std::any`是什么？",
            "answer": "任何类型单个值的类型安全容器",
            "explanation": "**解释：**\n`std::any`可以存储任何可复制构造类型的单个值，提供带运行时类型检查的类型安全存储。\n[参考](https://en.cppreference.com/w/cpp/utility/any)",
            "hint": null,
            "correctAnswer": ["任何类型单个值的类型安全容器"],
            "options": ["任何类型的变量", "任何类型单个值的类型安全容器", "通配符类型", "可选类型"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "91bdfa0a9d2451ab2321fa80",
            "question": "`std::array`和C风格数组之间有什么区别？",
            "answer": "std::array知道自己的大小并提供成员函数",
            "explanation": "**解释：**\n`std::array`是封装固定大小数组的容器，提供大小信息和STL容器接口，同时保持C风格数组的性能。\n[参考](https://en.cppreference.com/w/cpp/container/array)",
            "hint": null,
            "correctAnswer": ["std::array知道自己的大小并提供成员函数"],
            "options": [
              "std::array知道自己的大小并提供成员函数",
              "std::array更慢",
              "C风格数组更安全",
              "没有区别"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "73174b6fef45896f2eabca3c",
            "question": "什么是完美转发？",
            "answer": "将参数传递给另一个函数时保留参数的值类别",
            "explanation": "**解释：**\n完美转发使用`std::forward`和通用引用将参数传递给另一个函数，同时保留其值类别（左值或右值）。\n[参考](https://en.cppreference.com/w/cpp/utility/forward)",
            "hint": null,
            "correctAnswer": ["将参数传递给另一个函数时保留参数的值类别"],
            "options": [
              "无错误的转发",
              "将参数传递给另一个函数时保留参数的值类别",
              "快速参数传递",
              "函数的前向声明"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "62200ada28c66b67c3a1011e",
            "question": "这段代码的输出是什么？\n```cpp\n#include <iostream>\ntemplate<typename T>\nvoid func(T&& x) {\n    std::cout << std::is_lvalue_reference<T>::value;\n}\nint main() {\n    int a = 5;\n    func(a);\n    return 0;\n}\n```",
            "answer": "1",
            "explanation": "**解释：**\n当左值传递给通用引用时，T被推导为左值引用，所以`std::is_lvalue_reference<T>::value`为true（1）。\n[参考](https://en.cppreference.com/w/cpp/language/reference)",
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["1", "0", "5", "编译错误"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "35c6a6596b954eff3d69c78a",
            "question": "C++17中的`std::invoke`是什么？",
            "answer": "使用给定参数调用任何可调用对象的实用工具",
            "explanation": "**解释：**\n`std::invoke`提供统一的方式来调用任何可调用对象（函数、函数指针、成员函数、函数对象）及其参数。\n[参考](https://en.cppreference.com/w/cpp/utility/functional/invoke)",
            "hint": null,
            "correctAnswer": ["使用给定参数调用任何可调用对象的实用工具"],
            "options": [
              "调用程序的函数",
              "使用给定参数调用任何可调用对象的实用工具",
              "方法调用运算符",
              "构造函数的调用器"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "90af32c3005a866408ef0b49",
            "question": "C++17中的`if constexpr`是什么？",
            "answer": "在编译时丢弃分支的编译时条件",
            "explanation": "**解释：**\n`if constexpr`在编译时评估条件，只实例化选中的分支，在模板元编程中很有用。\n[参考](https://en.cppreference.com/w/cpp/language/if)",
            "hint": null,
            "correctAnswer": ["在编译时丢弃分支的编译时条件"],
            "options": [
              "常量if语句",
              "在编译时丢弃分支的编译时条件",
              "必须是常量的if语句",
              "带if的constexpr函数"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "817547676fa8037eeac8abb8",
            "question": "C++17中的折叠表达式是什么？",
            "answer": "将二元运算符应用于参数包所有元素的方法",
            "explanation": "**解释：**\n折叠表达式为可变参数模板中的参数包应用二元运算符提供简洁的语法。\n[参考](https://en.cppreference.com/w/cpp/language/fold)",
            "hint": null,
            "correctAnswer": ["将二元运算符应用于参数包所有元素的方法"],
            "options": [
              "折叠代码的表达式",
              "将二元运算符应用于参数包所有元素的方法",
              "折叠算法",
              "用于折叠容器的表达式"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "de329ecad6c9eb3161c29017",
            "question": "这段代码的输出是什么？\n```cpp\n#include <iostream>\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int* p = arr;\n    std::cout << *(p + 3);\n    return 0;\n}\n```",
            "answer": "4",
            "explanation": "**解释：**\n指针算术：p + 3指向第4个元素（索引3），即4。\n[参考](https://en.cppreference.com/w/cpp/language/operator_arithmetic)",
            "hint": null,
            "correctAnswer": ["4"],
            "options": ["1", "2", "3", "4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b6e63d03e82c463c7d2e6dcd",
            "question": "C++17中的`std::filesystem`是什么？",
            "answer": "在文件系统和路径上执行操作的库",
            "explanation": "**解释：**\n`std::filesystem`提供在文件系统及其组件（如路径、常规文件和目录）上执行操作的功能。\n[参考](https://en.cppreference.com/w/cpp/filesystem)",
            "hint": null,
            "correctAnswer": ["在文件系统和路径上执行操作的库"],
            "options": [
              "文件系统驱动程序",
              "在文件系统和路径上执行操作的库",
              "虚拟文件系统",
              "文件流类"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "32de2351a5d13de14b009c0e",
            "question": "`std::atomic`用于什么？",
            "answer": "无锁的共享变量线程安全操作",
            "explanation": "**解释：**\n`std::atomic`提供对共享变量的原子操作，确保线程安全访问而无需显式锁定。\n[参考](https://en.cppreference.com/w/cpp/atomic/atomic)",
            "hint": null,
            "correctAnswer": ["无锁的共享变量线程安全操作"],
            "options": [
              "原子能计算",
              "无锁的共享变量线程安全操作",
              "原子数据类型",
              "对原子的不可分割操作"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "046a0a4fa569d8c2a6198482",
            "question": "`std::mutex`和`std::recursive_mutex`之间有什么区别？",
            "answer": "recursive_mutex可以被同一线程多次锁定",
            "explanation": "**解释：**\n`std::recursive_mutex`允许同一线程多次锁定它，而`std::mutex`如果同一线程尝试两次锁定会导致死锁。\n[参考](https://en.cppreference.com/w/cpp/thread/recursive_mutex)",
            "hint": null,
            "correctAnswer": ["recursive_mutex可以被同一线程多次锁定"],
            "options": [
              "recursive_mutex可以被同一线程多次锁定",
              "mutex更快",
              "recursive_mutex已弃用",
              "没有区别"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ae4d6493eff90219d170a20f",
            "question": "C++11中的`std::future`是什么？",
            "answer": "提供对异步操作结果访问的对象",
            "explanation": "**解释：**\n`std::future`用于检索通过`std::async`或`std::promise`启动的异步操作的结果。\n[参考](https://en.cppreference.com/w/cpp/thread/future)",
            "hint": null,
            "correctAnswer": ["提供对异步操作结果访问的对象"],
            "options": [
              "C++的未来版本",
              "提供对异步操作结果访问的对象",
              "基于时间的类",
              "未来声明"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1fbc8021959a8cf2c42880a8",
            "question": "这段代码的输出是什么？\n```cpp\n#include <iostream>\nclass Base {\npublic:\n    virtual void show() { std::cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void show() override { std::cout << \"Derived\"; }\n};\nint main() {\n    Base* b = new Derived();\n    b->show();\n    delete b;\n    return 0;\n}\n```",
            "answer": "Derived",
            "explanation": "**解释：**\n由于虚函数多态性，即使指针类型是Base\\*，也会调用Derived类的show()。\n[参考](https://en.cppreference.com/w/cpp/language/virtual)",
            "hint": null,
            "correctAnswer": ["Derived"],
            "options": ["Base", "Derived", "编译错误", "未定义行为"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6c540f7feb3fa33391911615",
            "question": "`std::enable_if`用于什么？",
            "answer": "基于SFINAE的条件模板实例化",
            "explanation": "**解释：**\n`std::enable_if`用于SFINAE（替换失败不是错误）来有条件地启用或禁用模板特化。\n[参考](https://en.cppreference.com/w/cpp/types/enable_if)",
            "hint": null,
            "correctAnswer": ["基于SFINAE的条件模板实例化"],
            "options": [
              "启用if语句",
              "基于SFINAE的条件模板实例化",
              "启用功能",
              "检查是否启用某些内容"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8ac21c3fa3a24d2734ccaff2",
            "question": "C++11中的`std::tuple`是什么？",
            "answer": "异构值的固定大小集合",
            "explanation": "**解释：**\n`std::tuple`是可以保存不同类型元素的固定大小集合，将`std::pair`推广到任意数量的元素。\n[参考](https://en.cppreference.com/w/cpp/utility/tuple)",
            "hint": null,
            "correctAnswer": ["异构值的固定大小集合"],
            "options": ["两元素对", "异构值的固定大小集合", "值的三元组", "数学中的元组"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ac8de08e02270d6fa8d358d9",
            "question": "这段代码的输出是什么？\n```cpp\n#include <iostream>\nint main() {\n    int x = 10;\n    int& ref = x;\n    ref = 20;\n    std::cout << x;\n    return 0;\n}\n```",
            "answer": "20",
            "explanation": "**解释：**\nref是x的引用。修改ref直接修改x，所以x变为20。\n[参考](https://en.cppreference.com/w/cpp/language/reference)",
            "hint": null,
            "correctAnswer": ["20"],
            "options": ["10", "20", "编译错误", "未定义"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "054f3bac0ba48ad0a0783a34",
            "question": "`std::chrono`用于什么？",
            "answer": "时间实用工具，包括时钟、时间点和持续时间",
            "explanation": "**解释：**\n`std::chrono`是用于时间相关操作的库，提供具有类型安全的时钟、时间点和持续时间。\n[参考](https://en.cppreference.com/w/cpp/chrono)",
            "hint": null,
            "correctAnswer": ["时间实用工具，包括时钟、时间点和持续时间"],
            "options": [
              "按时间顺序排序",
              "时间实用工具，包括时钟、时间点和持续时间",
              "计时器函数",
              "慢性病管理"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f4339ac27b7e410091e7db6b",
            "question": "C++11中的`std::regex`是什么？",
            "answer": "用于正则表达式模式匹配的库",
            "explanation": "**解释：**\n`std::regex`为C++中的模式匹配和文本处理提供正则表达式支持。\n[参考](https://en.cppreference.com/w/cpp/regex)",
            "hint": null,
            "correctAnswer": ["用于正则表达式模式匹配的库"],
            "options": [
              "正则表达式引擎",
              "用于正则表达式模式匹配的库",
              "文本替换工具",
              "字符串格式化程序"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "dc4188707bb2aa5b235d87f7",
            "question": "`std::initializer_list`是什么？",
            "answer": "用于访问const T数组的轻量级代理对象",
            "explanation": "**解释：**\n`std::initializer_list`允许函数接受大括号括起的值列表，实现统一初始化语法。\n[参考](https://en.cppreference.com/w/cpp/utility/initializer_list)",
            "hint": null,
            "correctAnswer": ["用于访问const T数组的轻量级代理对象"],
            "options": [
              "初始化器列表",
              "用于访问const T数组的轻量级代理对象",
              "初始化函数",
              "列表构造函数"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "493dc10a99dbf9f3ca6d6de5",
            "question": "这段代码的输出是什么？\n```cpp\n#include <iostream>\nint main() {\n    const int x = 10;\n    int* p = const_cast<int*>(&x);\n    *p = 20;\n    std::cout << x;\n    return 0;\n}\n```",
            "answer": "10（未定义行为）",
            "explanation": "**解释：**\n这是未定义行为。通过const_cast修改const对象会导致不可预测的结果。编译器可能基于const假设进行优化。\n[参考](https://en.cppreference.com/w/cpp/language/const_cast)",
            "hint": null,
            "correctAnswer": ["10（未定义行为）"],
            "options": ["10（未定义行为）", "20", "编译错误", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1291c3be8806419b78430ff3",
            "question": "C++11中的`std::function`是什么？",
            "answer": "通用多态函数包装器",
            "explanation": "**解释：**\n`std::function`是类型擦除包装器，可以存储具有特定签名的任何可调用对象（函数、lambda、函数对象）。\n[参考](https://en.cppreference.com/w/cpp/utility/functional/function)",
            "hint": null,
            "correctAnswer": ["通用多态函数包装器"],
            "options": ["函数声明", "通用多态函数包装器", "函数指针", "函数式编程库"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2bd5e63ae0ad403a084124c5",
            "question": "`std::bind`用于什么？",
            "answer": "通过将参数绑定到函数来创建新的可调用对象",
            "explanation": "**解释：**\n`std::bind`通过将某些参数绑定到函数来创建新的函数对象，用于部分函数应用。\n[参考](https://en.cppreference.com/w/cpp/utility/functional/bind)",
            "hint": null,
            "correctAnswer": ["通过将参数绑定到函数来创建新的可调用对象"],
            "options": [
              "绑定变量",
              "通过将参数绑定到函数来创建新的可调用对象",
              "绑定类",
              "绑定内存"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ba75644efa2def7e380f6299",
            "question": "`std::unordered_map`基于什么？",
            "answer": "哈希表",
            "explanation": "**解释：**\n`std::unordered_map`使用哈希表实现，与`std::map`的O(log n)相比，提供平均O(1)的查找时间。\n[参考](https://en.cppreference.com/w/cpp/container/unordered_map)",
            "hint": null,
            "correctAnswer": ["哈希表"],
            "options": ["二叉搜索树", "哈希表", "链表", "数组"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "eb6aaf1a0b352a784da609f2",
            "question": "这段代码的输出是什么？\n```cpp\n#include <iostream>\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    std::cout << sizeof(arr) / sizeof(arr[0]);\n    return 0;\n}\n```",
            "answer": "5",
            "explanation": "**解释：**\nsizeof(arr)给出总字节数，sizeof(arr[0])给出每个元素的字节数。相除得到元素数量：5。\n[参考](https://en.cppreference.com/w/cpp/language/sizeof)",
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["4", "5", "20", "1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cbaf2b7b022adc72a712e473",
            "question": "C++14中的`std::make_unique`是什么？",
            "answer": "创建std::unique_ptr对象的函数",
            "explanation": "**解释：**\n`std::make_unique`是创建并返回`std::unique_ptr`的实用函数，提供异常安全性和更清晰的语法。\n[参考](https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique)",
            "hint": null,
            "correctAnswer": ["创建std::unique_ptr对象的函数"],
            "options": [
              "唯一标识符生成器",
              "创建std::unique_ptr对象的函数",
              "唯一性检查器",
              "唯一值创建器"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7a2a66abd01f905e673cf22c",
            "question": "C++14中的`std::exchange`是什么？",
            "answer": "原子地替换值并返回旧值",
            "explanation": "**解释：**\n`std::exchange`在单个操作中替换对象的值并返回其旧值。\n[参考](https://en.cppreference.com/w/cpp/utility/exchange)",
            "hint": null,
            "correctAnswer": ["原子地替换值并返回旧值"],
            "options": ["值交换程序", "原子地替换值并返回旧值", "交换运算符", "交换函数"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ae5681d38b1bf5a37894c05a",
            "question": "C++17中的`std::apply`是什么？",
            "answer": "使用元组参数调用可调用对象",
            "explanation": "**解释：**\n`std::apply`使用元组参数调用可调用对象，将元组解包为函数参数。\n[参考](https://en.cppreference.com/w/cpp/utility/apply)",
            "hint": null,
            "correctAnswer": ["使用元组参数调用可调用对象"],
            "options": ["应用程序启动器", "使用元组参数调用可调用对象", "应用函数", "函数应用器"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bf782ce1a6fd7d5080ac6ce4",
            "question": "这段代码的输出是什么？\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    int y = ++x + x++;\n    std::cout << y;\n    return 0;\n}\n```",
            "answer": "未定义行为",
            "explanation": "**解释：**\n在序列点之间多次修改x会导致未定义行为。结果不可预测。\n[参考](https://en.cppreference.com/w/cpp/language/eval_order)",
            "hint": null,
            "correctAnswer": ["未定义行为"],
            "options": ["11", "12", "未定义行为", "13"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8966e6e56d907d0259e8633e",
            "question": "C++11中的`std::decay`是什么？",
            "answer": "应用数组到指针、函数到指针转换并删除cv限定符",
            "explanation": "**解释：**\n`std::decay`应用类型转换，类似于按值传递参数时发生的转换。\n[参考](https://en.cppreference.com/w/cpp/types/decay)",
            "hint": null,
            "correctAnswer": ["应用数组到指针、函数到指针转换并删除cv限定符"],
            "options": [
              "衰减函数",
              "应用数组到指针、函数到指针转换并删除cv限定符",
              "弃用标记",
              "衰减常数"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e203d968403fb4957e4d1bc1",
            "question": "C++11中的`std::conditional`是什么？",
            "answer": "基于编译时布尔值选择一种类型或另一种类型",
            "explanation": "**解释：**\n`std::conditional`是元函数，根据编译时布尔条件选择两种类型之一。\n[参考](https://en.cppreference.com/w/cpp/types/conditional)",
            "hint": null,
            "correctAnswer": ["基于编译时布尔值选择一种类型或另一种类型"],
            "options": [
              "条件语句",
              "基于编译时布尔值选择一种类型或另一种类型",
              "条件运算符",
              "条件检查器"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3acd17a6d2d529bd3b067a28",
            "question": "`std::is_same`用于什么？",
            "answer": "在编译时检查两种类型是否相同",
            "explanation": "**解释：**\n`std::is_same`是类型特征，在编译时检查两种类型是否相同。\n[参考](https://en.cppreference.com/w/cpp/types/is_same)",
            "hint": null,
            "correctAnswer": ["在编译时检查两种类型是否相同"],
            "options": ["检查值是否相同", "在编译时检查两种类型是否相同", "比较对象", "检查相同性"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3b60d444f518174ba48e0c91",
            "question": "这段代码的输出是什么？\n```cpp\n#include <iostream>\nint main() {\n    int x = 10;\n    int* p = &x;\n    int** pp = &p;\n    std::cout << **pp;\n    return 0;\n}\n```",
            "answer": "10",
            "explanation": "**解释：**\npp是指向指针的指针。\\*\\*pp解引用两次以获得x的值，即10。\n[参考](https://en.cppreference.com/w/cpp/language/pointer)",
            "hint": null,
            "correctAnswer": ["10"],
            "options": ["10", "x的地址", "p的地址", "编译错误"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d957fe7d15091a9e9a256747",
            "question": "`std::remove_if`用于什么？",
            "answer": "从范围中删除满足谓词的元素",
            "explanation": "**解释：**\n`std::remove_if`从范围中删除满足给定谓词的元素，与erase一起使用以实际删除。\n[参考](https://en.cppreference.com/w/cpp/algorithm/remove)",
            "hint": null,
            "correctAnswer": ["从范围中删除满足谓词的元素"],
            "options": ["删除if语句", "从范围中删除满足谓词的元素", "有条件地删除文件", "删除条件"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "50b25fd2ab7b6b05c6ba1ea6",
            "question": "`std::transform`用于什么？",
            "answer": "将函数应用于范围并将结果存储在另一个范围中",
            "explanation": "**解释：**\n`std::transform`将给定函数应用于元素范围，并将结果存储在另一个范围中。\n[参考](https://en.cppreference.com/w/cpp/algorithm/transform)",
            "hint": null,
            "correctAnswer": ["将函数应用于范围并将结果存储在另一个范围中"],
            "options": [
              "转换代码",
              "将函数应用于范围并将结果存储在另一个范围中",
              "转换类型",
              "执行转换"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "37a4c4bf4772aa9f1f25e7ae",
            "question": "`std::accumulate`用于什么？",
            "answer": "计算范围元素的和或折叠",
            "explanation": "**解释：**\n`std::accumulate`计算元素范围的和，或应用二元操作来折叠范围。\n[参考](https://en.cppreference.com/w/cpp/algorithm/accumulate)",
            "hint": null,
            "correctAnswer": ["计算范围元素的和或折叠"],
            "options": ["累积错误", "计算范围元素的和或折叠", "累积数据", "添加数字"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e6e586249a471479f064e54d",
            "question": "这段代码的输出是什么？\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    int y = 10;\n    int z = x > y ? x : y;\n    std::cout << z;\n    return 0;\n}\n```",
            "answer": "10",
            "explanation": "**解释：**\n三元运算符检查x > y。由于为false，z被赋值为y，即10。\n[参考](https://en.cppreference.com/w/cpp/language/operator_other)",
            "hint": null,
            "correctAnswer": ["10"],
            "options": ["5", "10", "1", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "65728301dd6ec20a7bdf2803",
            "question": "`std::copy`用于什么？",
            "answer": "将元素从一个范围复制到另一个范围",
            "explanation": "**解释：**\n`std::copy`将元素从源范围复制到目标范围。\n[参考](https://en.cppreference.com/w/cpp/algorithm/copy)",
            "hint": null,
            "correctAnswer": ["将元素从一个范围复制到另一个范围"],
            "options": ["复制文件", "将元素从一个范围复制到另一个范围", "复制对象", "复制内存"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d15a84701b193173030033ba",
            "question": "`std::find`用于什么？",
            "answer": "在范围中查找值的第一次出现",
            "explanation": "**解释：**\n`std::find`在范围中搜索值的第一次出现，并返回指向它的迭代器。\n[参考](https://en.cppreference.com/w/cpp/algorithm/find)",
            "hint": null,
            "correctAnswer": ["在范围中查找值的第一次出现"],
            "options": ["查找文件", "在范围中查找值的第一次出现", "搜索模式", "定位对象"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d8ce00a30141002e7849024a",
            "question": "`std::sort`基于什么？",
            "answer": "内省排序（快速排序、堆排序和插入排序的混合）",
            "explanation": "**解释：**\n`std::sort`通常使用内省排序，它结合了快速排序、堆排序和插入排序以获得最佳性能。\n[参考](https://en.cppreference.com/w/cpp/algorithm/sort)",
            "hint": null,
            "correctAnswer": ["内省排序（快速排序、堆排序和插入排序的混合）"],
            "options": [
              "冒泡排序",
              "内省排序（快速排序、堆排序和插入排序的混合）",
              "仅归并排序",
              "选择排序"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5a00c6d0a755afd1b5dd8ff1",
            "question": "这段代码的输出是什么？\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\nint main() {\n    std::vector<int> v = {5, 2, 8, 1, 9};\n    std::sort(v.begin(), v.end());\n    std::cout << v[2];\n    return 0;\n}\n```",
            "answer": "5",
            "explanation": "**解释：**\n排序后，向量变为{1, 2, 5, 8, 9}。v[2]是第三个元素，即5。\n[参考](https://en.cppreference.com/w/cpp/algorithm/sort)",
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["8", "2", "5", "1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-ch",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          }
        ]
      },
      {
        "id": "72f5aa2d090f4b90bc8be471-de",
        "language": "de",
        "title": "C++",
        "description": "Seeded from c++/c++-quiz-de.md",
        "questions": [
          {
            "id": "36efe0a1409dc2c1cafb8d95",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\nvector<int> v(22);\nbool b = (v[6]);\nprintf(\"%d\", !b);\n```",
            "answer": "1",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["False", "0", "1", "Dieser Code hat einen Fehler."],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b19b9e9f0e729ffae4c4f558",
            "question": "Welcher der folgenden Gründe spricht dafür, dass die Verwendung dieser Zeile als schlechte Praxis gilt? (_Alternative_: Warum gilt die Verwendung dieser Zeile als schlechte Praxis?)\n```cpp\nusing namespace std;\n```",
            "answer": "Wenn der Code eine Funktion verwendet, die in zwei verschiedenen Bibliotheken mit demselben Prototyp, aber möglicherweise unterschiedlichen Implementierungen definiert ist, wird es einen Kompilierfehler aufgrund von Mehrdeutigkeit geben.",
            "explanation": "[Referenz](https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/)",
            "hint": null,
            "correctAnswer": [
              "Wenn der Code eine Funktion verwendet, die in zwei verschiedenen Bibliotheken mit demselben Prototyp, aber möglicherweise unterschiedlichen Implementierungen definiert ist, wird es einen Kompilierfehler aufgrund von Mehrdeutigkeit geben."
            ],
            "options": [
              "Der kompilierte Code ist immer größer wegen all der importierten Symbole.",
              "Wenn der Code eine Funktion verwendet, die in zwei verschiedenen Bibliotheken mit demselben Prototyp, aber möglicherweise unterschiedlichen Implementierungen definiert ist, wird es einen Kompilierfehler aufgrund von Mehrdeutigkeit geben.",
              "Es werden automatisch alle Header-Dateien der Standardbibliothek eingebunden (cstdint, cstdlib, cstdio, iostream, etc.).",
              "Es veranlasst den Compiler, die ausschließliche Einbindung von Header-Dateien der Standardbibliothek zu erzwingen und generiert einen Kompilierfehler, wenn eine andere Header-Datei eingebunden wird."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0fa321eb93f846d9d1f592fa",
            "question": "Welche kleinste Größe kann eine Variable des Typs child_t im Speicher einnehmen?\n```cpp\ntypedef struct{\n    unsigned int  age    : 4;\n    unsigned char gender : 1;\n    unsigned int  size   : 2;\n}child_t;\n```",
            "answer": "1 Byte",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": ["1 Byte"],
            "options": ["7 Bits", "25 Bytes", "1 Bit", "1 Byte"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3e7c8d0e438c25919f0a4a6d",
            "question": "Was sind die Vektoren v1 und v2 nach Ausführung des Codes?\n```cpp\nstd::vector<int> v1{1,2,3},v2;\nv2=v1;\nv1.push_back(4);\nv2.push_back(5);\n```",
            "answer": "v1:{1,2,3,4}; v2:{1,2,3,5};",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["v1:{1,2,3,4}; v2:{1,2,3,5};"],
            "options": [
              "Fehler",
              "v1:{1,2,3,4}; v2:{5};",
              "v1:{1,2,3,4,5}; v2:{1,2,3,4,5};",
              "v1:{1,2,3,4}; v2:{1,2,3,5};"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "60afdac3ff8393f30d4b898b",
            "question": "Welche der folgenden Aussagen über den Unterschied zwischen Zeigern und Iteratoren ist richtig?",
            "answer": "Das Inkrementieren eines Iterators bedeutet immer den Zugriff auf das nächste Element im Container (falls vorhanden), unabhängig vom Container. Das Inkrementieren eines Zeigers bedeutet, auf das nächste Element im Speicher zu zeigen, nicht immer auf das nächste Element.",
            "explanation": "[Referenz](https://stackoverflow.com/a/31128162)",
            "hint": null,
            "correctAnswer": [
              "Das Inkrementieren eines Iterators bedeutet immer den Zugriff auf das nächste Element im Container (falls vorhanden), unabhängig vom Container. Das Inkrementieren eines Zeigers bedeutet, auf das nächste Element im Speicher zu zeigen, nicht immer auf das nächste Element."
            ],
            "options": [
              "Während Zeiger Variablen sind, die Speicheradressen enthalten, sind Iteratoren generische Funktionen zum Durchlaufen von Containern. Diese Funktion ermöglicht es dem Programmierer, Lese- und Schreibcode zu implementieren, während der Container durchlaufen wird.",
              "Das Inkrementieren eines Iterators bedeutet immer den Zugriff auf das nächste Element im Container (falls vorhanden), unabhängig vom Container. Das Inkrementieren eines Zeigers bedeutet, auf das nächste Element im Speicher zu zeigen, nicht immer auf das nächste Element.",
              "Zeiger sind Variablen, die Speicheradressen enthalten, während Iteratoren vorzeichenlose Ganzzahlen sind, die sich auf Offsets in Arrays beziehen.",
              "Alle Iteratoren werden mit Zeigern implementiert, sodass alle Iteratoren Zeiger sind, aber nicht alle Zeiger Iteratoren sind."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6b855105035bcf1174792d75",
            "question": "Welchen Speicherplatz belegt u1?\n```cpp\nunion {\n    uint16_t a;\n    uint32_t b;\n    int8_t c;\n} u1;\n```",
            "answer": "4 Bytes",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/language/union)",
            "hint": null,
            "correctAnswer": ["4 Bytes"],
            "options": ["4 Bytes", "7 Bytes", "8 Bytes", "2 Bytes"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "323e3bcec85b47e1458a7895",
            "question": "Welcher der folgenden Operatoren kann überladen werden?",
            "answer": "`new`",
            "explanation": "[Referenz](https://www.tutorialspoint.com/operators-that-cannot-be-overloaded-in-cplusplus)",
            "hint": null,
            "correctAnswer": ["`new`"],
            "options": ["`?:`", "`new`", "`::`", "`.`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5d0f6cd91cf6586cdfc18e15",
            "question": "Welcher der folgenden zeigt den Inhalt der Vektoren, auf die v1 und v2 nach Ausführung dieses Codes zeigen?\n```cpp\nstd:: vector<int> *v1 = new std::vector<int>({1,2,3});\nstd:: vector<int> *v2;\nv2=v1;\nv1->push_back(4);\nv2->push_back(5);\n```",
            "answer": "`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`",
            "explanation": "v1 und v2 zeigen auf denselben Vektor.",
            "hint": null,
            "correctAnswer": ["`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`"],
            "options": [
              "`*v1:{1,2,3,4}; *v2:{5};`",
              "`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`",
              "Fehler",
              "`*v1:{1,2,3,4}; *v2:{1,2,3,5};`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "013144b36ead73bcbe0c8093",
            "question": "Was ist kein Unterschied zwischen einer Klasse und einer Struktur?",
            "answer": "Template-Typparameter können mit Klassen deklariert werden, aber nicht mit dem struct-Schlüsselwort.",
            "explanation": "Templates können sowohl mit Klassen als auch mit Strukturen verwendet werden\n[Referenz](https://docs.microsoft.com/en-us/cpp/cpp/struct-cpp?view=msvc-170)\n[Referenz](https://www.fluentcpp.com/2017/06/13/the-real-difference-between-struct-class/)",
            "hint": null,
            "correctAnswer": [
              "Template-Typparameter können mit Klassen deklariert werden, aber nicht mit dem struct-Schlüsselwort."
            ],
            "options": [
              "Da Strukturen Teil der Programmiersprache C sind, gibt es eine gewisse Komplexität zwischen C- und C++-Strukturen. Dies ist bei Klassen nicht der Fall.",
              "Klassen können Mitgliedsfunktionen haben; Strukturen sind privat.",
              "Der Standard-Zugriffsspezifizierer für Mitglieder einer Struktur ist public, während er für Mitglieder einer Klasse private ist.",
              "Template-Typparameter können mit Klassen deklariert werden, aber nicht mit dem struct-Schlüsselwort."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "66dc57b4e781ead51bca8fac",
            "question": "Angenommen, Sie müssen eine Datenstruktur mit Berechtigung zum Zugriff auf eine Ressource basierend auf den Wochentagen führen, aber Sie können keine bool-Variable für jeden Tag verwenden. Sie müssen ein Bit pro Wochentag verwenden. Welche der folgenden ist eine korrekte Implementierung einer Struktur mit Bitfeldern für diese Anwendung?",
            "answer": "A",
            "explanation": "```cpp\ntypedef struct {\nint sunday:1;\nint monday:1;\n// weitere Tage\nint friday:1;\nint saturday:1;\n} weekdays;\n```\n```cpp\ntypedef char[7]: weekdays;\n```\n```cpp\ntypedef struct {\nbit sunday:1;\nbit monday:1;\n// weitere Tage\nbit friday:1;\nbit saturday:1;\n} weekdays;\n```\n```cpp\ntypedef struct {\nbit sunday;\nbit monday;\n// weitere Tage\nbit friday;\nbit saturday;\n} weekdays;\n```\n[Referenz](https://en.cppreference.com/w/cpp/language/bit_field) _HINWEIS_: Die korrekte Syntax ist, dass jede Variable eine Größe von 1 Bit hat. `bit` ist kein Typ in C++.",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c0ddd8f2af5fd8b8c5fe9bf2",
            "question": "Was ist ein lvalue?",
            "answer": "Es ist ein Ortswert (location value), d.h. eine Speicheradresse, die für die Zuweisung an einen Zeiger oder eine Referenz geeignet ist.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Es ist ein Ortswert (location value), d.h. eine Speicheradresse, die für die Zuweisung an einen Zeiger oder eine Referenz geeignet ist."
            ],
            "options": [
              "Es ist ein konstanter Ausdruck, d.h. ein Ausdruck, der aus Konstanten und Operationen besteht.",
              "Es ist ein Ausdruck, der ein Objekt mit einer Adresse darstellt.",
              "Es ist ein Ausdruck, der für den linken Operanden in einer binären Operation geeignet ist.",
              "Es ist ein Ortswert (location value), d.h. eine Speicheradresse, die für die Zuweisung an einen Zeiger oder eine Referenz geeignet ist."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0ecee0d758712ee939f4b045",
            "question": "Was macht der auto-Typ-Spezifizierer in dieser Codezeile (seit C++11)?\n```cpp\nauto x = 4000.22;\n```",
            "answer": "Er gibt an, dass der Typ von x aus dem Initialisierer abgeleitet wird - in diesem Fall double.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Er gibt an, dass der Typ von x aus dem Initialisierer abgeleitet wird - in diesem Fall double."
            ],
            "options": [
              "Er gibt an, dass der Typ von x aus dem Initialisierer abgeleitet wird - in diesem Fall double.",
              "Er gibt an, dass der Typ von x automatisch ist, was bedeutet, dass ihm während des Programms verschiedene Datentypen zugewiesen werden können.",
              "Er gibt an, dass x eine Variable mit automatischer Speicherdauer ist.",
              "Er gibt an, dass mehr Speicher für x zugewiesen wird, falls mehr Platz benötigt wird, um Datenverlust durch Überlauf zu vermeiden."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cbc76ce165d7713117e780be",
            "question": "Was ist ein Klassen-Template?",
            "answer": "Eine Klasse, die mit dem generischen Programmierparadigma geschrieben wurde und Verhalten in Bezug auf Typparameter anstelle spezifischer Typen spezifiziert.",
            "explanation": "[Referenz](https://www.mygreatlearning.com/blog/templates-in-cpp/)",
            "hint": null,
            "correctAnswer": [
              "Eine Klasse, die mit dem generischen Programmierparadigma geschrieben wurde und Verhalten in Bezug auf Typparameter anstelle spezifischer Typen spezifiziert."
            ],
            "options": [
              "Eine Klasse, die mit dem generischen Programmierparadigma geschrieben wurde und Verhalten in Bezug auf Typparameter anstelle spezifischer Typen spezifiziert.",
              "Eine leere Oberklasse, die für Vererbung und Polymorphismus vorgesehen ist.",
              "Eine Klasse, die nur aus einer Mitgliedsvariablen besteht, ohne Konstruktor, Destruktor oder Mitgliedsfunktionen.",
              "Quellcode-Skelett für eine Klasse, bei dem der Programmierer bestimmte Teile ausfüllen muss, um die verwendeten Datentypen und Algorithmen zu definieren."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "51efc09a275ac408564d8754",
            "question": "Was ist die ternäre Operator-Entsprechung zu diesem Code-Snippet?\n```cpp\nif(x)\n    y=a;\nelse\n    y=b;\n```",
            "answer": "`y=x?a:b;`",
            "explanation": "[Referenz](https://www.w3schools.com/cpp/cpp_conditions_shorthand.asp)",
            "hint": null,
            "correctAnswer": ["`y=x?a:b;`"],
            "options": ["`y=a?b:x;`", "`y=if(x?a:b);`", "`y=(x&a)?a:(x&b)?b:0;`", "`y=x?a:b;`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "47828145cf6c16e7c6e5d1e5",
            "question": "Was ist die Ausgabe des unten angegebenen Codes?\n```cpp\n#include <iostream>\nint main(){\n    int x=10, y=20;\n    std::cout << \"x = \" << x++ << \" and y = \" << --y << std::endl;\n    std::cout << \"x = \" << x-- << \" and y = \" << ++y << std::endl;\n    return(0);\n}\n```",
            "answer": "`x = 10 and y = 19`",
            "explanation": "`x = 11 and y = 19`\n`x = 10 and y = 20`\n`x = 11 and y = 20`\n`x = 10 and y = 19`",
            "hint": null,
            "correctAnswer": ["`x = 10 and y = 19`"],
            "options": [
              "`x = 10 and y = 20`",
              "`x = 11 and y = 19`",
              "`x = 10 and y = 19`",
              "`x = 11 and y = 20`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "93a8beb740fe61f89deea358",
            "question": "Was bedeuten die zwei Teile, die zwischen Klammern in einer bereichsbasierten For-Schleife angegeben sind, getrennt durch einen Doppelpunkt?",
            "answer": "Der erste ist eine Variablendeklaration, die ein Element in einer Sequenz enthält. Der zweite ist die zu durchlaufende Sequenz.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Der erste ist eine Variablendeklaration, die ein Element in einer Sequenz enthält. Der zweite ist die zu durchlaufende Sequenz."
            ],
            "options": [
              "Der erste ist eine Variablendeklaration, die ein Element in einer Sequenz enthält. Der zweite ist die zu durchlaufende Sequenz.",
              "Der erste ist ein Iterator, und der zweite ist der Inkrementwert, der zum Iterator hinzugefügt werden soll.",
              "Der erste ist die iterierende Variable. Der zweite ist ein `std::pair`, das den Bereich (Start und Ende) angibt, in dem die Variable iteriert.",
              "Der erste ist ein Container-Objekt. Der zweite ist ein `std::pair`, das den Bereich (Start und Ende) angibt, in dem auf die Elemente innerhalb der Schleife zugegriffen wird."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e559bfa6ff2e8c7c4d4780a0",
            "question": "Was ist die Ausgabe des unten angegebenen Codes?\n```cpp\nint8_t a=200;\nuint8_t b=100;\nif(a>b)\n    std::cout<<\"greater\";\nelse\n    std::cout<<\"less\";\n```",
            "answer": "less",
            "explanation": "Hinweis: Eine Variante der Frage unten.",
            "hint": null,
            "correctAnswer": ["less"],
            "options": [
              "Es gibt keine Ausgabe, weil es eine Ausnahme beim Vergleich eines int8_t mit einem uint8_t gibt.",
              "greater",
              "less",
              "Es gibt keine Ausgabe, weil es einen Compilerfehler gibt."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b604cf50e48748f63122c1c3",
            "question": "Was ist die Ausgabe dieses Codeblocks?\n```cpp\nint8_t a=200;\nuint8_t b=100;\nstd::cout<<\"a=\"<<(int)a;\nstd::cout<<\", b=\"<<(int)b;\n```",
            "answer": "a=-56, b=100",
            "explanation": "Hinweis: Implizite Konvertierung von 'int' zu 'int8_t' (auch bekannt als 'signed char') ändert den Wert von 200 zu -56",
            "hint": null,
            "correctAnswer": ["a=-56, b=100"],
            "options": ["a=-56, b=100", "a=-55, b=100", "a=200, b=-156", "a=200, b=100"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4b023cc614f6594ef0537da8",
            "question": "Was ist die Ausgabe nach Ausführung dieses Code-Snippets?\n```cpp\nint x=5, y=2;\nif(x & y) {\n    /*_Teil A_*/\n}\nelse {\n    /*_Teil B_*/\n}\n```",
            "answer": "Teil B wird ausgeführt, weil (x & y) 0 oder falsch ergibt.",
            "explanation": "[Referenz](https://stackoverflow.com/questions/63867765/dont-understand-why-if-5-2-is-false)",
            "hint": null,
            "correctAnswer": ["Teil B wird ausgeführt, weil (x & y) 0 oder falsch ergibt."],
            "options": [
              "Teil A wird ausgeführt, weil x==5 (wahr) und y==2 (wahr), daher wertet die UND-Operation als wahr aus.",
              "Teil B wird ausgeführt, weil (x & y) 0 oder falsch ergibt.",
              "Teil A wird ausgeführt, weil (x & y) einen Wert ungleich Null oder wahr ergibt.",
              "Teil B wird ausgeführt, weil die Anweisung (x & y) ungültig und daher falsch ist."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "67ae0dab90b6e2a59b012f17",
            "question": "Was ist eine gültige Definition für die `get_length`-Funktion, die die Länge einer null-terminierten Zeichenkette zurückgibt?",
            "answer": "A",
            "explanation": "```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str[count++]);\nreturn count-1;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str!=NULL){\ncount++;\nstr++;\n}\nreturn count;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile((*str)++)\ncount++;\nreturn count;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str++)\ncount++;\nreturn count;\n}\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6de3be3ba6265b179de44fce",
            "question": "Welche STL-Klasse ist am besten geeignet, um eine Sammlung von Daten zu implementieren, die immer sortiert ist, sodass die Pop-Operation immer das größte Element erhält? Angenommen, Sie sind nur an Push- und Pop-Operationen interessiert.",
            "answer": "`std::priority_queue`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`std::priority_queue`"],
            "options": ["`std::list`", "`std::vector`", "`std::priority_queue`", "`std::map`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4daa7da4a233c890ec8bbbcc",
            "question": "Was bedeuten die drei Abschnitte, die zwischen Klammern in einer For-Schleife durch Semikolons getrennt sind?",
            "answer": "Der erste ist der Initialisierungsblock, der zweite ist die Bedingung zum Iterieren, und der dritte ist der Inkrementblock.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Der erste ist der Initialisierungsblock, der zweite ist die Bedingung zum Iterieren, und der dritte ist der Inkrementblock."
            ],
            "options": [
              "Der erste ist der Name der iterierenden Variablen, der zweite ist die Anzahl der Iterationen, und der dritte ist das gewünschte Inkrement oder Dekrement (angegeben mit einer vorzeichenbehafteten Ganzzahl).",
              "Der erste ist der Initialisierungsblock, der zweite ist die Bedingung zum Iterieren, und der dritte ist der Inkrementblock.",
              "Der erste ist die iterierende Variable, der zweite ist der Container, in dem sie operieren soll, und der dritte ist eine Abbruchbedingung zum jederzeit Abbrechen.",
              "Der erste ist der Name der iterierenden Variablen, der zweite ist der Startwert für die iterierende Variable, und der dritte ist der Stoppwert (der letzte Wert plus eins)."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0b61a5f214d330622c710166",
            "question": "Was gibt dieser Code aus?\n```cpp\nint i = 0;\nprintf(\"%d\", i++);\nprintf(\"%d\", i--);\nprintf(\"%d\", ++i);\nprintf(\"%d\", --i);\n```",
            "answer": "0,1,1,0",
            "explanation": "[Referenz](https://www.geeksforgeeks.org/pre-increment-and-post-increment-in-c/)",
            "hint": null,
            "correctAnswer": ["0,1,1,0"],
            "options": ["0,1,1,0", "0,1,0,1", "0,0,1,0", "1,0,1,0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7b25091d1788b38f2cb40abd",
            "question": "Was ist wahr über die Variable namens `ptr`?\n```cpp\nvoid *ptr;\n```",
            "answer": "Es ist ein Zeiger auf einen Wert ohne spezifischen Typ, sodass er auf jeden Typ gecastet werden kann.",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/language/pointer)",
            "hint": null,
            "correctAnswer": [
              "Es ist ein Zeiger auf einen Wert ohne spezifischen Typ, sodass er auf jeden Typ gecastet werden kann."
            ],
            "options": [
              "Es ist ein Zeiger, der mit NULL initialisiert wurde.",
              "Es ist ein Zeiger auf eine void-Funktion.",
              "Diese Deklaration verursacht einen Compilerfehler, da Zeiger einen Typ angeben müssen.",
              "Es ist ein Zeiger auf einen Wert ohne spezifischen Typ, sodass er auf jeden Typ gecastet werden kann."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "69aa1c24a392a43cccf34b8b",
            "question": "Was ist die Ausgabe des unten angegebenen Codes?\n```cpp\nint c=3; char d='A';\nstd::printf(\"c is %d and d is %c\",c,d);\n```",
            "answer": "c is 3 and d is A",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["c is 3 and d is A"],
            "options": [
              "c is d and d is c",
              "c is A and d is 3",
              "c is 3 and d is A",
              "c is c and d is d"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "622fad24bb0f5e33c8b8b385",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\nprintf(\"1/2 = %f\",(float)(1/2));\n```",
            "answer": "1/2 = 0.000000",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["1/2 = 0.000000"],
            "options": ["1/2 = 0.499999", "1/2 = 0", "1/2 = 0.000000", "1/2 = 0.5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c4b98689e6a782ea0913a955",
            "question": "Was ist der Unterschied zwischen einem öffentlichen und einem privaten Klassenmitglied?",
            "answer": "Öffentliche Mitglieder können von jeder Funktion aufgerufen werden. Private Mitglieder können nur von Mitgliedsfunktionen derselben Klasse und Freunden der Klasse aufgerufen werden.",
            "explanation": "[Referenz](https://www.geeksforgeeks.org/difference-between-public-and-private-in-c-with-example/)",
            "hint": null,
            "correctAnswer": [
              "Öffentliche Mitglieder können von jeder Funktion aufgerufen werden. Private Mitglieder können nur von Mitgliedsfunktionen derselben Klasse und Freunden der Klasse aufgerufen werden."
            ],
            "options": [
              "Öffentliche Mitglieder sind dasselbe wie globale Variablen, sodass jeder Teil des Codes auf sie zugreifen kann. Private Mitglieder sind dasselbe wie automatische Variablen, sodass nur ihre Klasse auf sie zugreifen kann.",
              "Öffentliche Mitglieder werden für jede laufende Anwendung zugänglich gemacht. Private Mitglieder werden nur für die Anwendung zugänglich gemacht, in der das Objekt instanziiert wird.",
              "Öffentliche Mitglieder werden in einer Multithread-Umgebung als gemeinsame Variablen kompiliert. Private Mitglieder werden als Thread-lokale Variablen kompiliert.",
              "Öffentliche Mitglieder können von jeder Funktion aufgerufen werden. Private Mitglieder können nur von Mitgliedsfunktionen derselben Klasse und Freunden der Klasse aufgerufen werden."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f8beabbceea2a35f4a040345",
            "question": "Was ist der Wert von `x` nach Ausführung dieses Codes?\n```cpp\nint x=10, a=-3;\nx+=a;\n```",
            "answer": "7",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["7"],
            "options": ["3", "7", "-3", "13"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "09e92906518a77ece7a9eab7",
            "question": "Welche Aussage ist wahr?",
            "answer": "C++ unterstützt Mehrfachvererbung.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C++ unterstützt Mehrfachvererbung."],
            "options": [
              "Nur Klassen können Mitgliedsvariablen und Methoden haben.",
              "C++ unterstützt Mehrfachvererbung.",
              "C++ unterstützt nur Einfachvererbung.",
              "Nur Strukturen können erben."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "754eb82724f2ed4eb96cbc82",
            "question": "Betrachten Sie einen Zeiger auf void, genannt `ptr`, der so eingestellt wurde, dass er auf eine Gleitkommavariable `g` zeigt. Welche Wahl ist eine gültige Methode, um `ptr` zu dereferenzieren, um seinen Zeigerwert einer Float-Variablen `f` später im Programm zuzuweisen?\n```cpp\nfloat g;\nvoid *ptr=&g;\n```",
            "answer": "`float f=*(float *)ptr;`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`float f=*(float *)ptr;`"],
            "options": [
              "`float f=*(float)ptr;`",
              "`float f=(float *)ptr;`",
              "`float f=(float)*ptr;`",
              "`float f=*(float *)ptr;`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0168a12842d82376dda236d1",
            "question": "Was ist der `.*`-Operator und was macht er?",
            "answer": "Er ist der Zeiger-auf-Mitglied-Operator und ermöglicht es Ihnen, auf ein Mitglied eines Objekts über einen Zeiger auf dieses spezifische Klassenmitglied zuzugreifen.",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/language/operator_member_access)",
            "hint": null,
            "correctAnswer": [
              "Er ist der Zeiger-auf-Mitglied-Operator und ermöglicht es Ihnen, auf ein Mitglied eines Objekts über einen Zeiger auf dieses spezifische Klassenmitglied zuzugreifen."
            ],
            "options": [
              "Er ist derselbe wie der Klassenmitgliedszugriffsoperator oder Pfeiloperator `(->)`, der es Ihnen ermöglicht, auf ein Mitglied eines Objekts über einen Zeiger auf das Objekt zuzugreifen.",
              "Er ist der Zeiger-auf-Mitglied-Operator und ermöglicht es Ihnen, auf ein Mitglied eines Objekts über einen Zeiger auf dieses spezifische Klassenmitglied zuzugreifen.",
              "Er ist der Mitgliedszugriff mit Adressoperator, der die Adresse eines Klassen- oder Strukturmitglieds zurückgibt.",
              "Er ist eine Kombination des Mitgliedszugriffsoperators `(.)` und des Dereferenzierungsoperators `(*)`, sodass er es Ihnen ermöglicht, auf das Objekt zuzugreifen, auf das ein Mitgliedszeiger zeigt."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "45fb5a318e4eb8b8494fde6c",
            "question": "Für diese Deklarationen, welche Wahl zeigt vier gleichwertige Möglichkeiten, das Zeichen \"y\" im String einer char-Variablen c zuzuweisen?\n```cpp\nchar buff[50] = \"strings as arrays of characters are fun!\"\nchar *str = buff+11;\nchar c;\n```",
            "answer": "C",
            "explanation": "```cpp\nc = buff[16];\nc = str[5];\nc = *(buff+16);\nc = *(str+5);\n```\n```cpp\nc = *(buff[15]);\nc = *(str[4]);\nc = buff+15;\nc = str+4;\n```\n```cpp\nc = buff[15];\nc = str[4];\nc = *(buff+15);\nc = *(str+4);\n```\n```cpp\nc = *(buff[16]);\nc = *(str[5]);\nc = buff+16;\nc = str+5;\n```",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e47c3416b8c163fd94f635a6",
            "question": "Welche Wahl ist die korrekte Deklaration für die Klasse namens Dog, abgeleitet von der Animal-Klasse?\n```cpp\nclass Animal{\n    //....\n}\n```",
            "answer": "B",
            "explanation": "```cpp\nclass Dog :: public Animal {\n//....\n};\n```\n```cpp\nclass Dog : public Animal {\n//....\n};\n```\n```cpp\npublic class Animal :: Dog {\n//....\n};\n```\n```cpp\npublic class Dog extends Animal {\n//....\n};\n```",
            "hint": null,
            "correctAnswer": ["B"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "dc1395f1c1198f88ad81ca4b",
            "question": "Was ist die Ausgabe dieses unten angegebenen Codes?\n```cpp\n#include <cstdio>\nusing namespace std;\nint main(){\n    char c = 255;\n    if(c>10)\n        printf(\"c = %i, which is greater than 10\", c);\n    else\n        printf(\"c = %i, which is less than 10\", c);\n    return 0;\n}\n```",
            "answer": "c = -1, which is less than 10",
            "explanation": "Technisch gesehen ist es implementierungsabhängig, ob ein `char` `signed` oder `unsigned` ist;\nim letzteren Fall wäre die zweite Antwort korrekt.\n[Referenz](https://en.cppreference.com/w/cpp/language/types)",
            "hint": null,
            "correctAnswer": ["c = -1, which is less than 10"],
            "options": [
              "c = -1, which is less than 10",
              "c = 255, which is greater than 10",
              "c = -1, which is greater than 10",
              "c = 255, which is less than 10"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ad7fd21bff2b38e81da720e8",
            "question": "Wie kann C++-Code eine C-Funktion aufrufen?",
            "answer": "durch Verwendung von extern \"C\"",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["durch Verwendung von extern \"C\""],
            "options": [
              "durch einfachen Aufruf des C-Codes",
              "Es gibt keine Möglichkeit für C++, eine C-Funktion aufzurufen",
              "durch Verwendung von extern \"C\"",
              "durch Importieren des Quell-C-Codes"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a60f82b381479352b4547f30",
            "question": "Welche Wahl ist _keine_ gültige Typdefinition einer Struktur, die x- und y-Koordinaten als Ganzzahlen enthält und genau wie gezeigt für die Variable namens `center` verwendet werden kann?\n```cpp\ncoord center;\ncenter.x = 5;\ncenter.y = 3;\n```",
            "answer": "A",
            "explanation": "```cpp\ntypedef struct coord {\nint x;\nint y;\n};\n```\n```cpp\ntypedef struct coord {\nint x;\nint y;\n} coord;\n```\n```cpp\ntypedef struct {\nint x;\nint y;\n} coord;\n```\n```cpp\nstruct coord {\nint x;\nint y;\n};\ntypedef struct coord coord;\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f8fc61c6dc3b3704f1924f51",
            "question": "Welche Wahl erzeugt _nicht_ dieselbe Ausgabe wie dieses Code-Snippet? Angenommen, die Variable `i` wird nirgendwo sonst im Code verwendet.\n```cpp\nfor (i=1;i<10;i++){\n    cout<<i<<endl;\n}\n```",
            "answer": "A",
            "explanation": "```cpp\ni=1;\nwhile(i<10){\ncout<<++i<<endl;\n}\n```\n```cpp\nfor (int i:{1,2,3,4,5,6,7,8,9}) {\ncout<<i<<endl;\n}\n```\n```cpp\ni = 1;\ndo {\ncout<<i++<<endl;\n} while(i<10);\n```\n```cpp\ni = 1;\nloop:\ncout<<i++<<endl;\nif(i<10) goto loop;\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b0a2354b570fe51e9e968d8e",
            "question": "Was macht dieser Teil einer main.cpp-Datei?\n```cpp\n#include \"library.h\"\n```",
            "answer": "Es verursacht den Ersatz der `#include`-Direktive durch den gesamten Inhalt der Quelldatei library.h. Dies ähnelt der Kopieren-Einfügen-Operation von library.h in main.cpp.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Es verursacht den Ersatz der `#include`-Direktive durch den gesamten Inhalt der Quelldatei library.h. Dies ähnelt der Kopieren-Einfügen-Operation von library.h in main.cpp."
            ],
            "options": [
              "Es veranlasst die Toolchain, alle Inhalte von library.h zu kompilieren, sodass der ausführbare Code bei Bedarf für die endgültige Anwendung verfügbar ist.",
              "Es wählt library.h für die Deklarationen und Definitionen aller Daten und Funktionen aus, die im Rest der Quelldatei main.cpp verwendet werden, und ersetzt schließlich die `#include`-Direktive durch diese Deklarationen und Definitionen.",
              "Es informiert den Linker, dass einige Funktionen oder Daten, die in der Quelldatei main.cpp verwendet werden, in library.h enthalten sind, sodass sie zur Laufzeit aufgerufen werden können. Dies wird auch als dynamisches Linken bezeichnet.",
              "Es verursacht den Ersatz der `#include`-Direktive durch den gesamten Inhalt der Quelldatei library.h. Dies ähnelt der Kopieren-Einfügen-Operation von library.h in main.cpp."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "033c6460be879680abf072ca",
            "question": "Betrachten Sie diese Funktionsdeklaration von `is_even`, die eine Ganzzahl entgegennimmt und true zurückgibt, wenn das Argument eine gerade Zahl ist, und false sonst. Welche Deklarationen sind korrekt für überladene Versionen dieser Funktion zur Unterstützung von Gleitkommazahlen und Zeichenkettendarstellungen von Zahlen?\n```cpp\nbool is_even(int);\n```",
            "answer": "A",
            "explanation": "```cpp\nbool is_even(float f);\nbool is_even(char *str);\n```\n```cpp\nbool is_even(float f);\nbool is_even(char str);\n```\n```cpp\nbool is_even_float(float f);\nbool is_even_str(char *str);\n```\n```cpp\nfloat is_even(float f);\nchar *is_even(char *str);\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7925746326f0f2d78964e293",
            "question": "Welche Wahl ist ein Include-Guard für die Header-Datei `my_library.h`?",
            "answer": "B",
            "explanation": "```cpp\n#ifdef MY_LIBRARY_H\n#define MY_LIBRARY_H\n// my_library.h Inhalt\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#ifndef MY_LIBRARY_H\n#define MY_LIBRARY_H\n// my_library.h Inhalt\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#ifdef MY_LIBRARY_H\n#undef MY_LIBRARY_H\n// my_library.h Inhalt\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#define MY_LIBRARY_H\n#include MY_LIBRARY_H\n// my_library.h Inhalt\n#undef MY_LIBRARY_H\n```",
            "hint": null,
            "correctAnswer": ["B"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "15bc5ac84c4e20d2f5c71d12",
            "question": "Was ist falsch an dieser Definition bei Verwendung eines Pre-C++11-Compilers?\n```cpp\nstd::vector<std::vector<int>> thematrix;\n```",
            "answer": "`>>` wird als Rechtsverschiebungsoperator geparst und führt somit zu einem Compilerfehler.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "`>>` wird als Rechtsverschiebungsoperator geparst und führt somit zu einem Compilerfehler."
            ],
            "options": [
              "Es ist nichts falsch daran.",
              "Ein `std::vector` kann keine weiteren `std::vector`-Container als seine Elemente enthalten.",
              "Die korrekte Syntax sollte sein: `std::vector[std::vector[int]] thematrix;`",
              "`>>` wird als Rechtsverschiebungsoperator geparst und führt somit zu einem Compilerfehler."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "12274d4d735244fca0adc15a",
            "question": "Was ist die folgende Anweisung gleichwertig?",
            "answer": null,
            "explanation": null,
            "hint": null,
            "correctAnswer": [],
            "options": [],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "679c8ce5d678252c53876fe9",
            "question": "b. Was ist die Anweisung gleichwertig?\n```cpp\nsprite->x\n```",
            "answer": "`(*sprite).x`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`(*sprite).x`"],
            "options": ["`sprite.x`", "`sprite.*x`", "`(*sprite).x`", "`*sprite.x`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6eb5463818883727f580f7ae",
            "question": "Betrachten Sie eine Klasse namens `complexNumber`. Welcher Code führt zu einem gleichwertigen Objekt?\n```cpp\ncomplexNumber(float real, float im)\n: real_part(real),\n im_part(im){}\n```",
            "answer": "C",
            "explanation": "```cpp\ncomplexNumber(float real, float im) {\nthis->real = real_part;\nthis->im = im_part;\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part(real);\nthis->im_part(im);\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part = real;\nthis->im_part = im;\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part = &real;\nthis->im_part = &im;\n}\n```",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "877c8d0985cf0ff1f37ae051",
            "question": "Was ist das Ergebnis der Ausführung dieses Code-Snippets?\n```cpp\nbool x=true, y=false;\nif (~x || y) {\n    /*Teil A*/\n} else {\n    /*Teil B*/\n}\n```",
            "answer": "Teil A wird ausgeführt, weil `~x` nicht null ist, was wahr bedeutet.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Teil A wird ausgeführt, weil `~x` nicht null ist, was wahr bedeutet."
            ],
            "options": [
              "Teil A wird ausgeführt, weil der Ausdruck `(~x || y)` immer wahr ist, wenn `y==false`.",
              "Teil B wird ausgeführt, weil die Anweisung `(~x || y)` ungültig und daher falsch ist.",
              "Teil A wird ausgeführt, weil `~x` nicht null ist, was wahr bedeutet.",
              "Teil B wird ausgeführt, weil `~x` falsch ist und `y` falsch ist, daher wertet die OR-Operation als falsch aus."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c7b3d9550a3787fba01cdac8",
            "question": "Was wäre die Ausgabe dieses Codes?\n```cpp\nint32_t nums[3]={2,4,3};\nstd::cout << ( nums[0] << nums[1] << nums[2] );\n```",
            "answer": "256",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["256"],
            "options": [
              "Die Ausgabe sind die Adressen von `nums[0]`, `nums[1]` und `nums[2]`, in dieser Reihenfolge, ohne Leerzeichen.",
              "256",
              "`0`",
              "`243`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "dfd3089527beed161404a50e",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\nfloat values[5]={0.54f, 2.71828f, 3.14159f, 5.499999f, 10.0f};\nfor(auto f:values)\n    printf(\"%i \",(int)(f+0.5f));\n```",
            "answer": "`1 3 3 5 10`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`1 3 3 5 10`"],
            "options": [
              "`0.54 2.71828 3.14159 5.499999 10.0`",
              "`1 3 4 6 11`",
              "`0 2 3 5 10`",
              "`1 3 3 5 10`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "70fb91ecb10ed000b7a5a6af",
            "question": "Welche der folgenden STL-Klassen ist am besten geeignet, um ein Telefonbuch zu implementieren? Angenommen, jeder Eintrag enthält einen Namen und eine Telefonnummer ohne Duplikate, und Sie möchten eine Suche nach Namen durchführen.",
            "answer": "`std::map`",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/container/map)",
            "hint": null,
            "correctAnswer": ["`std::map`"],
            "options": ["`std::priority_queue`", "`std::list`", "`std::vector`", "`std::map`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ec8e54fa2d58dc5516b25155",
            "question": "Was macht dieses Programm?\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\nint main(){\n    ifstream file1(\"text1.txt\", ios::binary);\n    ofstream file2(\"text2.txt\", ios::binary);\n    file2 << file1.rdbuf();\n}\n```",
            "answer": "Es kopiert den Inhalt von text1.txt in text2.txt - d.h., es erstellt eine Kopie von text1.txt mit dem Namen text2.txt.",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/header/fstream)",
            "hint": null,
            "correctAnswer": [
              "Es kopiert den Inhalt von text1.txt in text2.txt - d.h., es erstellt eine Kopie von text1.txt mit dem Namen text2.txt."
            ],
            "options": [
              "Es benennt text1.txt in text2.txt um.",
              "Es erstellt ein Verzeichnis namens text2.txt und verschiebt text1.txt dorthin.",
              "Es kopiert den Inhalt von text1.txt in text2.txt - d.h., es erstellt eine Kopie von text1.txt mit dem Namen text2.txt.",
              "Es hängt den Inhalt von text1.txt an text2.txt an - d.h., ersetzt den Inhalt von text2.txt durch die Verkettung von text2.txt und text1.txt."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7ed4504befb02acf541b2fd3",
            "question": "Was ist _keine_ Konsequenz der Deklaration der Mitgliedsvariablen `count` von my_class als static? / Alt.: Welche Aussage ist wahr bei der Deklaration der Mitgliedsvariablen `count` als static?\n```cpp\nclass my_class {\n    public: static int count;\n}\n```",
            "answer": "Die Variable kann von keinem Teil des Codes in derselben Anwendung oder Thread modifiziert werden. Andere Threads können sie jedoch modifizieren.",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/language/static)",
            "hint": null,
            "correctAnswer": [
              "Die Variable kann von keinem Teil des Codes in derselben Anwendung oder Thread modifiziert werden. Andere Threads können sie jedoch modifizieren."
            ],
            "options": [
              "Die Variable kann von keinem Teil des Codes in derselben Anwendung oder Thread modifiziert werden. Andere Threads können sie jedoch modifizieren.",
              "Die Variable existiert auch dann, wenn keine Objekte der Klasse definiert wurden, sodass sie an jedem Punkt im Quellcode modifiziert werden kann.",
              "Die Variable wird nur einmal zugewiesen, unabhängig davon, wie viele Objekte instanziiert werden, da sie an die Klasse selbst gebunden ist, nicht an ihre Instanzen.",
              "Alle Objekte, die versuchen, auf ihre count-Mitgliedsvariable zuzugreifen, verweisen tatsächlich auf die einzige klassengebundene statische count-Variable."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e0ccf1ee080bf55bb6051a90",
            "question": "Was ist der angenommene Typ einer Konstante, die im Quellcode als `0.44` dargestellt wird?",
            "answer": "double",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["double"],
            "options": ["double", "long float", "long double", "float"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6a50e38c8a6c7c4ff3853620",
            "question": "Was ist ein geeigneter Weg, `my_object` wie unten gezeigt zu entfernen?\n```cpp\nmy_class *my_object = new my_class();\n```",
            "answer": "`delete(my_object);`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`delete(my_object);`"],
            "options": [
              "`delete(my_object);`",
              "`free(my_object);`",
              "Der Garbage Collector wird das Objekt schließlich zerstören.",
              "Das Verlassen des Gültigkeitsbereichs wird das Objekt zerstören."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3ed57c12b61975aa365f92c5",
            "question": "Was ist der korrekte Weg, die `count`-Mitgliedsfunktion für den Objektzeiger namens `grades` aufzurufen?\n```cpp\nclass my_array{\n    public:\n        int count();\n};  // ... weitere Mitglieder oben\nint main(){\n    my_array *grades = new my_array();\n};  // ... weiterer Code oben\n```",
            "answer": "`grades->count();`",
            "explanation": "[Referenz](https://en.cppreference.com/w/c/language/operator_member_access)",
            "hint": null,
            "correctAnswer": ["`grades->count();`"],
            "options": [
              "`grades.count();`",
              "`my_array->count();`",
              "`grades->count();`",
              "`my_array.count();`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "91f3df639c196d1dbb7da528",
            "question": "Was wäre die Ausgabe dieses Codes?\n```cpp\nint i0=4, i1=6, i2=8;\nint& nums[3]={i2,i0,i1};\nstd::cout<<nums[0]<<nums[1]<<nums[2];\n```",
            "answer": "Es gibt keine Ausgabe. Der Code verursacht einen Compilerfehler, weil `nums` ein Array von Referenzen ist, was illegal ist.",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/language/array)",
            "hint": null,
            "correctAnswer": [
              "Es gibt keine Ausgabe. Der Code verursacht einen Compilerfehler, weil `nums` ein Array von Referenzen ist, was illegal ist."
            ],
            "options": [
              "Es gibt keine Ausgabe. Der Code verursacht einen Compilerfehler, weil `nums` ein Array von Referenzen ist, was illegal ist.",
              "846",
              "Die Ausgabe sind die Adressen von `i2`, `i0` und `i1`, in dieser Reihenfolge, ohne Leerzeichen.",
              "468"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3cc6324dfc9b5aa80a6f0092",
            "question": "Verursacht dieser Code einen Compilerfehler? Wenn ja, warum, und wenn nicht, was ist `child_t`?\n```cpp\ntypedef struct{\n    unsigned int  age    : 4;\n    unsigned char gender : 1;\n    char                 : 0;\n    unsigned int  size   : 2;\n}child_t;\n```",
            "answer": "Nein, und `child_t` ist ein Typ, der als Struktur mit Bitfeldern definiert ist. Es hat 4 Bits für age und 1 Bit für gender im ersten Byte und 2 Bits für size im zweiten Byte.",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": [
              "Nein, und `child_t` ist ein Typ, der als Struktur mit Bitfeldern definiert ist. Es hat 4 Bits für age und 1 Bit für gender im ersten Byte und 2 Bits für size im zweiten Byte."
            ],
            "options": [
              "Ja, es verursacht einen Compilerfehler, weil das Doppelpunktzeichen in Strukturdefinitionen nicht erlaubt ist.",
              "Nein, und `child_t` ist ein Typ, der als Struktur mit Bitfeldern definiert ist. Es hat 4 Bits für age und 1 Bit für gender im ersten Byte und 2 Bits für size im zweiten Byte.",
              "Ja, es verursacht einen Compilerfehler, weil es ein unbenanntes Feld gibt.",
              "Ja, es verursacht einen Compilerfehler, weil ein Feld mit einer Größe von 0 definiert ist."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "81685f9e9e525d9bed7901d4",
            "question": "Wozu ist dieser Ausdruck gleichwertig?\n```cpp\nA->B\n```",
            "answer": "`(*A).B`",
            "explanation": "Hinweis: Eine einfachere Variante der Frage unten.",
            "hint": null,
            "correctAnswer": ["`(*A).B`"],
            "options": ["`*(A.B)`", "`B=A`", "`(*A).B`", "`&A.B`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "dde887ff5e8bad0b56693994",
            "question": "Wozu ist dieser Ausdruck gleichwertig?\n```cpp\nA->B->C->D\n```",
            "answer": "`*(*((*A).B).C).D`",
            "explanation": "**Hinweis:** Eine komplexere Variante der Frage oben.",
            "hint": null,
            "correctAnswer": ["`*(*((*A).B).C).D`"],
            "options": ["`A.B.C.D`", "`*A.*B.*C.*D`", "`&A.&B.&C.&D`", "`*(*((*A).B).C).D`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "750335f1ef755ea5240f608c",
            "question": "Was macht diese Funktion?\n```cpp\nauto buff = new char[50];\nstd::memset(buff,20,50);\n```",
            "answer": "Sie schreibt den Wert 20 in jede Speicheradresse von buff bis buff+49.",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/string/byte/memset)",
            "hint": null,
            "correctAnswer": [
              "Sie schreibt den Wert 20 in jede Speicheradresse von buff bis buff+49."
            ],
            "options": [
              "Sie deklariert einen Speicherpuffer namens buff, der bei Adresse 20 beginnt und bei Adresse 70 endet.",
              "Sie setzt alle Bits im Array namens buffer von seinem Element bei Index 20 bis zu seinem Element bei Index 50.",
              "Sie schreibt den Wert 20 in jede Speicheradresse von buff bis buff+49.",
              "Sie deklariert einen Speicherpuffer namens buff, der bei Adresse 20 beginnt und bei Adresse 50 endet."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b163a00d2b0bf794d6b959c2",
            "question": "Betrachten Sie eine Klasse namens `CustomData`. Welche Wahl ist eine korrekte Deklarationssyntax zum Überladen des Postfix-`++`-Operators als Klassenmitglied?",
            "answer": "`CustomData operator++(int);`",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/language/operators)",
            "hint": null,
            "correctAnswer": ["`CustomData operator++(int);`"],
            "options": [
              "`CustomData& operator++();`",
              "`void operator++(CustomData);`",
              "`CustomData operator++(CustomData);`",
              "`CustomData operator++(int);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cbab4f27c0696d563699ad1e",
            "question": "Sie möchten my_array sortieren, das unten deklariert ist. Welche Wahl ist der korrekte Aufruf von std::sort unter Verwendung eines Lambda-Ausdrucks als Vergleichsfunktion?\n```cpp\nstd::array<uint32_t, 50> my_array;\n```",
            "answer": "A",
            "explanation": "```cpp\nstd::sort(my_array.begin(), my_array.end(),\n[](uint32_t a, uint32_t b) {\nreturn a < b;\n})\n```\n```cpp\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n}\nstd::sort(my_array.begin(), my_array.end(), lambda);\n```\n```cpp\nstd::sort(my_array.begin(), my_array.end(),\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n})\n```\n```cpp\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n}\nstd::sort(my_array.begin(), my_array.end(), &lambda);\n```\n[Referenz](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160)",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "16aa625102b5705eabe15941",
            "question": "Welche Wahl ist die vernünftigste Implementierung der Funktion std::mutex::lock() unter Verwendung von std::mutex::try_lock()?",
            "answer": "A",
            "explanation": "```cpp\nvoid std::mutex::lock(){\nwhile(!this->try_lock());\n}\n```\n```cpp\nvoid std::mutex::lock(){\nreturn (this->try_lock());\n}\n```\n```cpp\nvoid std::mutex::lock(){\nwhile(1)\nthis->try_lock();\n}\n```\n```cpp\nvoid std::mutex::lock(){\nwhile(this->try_lock());\n}\n```\nHinweis: Variante der Frage unten.",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bcd9a8f8d48cf5e9491f7094",
            "question": "Was ist der Hauptunterschied zwischen diesen beiden Funktionen?\n```cpp\nstd::mutex::lock()\nstd::mutex::try_lock()\n```",
            "answer": "Beide versuchen, eine Sperre zu erwerben, aber `lock()` blockiert, wenn der Mutex nicht verfügbar ist, während `try_lock()` zurückgibt, ob der Mutex verfügbar ist oder nicht.",
            "explanation": "Hinweis: Variante der Frage oben.\n[Referenz](https://en.cppreference.com/w/cpp/thread/mutex/try_lock)",
            "hint": null,
            "correctAnswer": [
              "Beide versuchen, eine Sperre zu erwerben, aber `lock()` blockiert, wenn der Mutex nicht verfügbar ist, während `try_lock()` zurückgibt, ob der Mutex verfügbar ist oder nicht."
            ],
            "options": [
              "`lock()` hat eine höhere Priorität über `try_lock()`. Das bedeutet, dass Sie eine bessere Chance haben, einen Mutex mit `lock()` zu erwerben.",
              "Beide versuchen, eine Sperre zu erwerben, aber `lock()` blockiert, wenn der Mutex nicht verfügbar ist, während `try_lock()` zurückgibt, ob der Mutex verfügbar ist oder nicht.",
              "`lock()` erzwingt Präemption, während `try_lock()` Präemption vorschlägt.",
              "Wenn der Mutex nicht verfügbar ist, gibt `try_lock()` mit einem entsprechenden Code zurück, während `lock()` den Mutex vom Thread stiehlt, der ihn derzeit hat."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8cd41bf2f6d1d6695e12e8f9",
            "question": "Was ist der Zweck eines Destruktors?",
            "answer": "Er ermöglicht es dem Programmierer, den notwendigen Code zu schreiben, um die vom Objekt erworbenen Ressourcen freizugeben, bevor das Objekt selbst gelöscht wird.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Er ermöglicht es dem Programmierer, den notwendigen Code zu schreiben, um die vom Objekt erworbenen Ressourcen freizugeben, bevor das Objekt selbst gelöscht wird."
            ],
            "options": [
              "Er ermöglicht es dem Programmierer, den notwendigen Code zu schreiben, um die vom Objekt erworbenen Ressourcen freizugeben, bevor das Objekt selbst gelöscht wird.",
              "Er löscht ein Objekt. Ein Beispiel für einen Destruktor ist die `delete()`-Funktion.",
              "Er beendet ein Programm. Dies kann als regulärer Funktionsaufruf oder als Ausnahme erreicht werden.",
              "Es gibt keine Destruktoren in C++."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4b149d9edd0ae52b35a4c654",
            "question": "Was ist ein Vorteil der Deklaration des Parameters als `const`-Referenz anstelle der Deklaration als reguläres Objekt?\n```cpp\nint calculateMedian(const my_array& a)\n```",
            "answer": "Der `const`-Qualifier verbietet es dem Code, das Argument zu modifizieren, sodass der Programmierer sicher sein kann, dass das Quellobjekt unverändert bleibt. / Alt.: Das Argument wird als Referenz übergeben, also wenn das übergebene my_array-Objekt groß ist, benötigt das Programm weniger Zeit und Speicher.",
            "explanation": "[Referenz](https://stackoverflow.com/a/2627179/10773894)",
            "hint": null,
            "correctAnswer": [
              "Der `const`-Qualifier verbietet es dem Code, das Argument zu modifizieren, sodass der Programmierer sicher sein kann, dass das Quellobjekt unverändert bleibt. / Alt.: Das Argument wird als Referenz übergeben, also wenn das übergebene my_array-Objekt groß ist, benötigt das Programm weniger Zeit und Speicher."
            ],
            "options": [
              "Tatsächlich können Objekte nicht als reguläre Variablen übergeben werden, weil sie einen Konstruktoraufruf erfordern. Daher ist eine `const`-Referenz die einzige Möglichkeit, Klasseninstanzen an Funktionen zu übergeben.",
              "Es gibt keine Vorteile, weil eine Referenz und ein Objekt als dasselbe behandelt werden.",
              "Der `const`-Qualifier verbietet es dem Code, das Argument zu modifizieren, sodass der Programmierer sicher sein kann, dass das Quellobjekt unverändert bleibt. / Alt.: Das Argument wird als Referenz übergeben, also wenn das übergebene my_array-Objekt groß ist, benötigt das Programm weniger Zeit und Speicher.",
              "Das Argument wird als Referenz übergeben, sodass die Funktion eine Kopie erhält, die modifiziert werden kann, ohne die ursprüngliche Variable zu beeinflussen."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8a4b8ef508077f22afc095dd",
            "question": "Was ist ein Include-Guard?",
            "answer": "Eine Präprozessoranweisung, die verhindert, dass eine Quelldatei mehr als einmal in einem Projekt eingebunden wird",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Eine Präprozessoranweisung, die verhindert, dass eine Quelldatei mehr als einmal in einem Projekt eingebunden wird"
            ],
            "options": [
              "Eine Präprozessordirektive, die inkonsistente Verhaltensweisen in Zeilen verhindert, die die Direktiven #ifdef, #ifndef oder #elif enthalten",
              "Eine Compileroption, die verhindert, dass der Benutzercode zusätzliche Bibliotheken einbindet",
              "Eine Präprozessoranweisung, die verhindert, dass eine Quelldatei mehr als einmal in einem Projekt eingebunden wird",
              "Eine Bibliothek, die Sicherheitsfunktionen wie Mutexe, Watchdog-Timer und Assertions zum Projekt hinzufügt"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "593558e5172215fd4e5ee7c6",
            "question": "Was wäre die korrekte Deklaration eines Standardkonstruktors für eine Klasse namens Sprite?",
            "answer": "A",
            "explanation": "```cpp\npublic: Sprite();\n```\n```cpp\nprivate: void Sprite();\n```\n```cpp\npublic: void Sprite();\n```\n```cpp\nprivate: Sprite();\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "eccacd6353dfe538d774c203",
            "question": "Was ist der Zweck dieser Zeile in einer Header-Datei?\n```cpp\n#pragma once\n```",
            "answer": "Den Compiler zu veranlassen, diese Header-Datei nur einmal zu parsen, selbst wenn sie mehrfach in der Quelle eingebunden ist",
            "explanation": "[Referenz hier](https://en.cppreference.com/w/cpp/preprocessor/impl)",
            "hint": null,
            "correctAnswer": [
              "Den Compiler zu veranlassen, diese Header-Datei nur einmal zu parsen, selbst wenn sie mehrfach in der Quelle eingebunden ist"
            ],
            "options": [
              "Die Verwendung ihres Inhalts auf nur eine Quelldatei zu beschränken",
              "Dem Compiler mitzuteilen, dass nur eine Variable aus den in dieser Header-Datei enthaltenen Klassen oder Typen instanziiert werden kann",
              "Dem Compiler zu helfen, schneller fertig zu werden, indem sichergestellt wird, dass nur ein Compiler-Durchgang für den in dieser Header-Datei enthaltenen Code notwendig ist",
              "Den Compiler zu veranlassen, diese Header-Datei nur einmal zu parsen, selbst wenn sie mehrfach in der Quelle eingebunden ist"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0cce8371ee3029090136e42e",
            "question": "Was ist eine Variable vom Typ double?",
            "answer": "Eine Gleitkommazahl",
            "explanation": "[Referenz](https://www.educba.com/c-plus-plus-double/)",
            "hint": null,
            "correctAnswer": ["Eine Gleitkommazahl"],
            "options": [
              "Ein 2-Tupel",
              "Eine Ganzzahl",
              "Eine Gleitkommazahl",
              "Eine Zeichenkette mit mehr als 255 Zeichen"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d980790fb8498539e6e5f2f4",
            "question": "Wofür wird der <<-Operator außer zum Verschieben von Bits nach links verwendet?",
            "answer": "Zum Einfügen von Zeichen in einen Ausgabestrom wie std::cout.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Zum Einfügen von Zeichen in einen Ausgabestrom wie std::cout."],
            "options": [
              "Zum Verschieben von Zeichen nach links in einer Zeichenkette.",
              "Zum Einfügen von Zeichen in einen Ausgabestrom wie std::cout.",
              "Zum Vergleichen von Gleitkommazahlen als kleiner-als.",
              "Zum Zuweisen einer Variablen zu einer Referenz."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d5af053ef2a8c2a29dab5d83",
            "question": "Welche Wahl ist ein Grund, den Typ eines Zeigers anzugeben, anstatt `void *` zu verwenden, das als Zeiger auf jeden Typ funktioniert?",
            "answer": "Der Compiler benötigt den Datentyp, um zu wissen, wie viel Speicher für den Zeiger zugewiesen werden soll, da verschiedene Datentypen unterschiedliche Zeigerlängen erfordern.",
            "explanation": "[Referenz](https://stackoverflow.com/questions/9802585/why-is-the-data-type-needed-in-pointer-declarations)",
            "hint": null,
            "correctAnswer": [
              "Der Compiler benötigt den Datentyp, um zu wissen, wie viel Speicher für den Zeiger zugewiesen werden soll, da verschiedene Datentypen unterschiedliche Zeigerlängen erfordern."
            ],
            "options": [
              "Der Compiler benötigt den Datentyp, um sicherzustellen, dass der Zeiger nicht für illegale nicht-zeigerfähige Typen wie Funktionen, Labels, Zeiger und Referenzen verwendet wird.",
              "`void *` funktioniert nicht für jeden Typ. Die Sprache erlaubt nicht die Zuweisung von etwas anderem als `void` an einen Zeiger auf `void *`.",
              "Der Compiler benötigt den Datentyp, um zu wissen, wie viel Speicher für den Zeiger zugewiesen werden soll, da verschiedene Datentypen unterschiedliche Zeigerlängen erfordern.",
              "Ja, es verursacht einen Compilerfehler, weil ein Feld mit einer Größe von 0 definiert ist."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1a5ed9c19a9318795b2eeb7b",
            "question": "Was ist falsch an diesem Code?\n```cpp\n#include <iostream>\nchar str[20];\nint main(){\n    std::cout << \"What's your name? \";\n    str << std::cin\n    std::cout << \"Hello, \" << str;\n    return 0;\n}\n```",
            "answer": "Der Eingabeoperatorfluss ist invertiert. Er sollte von `std::cin` ausgehen und dann (>>) in `str` fließen.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Der Eingabeoperatorfluss ist invertiert. Er sollte von `std::cin` ausgehen und dann (>>) in `str` fließen."
            ],
            "options": [
              "Die main-Funktion soll einen void-Rückgabetyp haben.",
              "`std::cin` und `std::cout` sind ungültig. Die korrekten Namen für die Zeicheneingabe- und Ausgabeströme sind `cin` und `cout`.",
              "Die Adresse von `str` soll verwendet werden. Das ist `&str` anstelle von `str`.",
              "Der Eingabeoperatorfluss ist invertiert. Er sollte von `std::cin` ausgehen und dann (>>) in `str` fließen."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d5435c200d2a697763fa6c13",
            "question": "Wenn in einem gültigen Ausführungskontext platziert, welche Anweisung wird dynamisch Speicher vom Heap für eine Ganzzahl mit dem Wert 11 zuweisen?",
            "answer": "`int* anInt = new int(11);`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`int* anInt = new int(11);`"],
            "options": [
              "`int anInt = new int(11);`",
              "`int* anInt = new int[11];`",
              "`int anInt = new int[11];`",
              "`int* anInt = new int(11);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "75c8550522d218c4e85e8298",
            "question": "Welche Wahl beschreibt den Typ `long` am besten?",
            "answer": "Eine Ganzzahl von mindestens 32 Bits",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Eine Ganzzahl von mindestens 32 Bits"],
            "options": [
              "Eine Ganzzahl von mindestens 32 Bits",
              "Eine Zeichenkette mit mehr als 255 Zeichen",
              "Ein Zeiger",
              "Eine 64-Bit-Gleitkommazahl"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4b23ca5801204910d4bf7a6f",
            "question": "Welcher der folgenden Typen hat die engste Funktionalität zu einer Klasse?",
            "answer": "`struct`",
            "explanation": "[Referenz](https://en.cppreference.com/w/c/language/struct)",
            "hint": null,
            "correctAnswer": ["`struct`"],
            "options": ["`struct`", "`union`", "`enum`", "`namespace`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3d77d608ad859ee7e3e27c9e",
            "question": "Bei diesen Einträgen in einer Map, wie werden Sie den Wert für den Schlüssel \"Sinead\" auf 22 aktualisieren?\n![image](images/Q79.png)",
            "answer": "`marks[\"Sinead\"] = 22`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`marks[\"Sinead\"] = 22`"],
            "options": [
              "`marks[\"Sinead\"] = 22`",
              "`marks[\"Sinead\"].22`",
              "`marks[\"Sinead\"] -> 22`",
              "`marks[\"Sinead\"].value = 22`"
            ],
            "nature": "ChooseOne",
            "attachments": [
              {
                "id": "ac01bb559e47f5a009d6da5b",
                "url": "/Users/arslankaleem/Workspace/Junk/linkedin-skill-assessments-quizzes/c++/images/Q79.png",
                "type": "question"
              }
            ],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d18936c7a791351d698a974d",
            "question": "Warum kann std::sort ein Funktionsobjekt als einen seiner Parameter empfangen?",
            "answer": "`Die std::sort-Funktion ist ein Template. Der Programmierer kann den Sortieralgorithmus in einem Funktionsobjekt als Argument eingeben.`",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "`Die std::sort-Funktion ist ein Template. Der Programmierer kann den Sortieralgorithmus in einem Funktionsobjekt als Argument eingeben.`"
            ],
            "options": [
              "`Die std::sort-Funktion ist ein Template. Der Programmierer kann den Sortieralgorithmus in einem Funktionsobjekt als Argument eingeben.`",
              "`Tatsächlich nimmt std::sort nur ein Argument entgegen, nämlich den zu sortierenden Container.`",
              "`std::sort arbeitet auf einem Template-Container. Der Compiler weiß nicht, wie er die darin enthaltenen Werte relational vergleichen soll, daher muss eine Funktion zum Vergleich bereitgestellt werden.`",
              "`std::sort verwendet die Parameter-Funktion als Fehlerbehandler. Die Funktion wird aufgerufen, wenn ein Fehler auftritt.`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5a4a27ad72748cc842d64971",
            "question": "Was passiert, wenn Sie dieses Code-Snippet ausführen?\n```cpp\n#include <iostream>\nint main() {\nfloat a = 5.51;\nint b = static_cast<int>(a);\nstd::cout << b;\n}\n```",
            "answer": "`5 wird auf der Standardausgabe ausgegeben, ohne dass Kompilierungswarnungen generiert werden.`",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "`5 wird auf der Standardausgabe ausgegeben, ohne dass Kompilierungswarnungen generiert werden.`"
            ],
            "options": [
              "`6 wird auf der Standardausgabe ausgegeben, ohne dass Kompilierungswarnungen generiert werden.`",
              "`5 wird auf der Standardausgabe ausgegeben, ohne dass Kompilierungswarnungen generiert werden.`",
              "`6 wird auf der Standardausgabe ausgegeben, mit Kompilierungswarnungen.`",
              "`5 wird auf der Standardausgabe ausgegeben, mit Kompilierungswarnungen.`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c75f5e6fab77576b8e59e77d",
            "question": "Welcher Zugriffsspezifizierer erlaubt es nicht, dass Klassenmitglieder von außerhalb der Klasse aufgerufen werden, erlaubt aber den Zugriff durch abgeleitete Klassen?",
            "answer": "protected",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["protected"],
            "options": ["guarded", "protected", "public", "private"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7efd625ce77cac848016130f",
            "question": "Die standardmäßige ausführbare Generierung auf UNIX für ein C++-Programm ist \\_",
            "answer": "a.out",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["a.out"],
            "options": ["a.exe", "a", "a.out", "out.a"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ae0691b775db9b2c58f7d5cc",
            "question": "Was wird die Ausgabe des folgenden Programms sein?\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\n  int a=1;\n  cout<<(a++)*(++a)<<endl;\n  return 0;\n}\n```",
            "answer": "3",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["3"],
            "options": ["1", "2", "3", "6"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "23f2067af2c633e8e0ab9a0f",
            "question": "Wofür steht \"c\" in cout und cin?",
            "answer": "character",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["character"],
            "options": ["compiler", "console", "character", "standard namespace"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3ad0e6b87fa8b74fe675180f",
            "question": "Was ist die Verwendung von tellp()?",
            "answer": "Aktuelle Ausgabezeigerposition",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Aktuelle Ausgabezeigerposition"],
            "options": [
              "Aktuelle Eingabezeigerposition",
              "Aktuelle Ausgabezeigerposition",
              "Letzte Eingabezeigerposition",
              "Letzte Ausgabezeigerposition"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7439a26043a1ec7f2592ba1f",
            "question": "Was ist eine Callback-Funktion?",
            "answer": "Zeiger auf eine Funktion",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Zeiger auf eine Funktion"],
            "options": [
              "Zeiger auf einen Zeiger",
              "Zeiger auf eine Funktion",
              "Funktion für einen Zeiger",
              "Funktion für eine Klasse"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "29020cede533ec33714ecd9b",
            "question": "Was ist die korrekte Syntax, um \"Hello World\" in C++ auszugeben?",
            "answer": "`cout << \"Hello World\";`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`cout << \"Hello World\";`"],
            "options": [
              "`cout << \"Hello World\";`",
              "`System.out.println(\"Hello World\");`",
              "`print(\"Hello World\");`",
              "Console.WriteLine(\"Hello World\");```"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0010544b644de243587bac43",
            "question": "Wie viele Kategorien von Iteratoren gibt es in C++?",
            "answer": "5",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["4", "3", "7", "5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "617ce80c6321a36c7f387a9d",
            "question": "Was bedeutet Basisklasse in C++?",
            "answer": "Eine andere Klasse wurde von dieser Klasse geerbt",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Eine andere Klasse wurde von dieser Klasse geerbt"],
            "options": [
              "Sie erbt andere Klassen",
              "Sie hat eine Zeigervariable",
              "Sie ist die erste deklarierte Klasse",
              "Eine andere Klasse wurde von dieser Klasse geerbt"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ec6c583498626863a2aee4af",
            "question": "Die Größe von C++-Objekten wird in Vielfachen der Größe eines ** ausgedrückt, und die Größe eines char ist **.",
            "answer": "char, 1",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["char, 1"],
            "options": ["char, 4", "float, 8", "int, 1", "char, 1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "965b8d66a695701039324c3e",
            "question": "Implementierungsabhängige Aspekte über eine Implementierung können gefunden werden in",
            "answer": "`<limits>`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`<limits>`"],
            "options": ["`<numeric>`", "`<limit>`", "`<limits>`", "`<implementation>`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "444c7bdd3e495dced5715458",
            "question": "Was ist ein Standardkonstruktor?",
            "answer": "Ein Konstruktor, der ohne Argumente verwendet werden kann",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Ein Konstruktor, der ohne Argumente verwendet werden kann"],
            "options": [
              "Ein Konstruktor, der ohne Argumente verwendet werden kann",
              "Ein Konstruktor, der keinen Rückgabewert hat",
              "Ein Konstruktor, der von mehreren Klassen verwendet wird",
              "Ein Konstruktor, der alle Mitglieder einer Klasse initialisiert"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6794d98b0c9bf2eba458b430",
            "question": "Warum würden Sie beim Schützen einer Header-Datei '#pragma once' anstelle von 'include guard' verwenden?",
            "answer": "Ein Include-Guard verwendet ein Makro, um eine einzige Einbindung zu erreichen, aber der Compiler kann nicht verhindern, dass der Programmierer dieses Makro anderswo definiert, was zu überhaupt keiner Einbindung führen würde",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Ein Include-Guard verwendet ein Makro, um eine einzige Einbindung zu erreichen, aber der Compiler kann nicht verhindern, dass der Programmierer dieses Makro anderswo definiert, was zu überhaupt keiner Einbindung führen würde"
            ],
            "options": [
              "Es gibt keinen Grund zu wählen, weil sie unterschiedlichen Zwecken dienen",
              "Ein Include-Guard verwendet ein Makro, um eine einzige Einbindung zu erreichen, aber der Compiler kann nicht verhindern, dass der Programmierer dieses Makro anderswo definiert, was zu überhaupt keiner Einbindung führen würde",
              "'#pragma once' garantiert, dass der Header-Code niemals geändert wird, weil es vom Compiler erzwungen wird",
              "Include-Guards beziehen sich auf die Header-Datei im Dateisystem, nicht auf den Code, daher sind sie nicht hilfreich, wenn die Header-Datei mehr als einmal in einem Projekt existiert. Dies ist bei '#pragma once' kein Problem"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a007b49792926c95ef6da413",
            "question": "Welche der folgenden Aussagen ist gültig?",
            "answer": "Wir können die Operator-Templates nicht ändern.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Wir können die Operator-Templates nicht ändern."],
            "options": [
              "Wir können einen neuen C++-Operator erstellen.",
              "Wir können die Vorrangstellung des C++-Operators ändern.",
              "Wir können die Operator-Templates nicht ändern.",
              "Wir können die Assoziativität der C++-Operatoren ändern."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b2fdad8103011c73d09e3ba6",
            "question": "Welches der folgenden wird/werden automatisch zu jeder Klasse hinzugefügt, wenn wir unsere eigenen nicht schreiben?",
            "answer": "Alle oben genannten",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Alle oben genannten"],
            "options": [
              "Kopierkonstruktor",
              "Zuweisungsoperator",
              "Ein Konstruktor ohne Parameter",
              "Alle oben genannten"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e29131acc2fb4760d188264c",
            "question": "Die if-else-Anweisung kann durch welchen Operator ersetzt werden?",
            "answer": "selektive Struktur",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["selektive Struktur"],
            "options": [
              "bestimmte Struktur",
              "Auswahlstruktur",
              "selektive Struktur",
              "Keine der oben genannten"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "94e40fd17362ffde80e1e838",
            "question": "Welche Wahl wäre eine rekursive Lösung für das Fakultätsproblem n!?",
            "answer": "&shy;",
            "explanation": "```cpp\nvoid fact(int n) {\nif (n <= 0)\nreturn 0;\nelse\nreturn 1;\n}\n```\n```cpp\nint fact(int n) {\nif (n <= 0)\nreturn 1;\nelse\nreturn (fact(n) * (n-1));\n}\n```\n```cpp\nint fact(int n) {\nif (n >= 0)\nreturn 1;\nelse\nreturn (fact(n-1) * n);\n}\n```\n```cpp\nint fact(int n) {\nif (n <= 0)\nreturn 1;\nelse\nreturn (fact(n-1) * n);\n}\n```",
            "hint": null,
            "correctAnswer": ["&shy;"],
            "options": ["&shy;", "&shy;", "&shy;", "&shy;"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "89fb588457cc80202f0edc94",
            "question": "Ein Klassen-Destruktor kann in verschiedenen Situationen aufgerufen werden. Welche Wahl ist keine dieser Situationen?",
            "answer": "Der Garbage Collector erkennt, dass ein Objekt nicht mehr verwendet wird.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Der Garbage Collector erkennt, dass ein Objekt nicht mehr verwendet wird."
            ],
            "options": [
              "Das Programm wird beendet. Dies ruft den Destruktor von Objekten mit statischer Dauer auf.",
              "Die delete()-Funktion wird für einen Objektzeiger aufgerufen, der mit dem new-Operator zugewiesen wurde.",
              "Der Garbage Collector erkennt, dass ein Objekt nicht mehr verwendet wird.",
              "Ein Objekt mit automatischer Speicherdauer verlässt den Gültigkeitsbereich."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "60ab17cf888347a3e4061e3e",
            "question": "Sie entwerfen ein Devisenzahlungssystem in C++. Sie müssen eine Transaktion einer Währung modellieren, die eine Ganzzahl als Menge und einen Float als Preis hat. Dann möchten Sie ein tatsächliches Objekt dieses Typs deklarieren. Wie erreichen Sie dies?",
            "answer": "A",
            "explanation": "```cpp\nstruct currencyDeal {\nfloat price;\nint quantity;\n};\ncurrencyDeal firstDeal;\n```\n```cpp\nunion currencyDeal {\nfloat price;\nint quantity;\n};\ncurrencyDeal firstDeal;\n```\n```cpp\nstruct currencyDeal {\nfloat price;\nint quantity;\n};\n```\n```cpp\nunion currencyDeal {\nfloat price;\nint quantity;\n};\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6d9df24679552c891638fc94",
            "question": "Was passiert, wenn Sie versuchen, diese Funktion mit checkConcatThreshold(\"a\"); aufzurufen?\n```cpp\nint checkConcatThreshold(string a, string b) {\n    return (a + b).length () > 120;\n}\n```",
            "answer": "Ein Kompilierungsfehler tritt auf.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Ein Kompilierungsfehler tritt auf."],
            "options": [
              "Eine Kompilierungswarnung tritt auf und das zweite Argument erhält einen Standardwert von b.",
              "Eine Kompilierungswarnung tritt auf und das zweite Argument erhält einen Standardwert der leeren Zeichenkette.",
              "Ein Kompilierungsfehler tritt auf.",
              "Es treten keine Kompilierungsfehler und keine Kompilierungswarnungen auf."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "296d77201da123377c1fca1d",
            "question": "Sie müssen eine C++-Lambda-Funktion definieren. Sie möchten, dass die Funktion nur Zugriff auf die Variablen hat, die lokal für sie sind. Die Funktion soll einen einzigen Parameter, einen Namen, empfangen und eine einfache Begrüßung konstruieren. Wie erreichen Sie dies?",
            "answer": "C",
            "explanation": "```cpp\nauto myVeryFirstLambda = [=] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nmyVeryFirstLambda = [&] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nauto myVeryFirstLambda = [] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nmyVeryFirstLambda = [] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n[Referenz](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160)",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e4404dbbf4437a5548c5b7a9",
            "question": "Was ist der Wert von X nach Ausführung dieses Codes?\n```cpp\nint x=10, a=-3;\nX+=a;\n```",
            "answer": "7",
            "explanation": "**Erklärung:** `+=` bedeutet Werterhöhung. Also ist `x += a` gleichwertig mit `x = x + a`",
            "hint": null,
            "correctAnswer": ["7"],
            "options": ["-3", "7", "13", "3"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6bad315a9c14d85beffef282",
            "question": "Sobald Sie mit dem Schreiben in eine Datei fertig sind, welche Methode werden Sie auf dem `ofstream` aufrufen, um das Betriebssystem zu benachrichtigen?",
            "answer": "close()",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["close()"],
            "options": ["printout()", "close()", "destroy()", "flush()"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "245dc837ac980f5c654689bc",
            "question": "Welche Wahl ist kein C++-Schlüsselwort?",
            "answer": "comPl",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["comPl"],
            "options": ["static_assert", "reinterpret_cast", "comPl", "alignas"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d49fde867bbc8fa6fdda4a6e",
            "question": "Die size_in_bits-Funktion scheint jeden Parametertyp zu akzeptieren. Dies kann durch Überladen der Funktion erreicht werden oder indem der Compiler sich darum kümmert, indem ein Template geschrieben wird. Welche Wahl ist eine Implementierung dieses Templates?\n```cpp\nint main()\n{\ncout « size_in_bits(21) « endl;\ncout « size_in_bits('f') « endl;\ncout « size_in_bits(32.1f) « endl;\ncout « size_in_bits(32.1) « endl;\nreturn 0;\n}\n```",
            "answer": "A; C",
            "explanation": "```cpp\ntemplate <typename T>\nsize_t size_in_bits(const T& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\ntemplate size_t size_in_bits(const {int,float,double,char,long}& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\ntemplate <typename T {int,float,double,char,long>\nsize_t size_in_bits(const T& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\nsize_t size_in_bits(void * a){\nreturn sizeof(a)*8;\n}\n```",
            "hint": null,
            "correctAnswer": ["A", "C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "788f1a52336e36f968d0e057",
            "question": "Um die Tastatur als Eingabe zu verwenden, wird die iostream-Bibliothek eingebunden. Um Eingaben aus Dateien zu lesen, welche Bibliothek wird benötigt?",
            "answer": "fstream",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["fstream"],
            "options": ["fstream", "cstdlib", "filestream", "iostream"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "99e55d643d8cbffc3eba32e3",
            "question": "Was wird dieses objektorientierte Programm ausgeben?\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Vehicle {\npublic:\n\tstring fuel = \"none\";\n};\nclass MotorizedVehicle : public Vehicle {\npublic:\n\tstring fuel = \"fossil\";\n};\nclass NextgenMotorizedVehicle : public MotorizedVehicle {\npublic:\n\tstring fuel = \"hydrogen\";\n};\nint main() {\n\tMotorizedVehicle aCar;\n\tcout << aCar.fuel;\n\treturn 0;\n}\n```",
            "answer": "fossil",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["fossil"],
            "options": ["fossil", "fossil none", "hydrogen", "none"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "144a3b6b9722976964ac6b7c",
            "question": "Das folgende Programm verarbeitet einen Stack-Container. Was ist die Ausgabe beim Ausführen des Programms?\n```cpp\n#include <iostream>\n#include <stack>\nint main()\n{\n\tstd::stack<int> stack;\n\tstack.push(1);\n\tstack.push(2);\n\tstack.push(3);\n\tstack.pop();\n\tstack.push(4);\n\tstack.top();\n\tstack.pop();\n\tstd::cout << stack.top();\n}\n```",
            "answer": "2",
            "explanation": "#Detaillierte Erklärung:\nHier sollen wir eine Stack-Datenstruktur implementieren, die dem **FILO**- oder (First IN Last Out) Prinzip folgt,\n_stack.push()_ -> schiebt ein Element vom Ende in das Array.\n_stack.pop()_ -> entfernt ein Element vom Ende des Arrays.\n_stack.top()_ -> Gibt uns nur das oberste Element des Arrays.\nNach der Reihenfolge der Push- und Pop-Operationen: **[1,2,3]** dann wird die Pop-Funktion verwendet,\nDas neu gebildete Array ist: **[1,2,4]** dann wird top verwendet, um das oberste Element '4' abzurufen, dann wird wieder die Pop-Funktion verwendet, die 4 entfernt.\nDas resultierende Array ist also: 1,2.\nDann wird das oberste Element (d.h.: 2) ausgegeben.",
            "hint": null,
            "correctAnswer": ["2"],
            "options": ["1", "2", "3", "4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "872d2b3179f65e3bda03f0e7",
            "question": "Welche Wahl ist eine gültige Möglichkeit, den ternären bedingten Operator zu überladen?",
            "answer": "`Der ternäre Operator kann nicht überladen werden.`",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/language/operators)",
            "hint": null,
            "correctAnswer": ["`Der ternäre Operator kann nicht überladen werden.`"],
            "options": [
              "`void& operator ?:(const bool cond, const void& iftrue, const void& iffalse);`",
              "`Der ternäre Operator kann nicht überladen werden.`",
              "`void& operator conditional(const bool cond, const void& iftrue, const void& iffalse);`",
              "`void* operator ?:(const bool cond, const void* iftrue, const void* iffalse);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "15d6e60b73ee8fb5e6830160",
            "question": "Welche Klassenhierarchie repräsentiert ein Beispiel für Mehrfachvererbung?",
            "answer": "Im selben Programm leitet sich eine gegebene Klasse an verschiedenen Punkten individuell von mehr als zwei verschiedenen Klassen ab.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Im selben Programm leitet sich eine gegebene Klasse an verschiedenen Punkten individuell von mehr als zwei verschiedenen Klassen ab."
            ],
            "options": [
              "Im selben Programm leitet sich eine gegebene Klasse an verschiedenen Punkten individuell von mehr als einer verschiedenen Klasse ab.",
              "Eine erste Klasse leitet sich direkt und gleichzeitig von einer zweiten und dritten Klasse ab.",
              "Im selben Programm leitet sich eine gegebene Klasse an verschiedenen Punkten individuell von mehr als zwei verschiedenen Klassen ab.",
              "Eine erste Klasse leitet sich von einer zweiten Klasse ab, und diese zweite Klasse ist bereits von einer dritten Klasse abgeleitet"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b35d21219b96673389bf9a9d",
            "question": "Was ist die korrekte Syntax, um die Nachricht in C++ auszugeben?",
            "answer": "cout <<\"Hello world!\";",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/io/cout)",
            "hint": null,
            "correctAnswer": ["cout <<\"Hello world!\";"],
            "options": [
              "Out <<\"Hello world!",
              "Cout << Hello world! ;",
              "cout <<\"Hello world!\";",
              "Keine der oben genannten"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bf3b0f51801e062714b12629",
            "question": "Betrachten Sie das folgende Programm. Was wird die Ausgabe/der Fehler sein?\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nbool compare(char c1, char c2){\nreturn tolower(c1) > tolower(c2);    //ZEILE-1\n}\nint main(){\nchar arr1[20] = \"C++ Program\", arr2[20] = \"C Program\";\ncout << lexicographical_compare(arr1, arr1+strlen(arr1), arr2, arr2+strlen(arr2),\ncompare);\nreturn 0;\n}\n```",
            "answer": "1",
            "explanation": "[Referenz](https://www.geeksforgeeks.org/tolower-function-in-cpp/)",
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["1", "0", "-1", "Kompilierungsfehler: Funktion ist nicht definiert"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "be49bf48165892291f305531",
            "question": "Betrachten Sie das folgende Code-Segment. Füllen Sie die Lücke in ZEILE-1 aus, damit das Programm \"not found\" ausgibt?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint data[] = {1,2,3,4,5};\nint key = 5;\nif(binary_search(__________))    //ZEILE-1\ncout << \"found\";\nelse\ncout << \"not found\";\nreturn 0;\n}\n```",
            "answer": "&data[0], &data[4], key; data+1, data+4, key",
            "explanation": "[Referenz](https://www.geeksforgeeks.org/binary-search-algorithms-the-c-standard-template-library-stl/)",
            "hint": null,
            "correctAnswer": ["&data[0], &data[4], key", "data+1, data+4, key"],
            "options": [
              "&data[0], &data[5], key",
              "data, data+5, key",
              "&data[0], &data[4], key",
              "data+1, data+4, key"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b37f5960fdc655b19a6e05a0",
            "question": "Betrachten Sie das folgende Code-Segment. Was wird die Ausgabe sein?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main () {\nint data[] = {50, 30, 40, 10, 20};\nsort (&data[1], &data[4]);\nfor (int i = 0; i < 5; i++)\ncout << data[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "50 10 30 40 20",
            "explanation": "[Referenz](https://cplusplus.com/reference/algorithm/sort/)",
            "hint": null,
            "correctAnswer": ["50 10 30 40 20"],
            "options": ["10 20 30 40 50", "10 30 40 50 20", "50 10 30 40 20", "50 10 20 30 40"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a40ace0e3f6fdd39e44ea3b4",
            "question": "Betrachten Sie das folgende Code-Segment. Was wird die Ausgabe sein?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint element[5];\nfor(int i = 1; i <= 5; i++)\n*(element + i - 1) = i * 5;\nrotate(element, element + 4, element + 5);\nrotate(element, element + 1, element + 4);\nfor (int i = 0; i < 5; ++i)\ncout << element[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "5 10 15 25 20",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/algorithm/rotate)",
            "hint": null,
            "correctAnswer": ["5 10 15 25 20"],
            "options": ["5 10 15 20 25", "5 10 15 25 20", "20 10 15 25 5", "25 5 10 15 20"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0129c14a1ea2125d622e8b22",
            "question": "Betrachten Sie das folgende Code-Segment. Was wird die Ausgabe sein?\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nconst int size = 3, c = 65;\nvector<char> vc(size, 'A');\nfor (int i = 1; i <= 2; i++)\nvc.push_back(65 + i);\nvc.resize(10, 90);\nvc.resize(8);\nfor (int i = 0; i < vc.size(); i++)\ncout << vc[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "A A A B C Z Z Z",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/container/vector)",
            "hint": null,
            "correctAnswer": ["A A A B C Z Z Z"],
            "options": ["A A A B C Z Z Z", "A A B B C Z Z Z", "A A A B C Z Z", "A A A B C Z Z Z Z"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bbde852c9f0be2f772a85e0c",
            "question": "Betrachten Sie das folgende Code-Segment. Wählen Sie die passende Option, um die Lücke in ZEILE-1 zu füllen, sodass die Ausgabe des Codes lautet: a C++ Program.\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nint main(void) {\nstring s1 = \"C++ \";\nstring s2 = \"Program\";\n__________________;    //ZEILE-1\ncout << s1;\nreturn 0;\n}\n```",
            "answer": "s1 += s2; s1.append(s2)",
            "explanation": "[Referenz](https://www.geeksforgeeks.org/stdstringappend-in-c/)",
            "hint": null,
            "correctAnswer": ["s1 += s2", "s1.append(s2)"],
            "options": ["s1 += s2", "strcat(s1, s2)", "s1.append(s2)", "s1.insert(s2)"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1d00178ff3cf9c50f60a856f",
            "question": "Betrachten Sie das folgende Code-Segment. Füllen Sie die Lücke in ZEILE-1 aus, sodass die Ausgabe 5 2 3 4 5 ist\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint data[] = { 1, 2, 3, 4, 5 };\nfor (int i = 0; i < 1; i++) {\nint j = data[i];\nreplace(data, data + 5, j, *(_________________));    //ZEILE-1\n}\nfor (int i = 0; i < 5; ++i)\ncout << data[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "data + 4 - i",
            "explanation": "[Referenz](https://www.geeksforgeeks.org/stdstringreplace-stdstringreplace_if-c/)",
            "hint": null,
            "correctAnswer": ["data + 4 - i"],
            "options": ["data + 4 - i", "data + 5 - i", "data + i - 4", "data + i - 5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2993fe751fde23ac9c7816a6",
            "question": "Betrachten Sie das folgende Code-Segment. Was wird die Ausgabe sein?\n```cpp\n#include <iostream>\n#include <cstring>\n#include <stack>\nusing namespace std;\nint main(){\nchar str[10] = \"123456789\";\nstack<char> s1, s2;\nint i;\nfor(i = 0; i < strlen(str)/2; i++)\ns1.push(str[i]);\nfor(i=i-1; i < strlen(str); i++)\ns2.push(str[i]);\nwhile (!s1.empty()) {\ns2.push(s1.top()); s1.pop();\n}\nwhile (!s2.empty()) {\ncout << s2.top(); s2.pop();\n}\nreturn 0;\n}\n```",
            "answer": "1234987654",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/container/stack)",
            "hint": null,
            "correctAnswer": ["1234987654"],
            "options": ["1234987654", "123498765", "1234897654", "123459876"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f8da355056132fe2886c5971",
            "question": "Betrachten Sie das folgende Code-Segment. Welche Anweisung(en) ist/sind korrekt?\n```cpp\nint i = 5;\nconst int *p = &i;\nint * const q = &i;\nint const *r = &i;\nint const * const s = &i;\n*p = 10; //ANWEISUNG-1\n*q = 10; //ANWEISUNG-2\n*r = 10; //ANWEISUNG-3\n*s = 10; //ANWEISUNG-4\n```",
            "answer": "ANWEISUNG-2",
            "explanation": "[Referenz](https://www.geeksforgeeks.org/const-keyword-in-cpp/)",
            "hint": null,
            "correctAnswer": ["ANWEISUNG-2"],
            "options": ["ANWEISUNG-1", "ANWEISUNG-2", "ANWEISUNG-3", "ANWEISUNG-4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a1b0378e01d57238d08bfc7c",
            "question": "Betrachten Sie das folgende Programm. Was wird die Ausgabe/der Fehler sein?\n```cpp\n#include <iostream>\nusing namespace std;\nchar add(char c1 = 'a') { return c1; }\nchar add(char c1 = 'a', char c2 = 'b') { return c1 + c2 - 'a';}\nchar add(char c1 = 'a', int d1 = 100){ return c1 + d1 - 'a'; }\nchar add(char c1 = 'a', char c2 = 'b', char c3) { return c1 + c2 + c3 - 'a'; }\nint main() {\nchar c = add('o', 'k');\ncout << c << endl;\nreturn 0;\n}\n```",
            "answer": "Kompilierungsfehler: Standardargument fehlt für \"char add(char, char, char)\"; Kompilierungsfehler: Aufruf von Überladung \"add(char, char)\" ist mehrdeutig",
            "explanation": "[Referenz](https://learn.microsoft.com/en-us/cpp/cpp/function-overloading?view=msvc-170)",
            "hint": null,
            "correctAnswer": [
              "Kompilierungsfehler: Standardargument fehlt für \"char add(char, char, char)\"",
              "Kompilierungsfehler: Aufruf von Überladung \"add(char, char)\" ist mehrdeutig"
            ],
            "options": [
              "y",
              "z",
              "Kompilierungsfehler: Standardargument fehlt für \"char add(char, char, char)\"",
              "Kompilierungsfehler: Aufruf von Überladung \"add(char, char)\" ist mehrdeutig"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "000820c663789dac3fefd580",
            "question": "Betrachten Sie das folgende Code-Segment. Was wird die Ausgabe sein?\n```cpp\n#include <iostream>\nusing namespace std;\n#define SQR(x) (x)*(x)\nint main() {\nint a=3;\ncout << SQR(a++) << endl;\nreturn 0;\n}\n```",
            "answer": "12",
            "explanation": "[Referenz](https://www.geeksforgeeks.org/output-of-the-program-use-macros-carefully/)",
            "hint": null,
            "correctAnswer": ["12"],
            "options": ["12", "25", "9", "16"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bfbaa5d98539fa9451813d66",
            "question": "Betrachten Sie das folgende Code-Segment. Welche Zeile(n) wird/werden Ihnen einen Fehler geben?\n```cpp\n#include<iostream>\n#define X 1\nusing namespace std;\nint main(){\nint i;\nconst int i1 = 2;\nconst int i2 = i1; //ZEILE-1\ni2 = X;\ni = i1;\ni1 = i;\nreturn 0;\n//ZEILE-2\n//ZEILE-3\n//ZEILE-4\n}\n```",
            "answer": "ZEILE-2; ZEILE-4",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["ZEILE-2", "ZEILE-4"],
            "options": ["ZEILE-1", "ZEILE-2", "ZEILE-3", "ZEILE-4"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "08307d37e64dfd93b07cc3e6",
            "question": "Betrachten Sie das folgende Code-Segment. Was wird die Ausgabe/der Fehler sein?\n```cpp\n#include<iostream>\nusing namespace std;\nint main(){\nint a = 5;\nint &b = a+1;\na = a*b;\ncout << a << \" \" << b;\nreturn 0;\n}\n```",
            "answer": "Kompilierungsfehler: ungültige Initialisierung einer Nicht-const-Referenz",
            "explanation": "#Detaillierte Erklärung:\nDer Fehler tritt auf, weil versucht wird, eine Referenz auf einen temporären Wert zu erstellen. In der Zeile int &b = a+1; versuchen wir, eine Referenz b auf das Ergebnis des Ausdrucks a + 1 zu erstellen, was ein temporärer Wert ist. Referenzen müssen an ein tatsächliches Objekt gebunden werden, nicht an einen temporären Wert oder einen Ausdruck, der keine Speicheradresse hat.",
            "hint": null,
            "correctAnswer": [
              "Kompilierungsfehler: ungültige Initialisierung einer Nicht-const-Referenz"
            ],
            "options": [
              "36",
              "30",
              "25",
              "Kompilierungsfehler: ungültige Initialisierung einer Nicht-const-Referenz"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "059ee6780e03d9ebbda36e70",
            "question": "Betrachten Sie das folgende Code-Segment. Was wird die Ausgabe sein?\n```cpp\n#include <iostream>\nusing namespace std;\nint& func(int& i) {     //ZEILE-1\nreturn i = i+5;\n}\nint main() {\nint x = 1, y = 2;\nint& z = func(x);\ncout << x << \" \" << z << \" \";\nfunc(x) = y;\ncout << x << \" \" << z;\nreturn 0;\n}\n```",
            "answer": "6 6 2 2",
            "explanation": "[Referenz](https://www.ibm.com/docs/en/zos/2.4.0?topic=calls-pass-by-reference-c-only)",
            "hint": null,
            "correctAnswer": ["6 6 2 2"],
            "options": ["6 6 2 2", "6 6 7 7", "1 1 2 2", "1 1 7 7"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cea9c0fc498ddb6da0883bc2",
            "question": "Betrachten Sie das folgende Code-Segment. Wählen Sie die passende Option, um die Lücken in ZEILE-1 zu füllen, sodass die Ausgabe des Codes lautet: 300 20000.\n```cpp\n#include <iostream>\nusing namespace std;\nvoid compute(int n1, int n2, ________, ________){ //ZEILE-1\nn3 = n1 + n2;\n*n4 = n1 * n2;\n}\nint main(){\nint a = 100, b = 200, c = 0, d = 0;\ncompute(a, b, c, &d); //ZEILE-2\ncout << c << \", \";\ncout << d;\nreturn 0;\n}\n```",
            "answer": "int& n3, int \\*n4",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["int& n3, int \\*n4"],
            "options": [
              "int n3, int\\* n4",
              "int& n3, int \\*n4",
              "int* n3, int* n4",
              "int& n3, int& n4"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2cec37af8a607644ec6b93a5",
            "question": "Betrachten Sie das folgende Code-Segment. Was wird die Ausgabe/der Fehler sein?\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\nint a = 2, *b;\n*b = 5;\nint * const ptr;    // ZEILE-1\n// ZEILE-2\nptr = b;\ncout << *ptr;\nreturn 0;\n}\n```",
            "answer": "Kompilierungsfehler bei ZEILE-1: nicht initialisiertes const 'ptr'; Kompilierungsfehler bei ZEILE-2: Zuweisung der schreibgeschützten Variable 'ptr'",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Kompilierungsfehler bei ZEILE-1: nicht initialisiertes const 'ptr'",
              "Kompilierungsfehler bei ZEILE-2: Zuweisung der schreibgeschützten Variable 'ptr'"
            ],
            "options": [
              "`<Müllwert>`",
              "5",
              "Kompilierungsfehler bei ZEILE-1: nicht initialisiertes const 'ptr'",
              "Kompilierungsfehler bei ZEILE-2: Zuweisung der schreibgeschützten Variable 'ptr'"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "92a0d9337841f321b65f258f",
            "question": "Betrachten Sie das folgende Code-Segment. Was wird die Ausgabe/der Fehler sein?\n```cpp\n#include <iostream>\nusing namespace std;\nvoid fun(int a = 5) { cout << a << endl; }\n//ZEILE-1\nint fun(int x = 10) { cout << x << endl; return 0; }    //ZEILE-2\nint main() {\nfun();\nreturn 0;\n}\n```",
            "answer": "Kompilierungsfehler bei ZEILE-2: mehrdeutige neue Deklaration von 'int fun(int)'",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Kompilierungsfehler bei ZEILE-2: mehrdeutige neue Deklaration von 'int fun(int)'"
            ],
            "options": [
              "5",
              "10",
              "5",
              "Kompilierungsfehler bei ZEILE-2: mehrdeutige neue Deklaration von 'int fun(int)'"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b9cef993ac59dee27f731775",
            "question": "Betrachten Sie das folgende Code-Segment. Füllen Sie die Lücke in ZEILE-1 aus, sodass das Programm 5 + i3 ausgibt\n```cpp\n#include<iostream>\nusing namespace std;\nstruct complex{\nint re, im;\nvoid show(){ cout << re << \" + i\" << im; }\n};\n______________________________________{ //Zeile-1\nc2.re = c1.re+c2.re;\nc2.im = c1.im+c2.im;\nreturn c2;\n}\nint main(){\nstruct complex c1={2,5},c2{3,-2};\nstruct complex t = c1 + c2;\nt.show();\nreturn 0;\n}\n```",
            "answer": "complex operator+(complex &c1, complex &c2)",
            "explanation": "[Referenz](https://www.w3schools.com/cpp/cpp_structs.asp)",
            "hint": null,
            "correctAnswer": ["complex operator+(complex &c1, complex &c2)"],
            "options": [
              "complex operator+(complex &c1, complex &c2)",
              "complex operator+(const complex &c1, const complex &c2)",
              "operator+(complex &c1, complex &c2)",
              "complex +(complex &c1, complex &c2)"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "83752263188c3a2c755cb091",
            "question": "Betrachten Sie das folgende Programm. Welche Zeile(n) wird/werden einen Fehler erzeugen?\n```cpp\n#include<iostream>\nusing namespace std;\nclass myClass{\nint pra = 5;\npublic:\nint pub = 10;\nvoid set_pr(int x){ pra = x; }\nvoid set_pu(int x){ pub = x; }\n};\nint main(){\nmyClass m;\nint a, b;\na = m.pra; //ZEILE-1\nb = m.pub; //ZEILE-2\nm.set_pr(100); //ZEILE-3\nm.set_pu(200); //ZEILE-4\nreturn 0;\n}\n```",
            "answer": "ZEILE-1",
            "explanation": "[Referenz](https://stackoverflow.com/questions/4855422/c-classes-public-private-and-protected)",
            "hint": null,
            "correctAnswer": ["ZEILE-1"],
            "options": ["ZEILE-1", "ZEILE-2", "ZEILE-3", "ZEILE-4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e0f8e8fd2c99a87a998c4667",
            "question": "Betrachten Sie die folgende Klasse. Füllen Sie die Lücken mit geeigneten Zugriffsspezifizierern aus, sodass Mitglied y von außerhalb der Klasse zugegriffen werden kann, aber Mitglied x nicht.\n```cpp\nclass Test{\n________:\nint x;\n________:\nint y;\n/* Weiterer Code */\n};\n```",
            "answer": "private, private",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["private, private"],
            "options": ["public, public", "public, private", "private, public", "private, private"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d82a31cc00cba5c5bb8ae0ae",
            "question": "Welcher C++-Standard hat In-Class-Standard-Mitgliedsinitialisierungen hinzugefügt?",
            "answer": "C++11",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C++11"],
            "options": ["C++98", "C++11", "C++14", "C++17."],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4df323703948aca4c339265e",
            "question": "Können Sie auto-Typ-Ableitung für nicht-statische Datenmitglieder verwenden?",
            "answer": "Nein",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Nein"],
            "options": ["Ja, seit C++11", "Nein", "Ja, seit C++20"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f4f3ee3ce2282358d858f5c5",
            "question": "Müssen Sie ein static inline Datenmitglied in einer cpp-Datei definieren?",
            "answer": "Nein, die Definition erfolgt an derselben Stelle, an der ein static inline Mitglied deklariert wird.",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": [
              "Nein, die Definition erfolgt an derselben Stelle, an der ein static inline Mitglied deklariert wird."
            ],
            "options": [
              "Nein, die Definition erfolgt an derselben Stelle, an der ein static inline Mitglied deklariert wird.",
              "Ja, der Compiler benötigt die Definition in einer cpp-Datei.",
              "Ja, der Compiler benötigt eine Definition in allen Übersetzungseinheiten, die diese Variable verwenden."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cf6f4547f2a96b1ce8dc4792",
            "question": "Was ist die Ausgabe des folgenden Codes:\n```cpp\nstruct S {\n    int a { 10 };\n    int b { 42 };\n};\nS s { 1 };\nstd::cout << s.a << \", \" << s.b;\n```",
            "answer": "Ausgabe ist: 1, 42",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Ausgabe ist: 1, 42"],
            "options": ["Ausgabe ist: 1, 0", "Ausgabe ist: 10, 42", "Ausgabe ist: 1, 42"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9ec9c1e9f4088e74333674a9",
            "question": "Kann eine static inline Variable nicht-konstant sein?",
            "answer": "Ja, es ist einfach eine reguläre Variable.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Ja, es ist einfach eine reguläre Variable."],
            "options": [
              "Ja, es ist einfach eine reguläre Variable.",
              "Nein, inline Variablen müssen konstant sein."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5808013535c7eeb15d093d68",
            "question": "Betrachten Sie den folgenden Code:\n```cpp\nstruct C {\n    C(int x) : a(x) { }\n    int a { 10 };\n    int b { 42 };\n};\nC c(0);\n```",
            "answer": "C::a wird nur einmal mit 0 im Konstruktor initialisiert.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C::a wird nur einmal mit 0 im Konstruktor initialisiert."],
            "options": [
              "C::a wird zweimal initialisiert. Das erste Mal wird es mit 10 initialisiert, dann das zweite Mal mit 0 im Konstruktor.",
              "C::a wird nur einmal mit 0 im Konstruktor initialisiert.",
              "Der Code kompiliert nicht, weil der Compiler nicht entscheiden kann, wie das Mitglied C::a initialisiert werden soll.",
              "2 Bytes"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "33f7cbb0f27f3a3ed5407356",
            "question": "Was passiert, wenn Sie eine Ausnahme aus einem Konstruktor werfen?",
            "answer": "Das Objekt wird als \"teilweise erstellt\" betrachtet, und daher wird der Compiler seinen Destruktor nicht aufrufen.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Das Objekt wird als \"teilweise erstellt\" betrachtet, und daher wird der Compiler seinen Destruktor nicht aufrufen."
            ],
            "options": [
              "Das Objekt wird als \"erstellt\" betrachtet, sodass es dem regulären Lebenszyklus eines Objekts folgt.",
              "Das Objekt wird als \"teilweise erstellt\" betrachtet, und daher wird der Compiler seinen Destruktor nicht aufrufen.",
              "Der Compiler ruft std::terminate auf, da Sie keine Ausnahmen aus Konstruktoren werfen können."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "73d753474f09b3252f705e04",
            "question": "Was passiert, wenn Sie diesen Code kompilieren?\n```cpp\nstruct Point { int x; int y; };\nPoint pt {.y = 10, .x = 11 };\nstd::cout << pt.x << \", \" << pt.y;\n```",
            "answer": "Der Code kompiliert nicht. Designatoren müssen in derselben Reihenfolge wie die Datenmitglieder in der Point-Klasse sein.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Der Code kompiliert nicht. Designatoren müssen in derselben Reihenfolge wie die Datenmitglieder in der Point-Klasse sein."
            ],
            "options": [
              "Der Code kompiliert nicht. Designatoren müssen in derselben Reihenfolge wie die Datenmitglieder in der Point-Klasse sein.",
              "Der Code kompiliert und gibt 11, 10 aus.",
              "Der Code kompiliert und gibt 10, 11 aus."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b1093ed6c8c3a84176548bf0",
            "question": "Wird dieser Code in C++11 funktionieren?\n```cpp\nstruct User { std::string name = \"unknown\"; unsigned age { 0 }; };\nUser u { \"John\", 101 };\n```",
            "answer": "Der Code kompiliert ab C++14-Modus.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Der Code kompiliert ab C++14-Modus."],
            "options": [
              "Ja, der Code kompiliert im C++11-Modus.",
              "Der Code kompiliert ab C++14-Modus.",
              "Der Code kompiliert auch in C++20 nicht."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "16a0ede1ba0ce320e47e7ecd",
            "question": "Angenommen, Sie haben ein std::map<string, int> m;. Wählen Sie die einzige wahre Aussage über die folgende Schleife:\n```cpp\nfor (const pair<string, int>& elem : m)\n```",
            "answer": "A Die Schleife iteriert ordnungsgemäß über die Map und erstellt keine zusätzlichen Kopien.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "A Die Schleife iteriert ordnungsgemäß über die Map und erstellt keine zusätzlichen Kopien."
            ],
            "options": [
              "A Die Schleife iteriert ordnungsgemäß über die Map und erstellt keine zusätzlichen Kopien.",
              "B Die Schleife erstellt eine Kopie jedes Elements in der Map, da der Typ von elem nicht übereinstimmt.",
              "C Der Code kompiliert nicht, da ein const pair nicht an eine Map gebunden werden kann."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d432d32ea660c27302b6ffb9",
            "question": "Identifizieren Sie die korrekte Erweiterung der benutzerdefinierten Header-Datei in C++.",
            "answer": ".h",
            "explanation": null,
            "hint": null,
            "correctAnswer": [".h"],
            "options": [".cpp", ".hg", ".h", ".hf"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "78ca2b8e52e05c4946264d90",
            "question": "Identifizieren Sie den falschen Konstruktortyp.\n```cpp\nauto x = 4000.22;\n```",
            "answer": "Friend-Konstruktor",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Friend-Konstruktor"],
            "options": [
              "Friend-Konstruktor",
              "Standard-Konstruktor",
              "Parametrisierter Konstruktor",
              "Kopierkonstruktor"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1fa33dc6b90708fc2df9b608",
            "question": "Welcher der folgenden Datentypen wird in C++ unterstützt, aber nicht in C?",
            "answer": "bool",
            "explanation": "[Referenz]: https://stackoverflow.com/questions/1608318/is-bool-a-native-c-type",
            "hint": null,
            "correctAnswer": ["bool"],
            "options": ["bool", "int", "double", "float"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a8fee99a75feebe01d841d7d",
            "question": "Identifizieren Sie die korrekte Syntax zum Deklarieren von Arrays in C++.",
            "answer": "int arr[10]",
            "explanation": "[Referenz]: (https://en.cppreference.com/w/cpp/language/array)",
            "hint": null,
            "correctAnswer": ["int arr[10]"],
            "options": ["int arr[10]", "array arr[10]", "array{10}", "int arr"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f659570c6519ecbb9f49ed3f",
            "question": "Die Größe von wchat_t ist.",
            "answer": "Hängt von der Anzahl der Bits im System ab",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Hängt von der Anzahl der Bits im System ab"],
            "options": ["2", "4", "2 oder 4", "Hängt von der Anzahl der Bits im System ab"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "71c2c771521f49c97ccdbf96",
            "question": "Welche der folgenden Schleifen ist am besten, wenn wir die Anzahl der Iterationen kennen?",
            "answer": "for",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["for"],
            "options": ["while", "for", "do", "Alle oben genannten"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6ace48344805b64dddc663f8",
            "question": "Welches Schlüsselwort wird verwendet, um Makros in C++ zu definieren?",
            "answer": "#define",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["#define"],
            "options": ["#macro", "#define", "macro", "keyword"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c802232ade788b6119fc16db",
            "question": "Welche der folgenden Operatoren sollte vorzugsweise als globale Funktion anstelle einer Mitgliedsmethode überladen werden?",
            "answer": "Vergleichsoperator",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Vergleichsoperator"],
            "options": ["Postfix ++", "Vergleichsoperator", "Einfügeoperator <<", "Präfix++"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b476f44a6ff264a9365f68b0",
            "question": "Wie können wir die dynamische Zuweisung von Objekten einer Klasse mit new einschränken?",
            "answer": "Durch Erstellen leerer privater new- und new[]-Operatoren",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Durch Erstellen leerer privater new- und new[]-Operatoren"],
            "options": [
              "Durch Überladen des new-Operators",
              "Durch Erstellen eines leeren privaten new-Operators.",
              "Durch Erstellen leerer privater new- und new[]-Operatoren",
              "Durch Überladen von new-Operatoren und new[]-Operatoren"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "602ae0a8eb0752a4f45b211c",
            "question": "Was ist die Zeitkomplexität des folgenden Codes?\n```cpp\nfor(int i=0;i<n;i++){\n   for(int j=0;j<n;j++){\n       cout<<\"hello\";\n    }\n}\n```",
            "answer": "O(n^2)",
            "explanation": "[Referenz](<https://medium.com/enjoy-algorithm/analysis-of-loop-in-programming-cc9a644ef8cd#:~:text=At%20each%20step%20of%20the%20iteration%2C%20the%20nested%20loop%20is,%20%3D%20O(n%C2%B2)>)",
            "hint": null,
            "correctAnswer": ["O(n^2)"],
            "options": ["O(n^3)", "O(n^2)", "O(n)", "O(1)"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cc636a9cfee0924e4f7af54c",
            "question": "Was ist die Ausgabe des unten angegebenen Codes?\n```cpp\nint a=10;\nint k=++a;\nint m=a++;\ncout<<k+m;\n```",
            "answer": "22",
            "explanation": "Sowohl **++a** als auch **a++** erhöhen den Wert von a um 1 (d.h.: 11) und daher wird k+m zu 22.",
            "hint": null,
            "correctAnswer": ["22"],
            "options": ["20", "21", "22", "23"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7bbb72da54d81d21c5ae0604",
            "question": "Welches C++-Konstrukt wird für die Ausnahmebehandlung verwendet?",
            "answer": "try-catch",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["try-catch"],
            "options": ["try-catch", "if-else", "for-Schleife", "switch-case"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b32f12a3a6504839c9bf8735",
            "question": "Was ist der Zweck der `break`-Anweisung in einer Schleife in C++?",
            "answer": "Die Schleife beenden",
            "explanation": "[Referenz]: (https://www.tutorialspoint.com/cprogramming/c_break_statement.htm)",
            "hint": null,
            "correctAnswer": ["Die Schleife beenden"],
            "options": [
              "Das Programm beenden",
              "Die aktuelle Iteration überspringen und mit der nächsten fortfahren",
              "Die Schleife beenden",
              "Einen Wert zurückgeben"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9c944144956c77be3b684b86",
            "question": "Was ist in C++ der Zweck des `const`-Schlüsselworts, wenn es mit einer Variablen verwendet wird?",
            "answer": "Es macht die Variable unveränderlich",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Es macht die Variable unveränderlich"],
            "options": [
              "Es macht die Variable unveränderlich",
              "Es ändert den Datentyp",
              "Es definiert eine konstante Funktion",
              "Es macht die Variable zu einem Zeiger"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8c17bd30119072582cdcc65a",
            "question": "Was ist effektiver beim Aufrufen von C++-Funktionen?",
            "answer": "Call by reference",
            "explanation": "[Referenz]: (https://www.algbly.com/More/MCQs/Cpp-mcq/Cpp-functions.html)",
            "hint": null,
            "correctAnswer": ["Call by reference"],
            "options": ["Call by reference", "Call by value", "Call by pointer", "Call by object"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "488d15bd825a977477974ece",
            "question": "Was wird die Ausgabe des folgenden C++-Programms sein?\n```cpp\n#include <iostream>\nusing namespace std;\nclass A{\npublic:\n\tA(){\n\t\tcout<<\"Constructor called\\n\";\n\t   }\n\t~A(){\n\t\tcout<<\"Destructor called\\n\";\n\t    }\n};\nint main(int argc, char const *argv[])\n{\n\tA *a = new A[5];\n\tdelete[] a;\n\treturn 0;\n}\n```",
            "answer": "\"Constructor called\" fünfmal und dann \"Destructor called\" fünfmal",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "\"Constructor called\" fünfmal und dann \"Destructor called\" fünfmal"
            ],
            "options": [
              "Segmentierungsfehler",
              "\"Constructor called\" fünfmal und dann \"Destructor called\" fünfmal",
              "\"Constructor called\" fünfmal und dann \"Destructor called\" einmal",
              "Fehler"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "421fab9f4f934964316ee8c3",
            "question": "Welche Wahl steht _nicht_ im Zusammenhang mit der Deklaration der Mitgliedsvariablen count als static in my_class?\n```cpp\nclass my_class{\n    public: static int count;\n}\n```",
            "answer": "Die Variable kann von keinem Teil des Codes in derselben Anwendung oder Thread modifiziert werden. Andere Threads können sie jedoch modifizieren.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Die Variable kann von keinem Teil des Codes in derselben Anwendung oder Thread modifiziert werden. Andere Threads können sie jedoch modifizieren."
            ],
            "options": [
              "Alle Objekte, die versuchen, auf ihre count-Mitgliedsvariable zuzugreifen, verweisen tatsächlich auf die einzige klassengebundene statische count-Variable.",
              "Die Variable existiert auch dann, wenn keine Objekte der Klasse definiert wurden, sodass sie an jedem Punkt im Quellcode modifiziert werden kann.",
              "Die Variable kann von keinem Teil des Codes in derselben Anwendung oder Thread modifiziert werden. Andere Threads können sie jedoch modifizieren.",
              "Die Variable wird nur einmal zugewiesen, unabhängig davon, wie viele Objekte instanziiert werden, da sie an die Klasse selbst gebunden ist, nicht an ihre Instanzen."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0cfdf77aae0f7cc44551db46",
            "question": "Was ist der Zweck des `constexpr`-Schlüsselworts in C++?",
            "answer": "`constexpr` wird verwendet, um anzuzeigen, dass ein Ausdruck zur Kompilierzeit ausgewertet werden kann, wodurch er für die Verwendung in konstanten Ausdrücken geeignet ist.",
            "explanation": "[Ref](https://learn.microsoft.com/en-us/cpp/cpp/constexpr-cpp?view=msvc-170#:~:text=constexpr%20indicates%20that%20the%20value,template%20arguments%20and%20array%20declarations.)",
            "hint": null,
            "correctAnswer": [
              "`constexpr` wird verwendet, um anzuzeigen, dass ein Ausdruck zur Kompilierzeit ausgewertet werden kann, wodurch er für die Verwendung in konstanten Ausdrücken geeignet ist."
            ],
            "options": [
              "Es wird verwendet, um Konstanten in C++ zu definieren.",
              "`constexpr` wird verwendet, um anzugeben, dass eine Variable ein konstanter Zeiger ist.",
              "`constexpr` wird verwendet, um anzuzeigen, dass ein Ausdruck zur Kompilierzeit ausgewertet werden kann, wodurch er für die Verwendung in konstanten Ausdrücken geeignet ist.",
              "Es ist ein Schlüsselwort, das zum Erstellen asynchroner Funktionen verwendet wird."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "006230f3ba4978b109dd0a8b",
            "question": "Was ist ein Template-Metaprogramm in C++?\n- Ref(https://www.geeksforgeeks.org/template-metaprogramming-in-c/)",
            "answer": "Ein Template-Metaprogramm ist eine Kompilierzeitberechnung, bei der Templates und Template-Spezialisierung verwendet werden, um Berechnungen zur Kompilierzeit durchzuführen.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Ein Template-Metaprogramm ist eine Kompilierzeitberechnung, bei der Templates und Template-Spezialisierung verwendet werden, um Berechnungen zur Kompilierzeit durchzuführen."
            ],
            "options": [
              "Ein Template-Metaprogramm ist eine hochrangige Programmiersprache.",
              "Es bezieht sich auf Metaprogrammierung, die Templates in C++ verwendet.",
              "Es ist eine Art Benutzeroberflächen-Designmuster.",
              "Ein Template-Metaprogramm ist eine Kompilierzeitberechnung, bei der Templates und Template-Spezialisierung verwendet werden, um Berechnungen zur Kompilierzeit durchzuführen."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c85fd383610068b1791836d9",
            "question": "Identifizieren Sie das korrekte Beispiel für einen Prä-Inkrement-Operator.",
            "answer": "++i",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["++i"],
            "options": ["++i", "i++", "--i", "+i"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "73bbaff55d041ddc149b6461",
            "question": "Was wird die Ausgabe des folgenden Codes sein?\n```cpp\n{% raw %}\nint matrix[3][3] = {{1, 2, 3},{4, 5, 6},{7, 8, 9}};\nfor(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n        int a = matrix[i][j];\n        matrix[i][j] = matrix[j][i];\n        matrix[j][i] = a;\n    }\n}\n{% endraw %}\n```",
            "answer": "Dieselbe Matrix",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Dieselbe Matrix"],
            "options": [
              "Transponierte der Matrix",
              "Dieselbe Matrix",
              "Spiegelbild der Matrix",
              "Invertierte Matrix"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2691b0cf441e54d1085f6d45",
            "question": "Was ist eine Race Condition in C++?",
            "answer": "Eine Bedingung, bei der mehrere Threads gleichzeitig auf gemeinsame Daten zugreifen und das Ergebnis vom Timing ihrer Ausführung abhängt",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/language/memory_model)",
            "hint": null,
            "correctAnswer": [
              "Eine Bedingung, bei der mehrere Threads gleichzeitig auf gemeinsame Daten zugreifen und das Ergebnis vom Timing ihrer Ausführung abhängt"
            ],
            "options": [
              "Eine Bedingung, bei der das Programm schneller als erwartet läuft",
              "Eine Bedingung, bei der mehrere Threads gleichzeitig auf gemeinsame Daten zugreifen und das Ergebnis vom Timing ihrer Ausführung abhängt",
              "Eine Bedingung, bei der zwei Threads um CPU-Zeit konkurrieren",
              "Eine Bedingung, bei der eine Schleife zu schnell ausgeführt wird und verlangsamt werden muss"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "11ec15b9a8e0a426da32ddd9",
            "question": "Betrachten Sie den folgenden Code, der eine Race Condition hat. Was ist der richtige Weg, ihn zu beheben?\n```cpp\n#include <thread>\n#include <vector>\nint counter = 0;\nvoid incrementCounter() {\n    for(int i = 0; i < 1000; i++) {\n        counter++;\n    }\n}\nint main() {\n    std::vector<std::thread> threads;\n    for(int i = 0; i < 10; i++) {\n        threads.push_back(std::thread(incrementCounter));\n    }\n    for(auto& t : threads) {\n        t.join();\n    }\n    return 0;\n}\n```",
            "answer": "`std::mutex` verwenden, um um `counter++` im kritischen Abschnitt zu sperren/entsperren",
            "explanation": "[Referenz](https://en.cppreference.com/w/cpp/thread/mutex)",
            "hint": null,
            "correctAnswer": [
              "`std::mutex` verwenden, um um `counter++` im kritischen Abschnitt zu sperren/entsperren"
            ],
            "options": [
              "`volatile`-Schlüsselwort hinzufügen: `volatile int counter = 0;`",
              "`std::mutex` verwenden, um um `counter++` im kritischen Abschnitt zu sperren/entsperren",
              "`std::this_thread::sleep_for()` verwenden, um jedes Inkrement zu verzögern",
              "`counter++` zu `++counter` ändern für atomare Operation"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cdbb2c429c191353afd05b39",
            "question": "Was ist der Zweck von `std::move` in C++11?",
            "answer": "Ein Objekt in eine Rvalue-Referenz umzuwandeln, um Move-Semantik zu ermöglichen",
            "explanation": "**Erklärung:**\n`std::move` ist eine Umwandlung, die eine Rvalue-Referenz auf ihr Argument erzeugt und ermöglicht, dass Ressourcen verschoben statt kopiert werden. Es verschiebt selbst nichts, sondern ermöglicht den Aufruf von Move-Konstruktoren und Move-Zuweisungsoperatoren.\n[Referenz](https://en.cppreference.com/w/cpp/utility/move)",
            "hint": null,
            "correctAnswer": [
              "Ein Objekt in eine Rvalue-Referenz umzuwandeln, um Move-Semantik zu ermöglichen"
            ],
            "options": [
              "Ein Objekt an einen neuen Speicherort zu kopieren",
              "Ein Objekt in eine Rvalue-Referenz umzuwandeln, um Move-Semantik zu ermöglichen",
              "Speicher physisch von einer Adresse zu einer anderen zu verschieben",
              "Ein Objekt zu löschen und ein neues zu erstellen"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "00d2a9a1da3bbec3efb185e5",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\n#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v1 = {1, 2, 3};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v1.size() << \" \" << v2.size();\n    return 0;\n}\n```",
            "answer": "0 3",
            "explanation": "**Erklärung:**\nNach `std::move(v1)` befindet sich v1 in einem gültigen, aber nicht spezifizierten Zustand. Typischerweise wird es leer (Größe 0) und v2 übernimmt den Besitz der Elemente.\n[Referenz](https://en.cppreference.com/w/cpp/utility/move)",
            "hint": null,
            "correctAnswer": ["0 3"],
            "options": ["3 3", "0 3", "3 0", "Kompilierungsfehler"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "23497765b181320873bd5a8e",
            "question": "Was ist ein Lambda-Ausdruck in C++?",
            "answer": "Ein anonymes Funktionsobjekt, das Variablen aus seinem umgebenden Bereich erfassen kann",
            "explanation": "**Erklärung:**\nLambda-Ausdrücke, eingeführt in C++11, ermöglichen das Schreiben von Inline-anonymen Funktionen. Sie können Variablen aus dem umgebenden Bereich erfassen und werden oft mit STL-Algorithmen verwendet.\n[Referenz](https://en.cppreference.com/w/cpp/language/lambda)",
            "hint": null,
            "correctAnswer": [
              "Ein anonymes Funktionsobjekt, das Variablen aus seinem umgebenden Bereich erfassen kann"
            ],
            "options": [
              "Eine mathematische Funktion",
              "Ein anonymes Funktionsobjekt, das Variablen aus seinem umgebenden Bereich erfassen kann",
              "Eine Template-Funktion",
              "Eine Makro-Definition"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e628824ca866b2b273614304",
            "question": "Was macht das Schlüsselwort `auto` in C++11?",
            "answer": "Leitet automatisch den Typ einer Variablen aus ihrem Initialisierer ab",
            "explanation": "**Erklärung:**\nDas Schlüsselwort `auto` in C++11 ermöglicht die automatische Typableitung aus dem Initialisierer, was den Code prägnanter und wartungsfreundlicher macht.\n[Referenz](https://en.cppreference.com/w/cpp/language/auto)",
            "hint": null,
            "correctAnswer": [
              "Leitet automatisch den Typ einer Variablen aus ihrem Initialisierer ab"
            ],
            "options": [
              "Gibt einer Variablen automatische Speicherdauer",
              "Leitet automatisch den Typ einer Variablen aus ihrem Initialisierer ab",
              "Macht eine Funktion inline",
              "Deklariert eine globale Variable"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "94a218ed5cd31a3f4d168e96",
            "question": "Was ist der Unterschied zwischen `std::unique_ptr` und `std::shared_ptr`?",
            "answer": "unique_ptr hat exklusiven Besitz, shared_ptr erlaubt mehrere Besitzer",
            "explanation": "**Erklärung:**\n`std::unique_ptr` bietet exklusiven Besitz - nur ein unique_ptr kann eine Ressource besitzen. `std::shared_ptr` verwendet Referenzzählung, um mehreren shared_ptrs den Besitz derselben Ressource zu ermöglichen.\n[Referenz](https://en.cppreference.com/w/cpp/memory/unique_ptr)",
            "hint": null,
            "correctAnswer": [
              "unique_ptr hat exklusiven Besitz, shared_ptr erlaubt mehrere Besitzer"
            ],
            "options": [
              "unique_ptr hat exklusiven Besitz, shared_ptr erlaubt mehrere Besitzer",
              "unique_ptr ist schneller, aber weniger sicher",
              "shared_ptr kann nur mit Klassen verwendet werden",
              "Es gibt keinen Unterschied"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "516779098a96214014ceac89",
            "question": "Was ist RAII in C++?",
            "answer": "Resource Acquisition Is Initialization (Ressourcenerwerb ist Initialisierung)",
            "explanation": "**Erklärung:**\nRAII ist ein C++-Programmieridiom, bei dem der Ressourcenerwerb an die Objektlebensdauer gebunden ist. Ressourcen werden in Konstruktoren erworben und in Destruktoren freigegeben, was eine ordnungsgemäße Bereinigung sicherstellt.\n[Referenz](https://en.cppreference.com/w/cpp/language/raii)",
            "hint": null,
            "correctAnswer": [
              "Resource Acquisition Is Initialization (Ressourcenerwerb ist Initialisierung)"
            ],
            "options": [
              "Random Access Iterator Interface",
              "Resource Acquisition Is Initialization (Ressourcenerwerb ist Initialisierung)",
              "Recursive Algorithm Implementation Interface",
              "Runtime Allocation and Initialization"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d345d8c7cc890beed0fb541b",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    auto lambda = [x]() mutable { x += 10; return x; };\n    std::cout << lambda() << \" \" << x;\n    return 0;\n}\n```",
            "answer": "15 5",
            "explanation": "**Erklärung:**\nDas Lambda erfasst x per Wert. Das Schlüsselwort `mutable` erlaubt die Änderung der erfassten Kopie. Das ursprüngliche x bleibt unverändert.\n[Referenz](https://en.cppreference.com/w/cpp/language/lambda)",
            "hint": null,
            "correctAnswer": ["15 5"],
            "options": ["5 5", "15 5", "15 15", "5 15"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1b463d081de9308a8b6c0605",
            "question": "Was ist `constexpr` in C++11?",
            "answer": "Spezifiziert, dass eine Funktion oder Variable zur Kompilierzeit ausgewertet werden kann",
            "explanation": "**Erklärung:**\n`constexpr` gibt an, dass ein Wert oder eine Funktion zur Kompilierzeit ausgewertet werden kann, was Kompilierzeitberechnungen und Optimierungen ermöglicht.\n[Referenz](https://en.cppreference.com/w/cpp/language/constexpr)",
            "hint": null,
            "correctAnswer": [
              "Spezifiziert, dass eine Funktion oder Variable zur Kompilierzeit ausgewertet werden kann"
            ],
            "options": [
              "Ein konstanter Ausdruck, der nur mit ganzen Zahlen verwendet werden kann",
              "Spezifiziert, dass eine Funktion oder Variable zur Kompilierzeit ausgewertet werden kann",
              "Ein Makro zur Definition von Konstanten",
              "Ein Schlüsselwort zur Deklaration konstanter Zeiger"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f1381f873bb09733aad4ccb7",
            "question": "Was ist der Zweck von `std::forward`?",
            "answer": "Die Wertkategorie (Lvalue/Rvalue) eines weitergeleiteten Arguments zu bewahren",
            "explanation": "**Erklärung:**\n`std::forward` wird in Template-Funktionen verwendet, um Argumente perfekt weiterzuleiten und dabei ihre Wertkategorie zu bewahren, was für die Implementierung der perfekten Weiterleitung wesentlich ist.\n[Referenz](https://en.cppreference.com/w/cpp/utility/forward)",
            "hint": null,
            "correctAnswer": [
              "Die Wertkategorie (Lvalue/Rvalue) eines weitergeleiteten Arguments zu bewahren"
            ],
            "options": [
              "Ein Objekt im Speicher nach vorne zu verschieben",
              "Die Wertkategorie (Lvalue/Rvalue) eines weitergeleiteten Arguments zu bewahren",
              "Vorwärts durch einen Container zu iterieren",
              "Eine Vorwärtsdeklaration zu deklarieren"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ffa567c24f61d8d13a2db5a8",
            "question": "Was ist ein variadisches Template?",
            "answer": "Ein Template, das eine variable Anzahl von Template-Parametern akzeptiert",
            "explanation": "**Erklärung:**\nVariadische Templates, eingeführt in C++11, ermöglichen Templates, eine beliebige Anzahl von Template-Argumenten zu akzeptieren, was flexible generische Programmierung ermöglicht.\n[Referenz](https://en.cppreference.com/w/cpp/language/parameter_pack)",
            "hint": null,
            "correctAnswer": [
              "Ein Template, das eine variable Anzahl von Template-Parametern akzeptiert"
            ],
            "options": [
              "Ein Template mit variierenden Rückgabetypen",
              "Ein Template, das eine variable Anzahl von Template-Parametern akzeptiert",
              "Ein Template, das mehrfach instanziiert werden kann",
              "Ein Template mit optionalen Parametern"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "18591ba82c40ca3118e9ab43",
            "question": "Was repräsentiert `nullptr`?",
            "answer": "Eine Nullzeiger-Konstante mit dem Typ std::nullptr_t",
            "explanation": "**Erklärung:**\n`nullptr` ist ein Schlüsselwort, das in C++11 eingeführt wurde und einen Nullzeiger repräsentiert. Es ist typsicher im Gegensatz zu NULL oder 0.\n[Referenz](https://en.cppreference.com/w/cpp/language/nullptr)",
            "hint": null,
            "correctAnswer": ["Eine Nullzeiger-Konstante mit dem Typ std::nullptr_t"],
            "options": [
              "Ein Null-Zeichen",
              "Eine Nullzeiger-Konstante mit dem Typ std::nullptr_t",
              "Eine leere Zeichenkette",
              "Nullwert"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "31f4f79946381223db87fea8",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\n#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> p1 = std::make_shared<int>(42);\n    std::shared_ptr<int> p2 = p1;\n    std::cout << p1.use_count();\n    return 0;\n}\n```",
            "answer": "2",
            "explanation": "**Erklärung:**\nSowohl p1 als auch p2 teilen sich den Besitz derselben ganzen Zahl, daher ist die Referenzzahl 2.\n[Referenz](https://en.cppreference.com/w/cpp/memory/shared_ptr)",
            "hint": null,
            "correctAnswer": ["2"],
            "options": ["1", "2", "42", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4b8086694dfcf96f25c16d1a",
            "question": "Was ist `std::optional` in C++17?",
            "answer": "Ein Wrapper, der möglicherweise einen Wert enthält oder nicht",
            "explanation": "**Erklärung:**\n`std::optional` ist eine Template-Klasse, die einen optionalen Wert repräsentiert - sie enthält entweder einen Wert oder ist leer und bietet eine typsichere Möglichkeit, \"kein Wert\" darzustellen.\n[Referenz](https://en.cppreference.com/w/cpp/utility/optional)",
            "hint": null,
            "correctAnswer": ["Ein Wrapper, der möglicherweise einen Wert enthält oder nicht"],
            "options": [
              "Ein optionaler Parameter in einer Funktion",
              "Ein Wrapper, der möglicherweise einen Wert enthält oder nicht",
              "Ein Template für optionale Kompilierung",
              "Ein Schlüsselwort für optionale Typen"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ae2d295919a6f17c21516637",
            "question": "Was ist strukturierte Bindung in C++17?\n```cpp\nauto [x, y, z] = std::make_tuple(1, 2, 3);\n```",
            "answer": "Eine Funktion, die Tupel-ähnliche Objekte in einzelne Variablen entpackt",
            "explanation": "**Erklärung:**\nStrukturierte Bindungen ermöglichen das Zerlegen von Objekten in ihre Bestandteile, was den Code lesbarer macht, wenn man mit Tupeln, Paaren oder Strukturen arbeitet.\n[Referenz](https://en.cppreference.com/w/cpp/language/structured_binding)",
            "hint": null,
            "correctAnswer": [
              "Eine Funktion, die Tupel-ähnliche Objekte in einzelne Variablen entpackt"
            ],
            "options": [
              "Eine Möglichkeit, Strukturen miteinander zu verbinden",
              "Eine Funktion, die Tupel-ähnliche Objekte in einzelne Variablen entpackt",
              "Eine Methode zum Erstellen strukturierter Daten",
              "Eine Bindung für Strukturmitglieder"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "26fd417326d894c200c7e56c",
            "question": "Was ist `std::string_view` in C++17?",
            "answer": "Eine nicht-besitzende Referenz auf eine Zeichenkette, die Kopieren vermeidet",
            "explanation": "**Erklärung:**\n`std::string_view` bietet eine leichtgewichtige, nicht-besitzende Referenz auf eine Zeichenkette, vermeidet unnötige Kopien und verbessert die Leistung.\n[Referenz](https://en.cppreference.com/w/cpp/string/basic_string_view)",
            "hint": null,
            "correctAnswer": [
              "Eine nicht-besitzende Referenz auf eine Zeichenkette, die Kopieren vermeidet"
            ],
            "options": [
              "Eine Ansicht einer Zeichenkette in einer GUI",
              "Eine nicht-besitzende Referenz auf eine Zeichenkette, die Kopieren vermeidet",
              "Eine Zeichenkette, die nur angezeigt, nicht geändert werden kann",
              "Eine View-Klasse zur Anzeige von Zeichenketten"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "702e10cf07bf13e12c755aba",
            "question": "Was sind Konzepte in C++20?",
            "answer": "Benannte Anforderungssätze für Template-Parameter",
            "explanation": "**Erklärung:**\nKonzepte sind eine C++20-Funktion, die es ermöglicht, Einschränkungen für Template-Parameter zu spezifizieren, wodurch Template-Code lesbarer wird und bessere Fehlermeldungen bereitgestellt werden.\n[Referenz](https://en.cppreference.com/w/cpp/language/constraints)",
            "hint": null,
            "correctAnswer": ["Benannte Anforderungssätze für Template-Parameter"],
            "options": [
              "Abstrakte Ideen in der Programmierung",
              "Benannte Anforderungssätze für Template-Parameter",
              "Konzeptionelle Entwurfsmuster",
              "Dokumentationskommentare"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "04c30f662a1fa60aeac6b7d9",
            "question": "Was ist der Drei-Wege-Vergleichsoperator (<=>) in C++20?",
            "answer": "Ein Operator, der Ordnungsinformationen zurückgibt (kleiner, gleich, größer)",
            "explanation": "**Erklärung:**\nDer Spaceship-Operator (<=>) führt einen Drei-Wege-Vergleich durch und gibt eine Ordnungskategorie zurück, was die Definition von Vergleichsoperatoren vereinfacht.\n[Referenz](https://en.cppreference.com/w/cpp/language/operator_comparison)",
            "hint": null,
            "correctAnswer": [
              "Ein Operator, der Ordnungsinformationen zurückgibt (kleiner, gleich, größer)"
            ],
            "options": [
              "Ein Vergleich von drei Werten",
              "Ein Operator, der Ordnungsinformationen zurückgibt (kleiner, gleich, größer)",
              "Drei separate Vergleichsoperatoren",
              "Ein ternärer Vergleich"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "33319fdd5f892e315c404ca3",
            "question": "Was ist `std::span` in C++20?",
            "answer": "Eine nicht-besitzende Ansicht über eine zusammenhängende Sequenz von Objekten",
            "explanation": "**Erklärung:**\n`std::span` bietet eine Ansicht über eine zusammenhängende Sequenz von Objekten, ohne sie zu besitzen, nützlich zum Übergeben Array-ähnlicher Daten ohne Kopieren.\n[Referenz](https://en.cppreference.com/w/cpp/container/span)",
            "hint": null,
            "correctAnswer": [
              "Eine nicht-besitzende Ansicht über eine zusammenhängende Sequenz von Objekten"
            ],
            "options": [
              "Eine Zeitspannenmessung",
              "Eine nicht-besitzende Ansicht über eine zusammenhängende Sequenz von Objekten",
              "Eine Spanning-Tree-Datenstruktur",
              "Ein Span-Element in HTML"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0aa661af1d72f0c0eb35c9bf",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\n#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v = {1, 2, 3, 4, 5};\n    for (auto& x : v) {\n        x *= 2;\n    }\n    std::cout << v[2];\n    return 0;\n}\n```",
            "answer": "6",
            "explanation": "**Erklärung:**\nDie bereichsbasierte for-Schleife mit `auto&` ändert jedes Element direkt. v[2] (ursprünglich 3) wird zu 6.\n[Referenz](https://en.cppreference.com/w/cpp/language/range-for)",
            "hint": null,
            "correctAnswer": ["6"],
            "options": ["3", "6", "2", "12"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "893cdd916cdea4f4134e6efb",
            "question": "Was ist `std::variant` in C++17?",
            "answer": "Eine typsichere Union, die einen von mehreren Typen enthalten kann",
            "explanation": "**Erklärung:**\n`std::variant` ist eine typsichere Union, die einen Wert von einem von mehreren angegebenen Typen enthalten kann und eine sicherere Alternative zu C-Unions bietet.\n[Referenz](https://en.cppreference.com/w/cpp/utility/variant)",
            "hint": null,
            "correctAnswer": ["Eine typsichere Union, die einen von mehreren Typen enthalten kann"],
            "options": [
              "Eine Variable, die variieren kann",
              "Eine typsichere Union, die einen von mehreren Typen enthalten kann",
              "Eine Variante einer Klasse",
              "Ein Variables-Template"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "68650ede1af965cedcf3f121",
            "question": "Was ist `std::any` in C++17?",
            "answer": "Ein typsicherer Container für einzelne Werte beliebigen Typs",
            "explanation": "**Erklärung:**\n`std::any` kann einen einzelnen Wert beliebigen kopierkonstruierbaren Typs speichern und bietet typsichere Speicherung mit Laufzeit-Typprüfung.\n[Referenz](https://en.cppreference.com/w/cpp/utility/any)",
            "hint": null,
            "correctAnswer": ["Ein typsicherer Container für einzelne Werte beliebigen Typs"],
            "options": [
              "Jede Art von Variable",
              "Ein typsicherer Container für einzelne Werte beliebigen Typs",
              "Ein Wildcard-Typ",
              "Ein optionaler Typ"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "81b756dd75195f4bedb90447",
            "question": "Was ist der Unterschied zwischen `std::array` und C-Style-Arrays?",
            "answer": "std::array kennt seine Größe und bietet Mitgliedsfunktionen",
            "explanation": "**Erklärung:**\n`std::array` ist ein Container, der Arrays fester Größe kapselt, Größeninformationen und STL-Container-Schnittstelle bietet und gleichzeitig die Leistung von C-Style-Arrays beibehält.\n[Referenz](https://en.cppreference.com/w/cpp/container/array)",
            "hint": null,
            "correctAnswer": ["std::array kennt seine Größe und bietet Mitgliedsfunktionen"],
            "options": [
              "std::array kennt seine Größe und bietet Mitgliedsfunktionen",
              "std::array ist langsamer",
              "C-Style-Arrays sind sicherer",
              "Es gibt keinen Unterschied"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e687c0d921af7b3648d782f9",
            "question": "Was ist perfekte Weiterleitung?",
            "answer": "Bewahren der Wertkategorie von Argumenten beim Übergeben an eine andere Funktion",
            "explanation": "**Erklärung:**\nPerfekte Weiterleitung verwendet `std::forward` und universelle Referenzen, um Argumente an eine andere Funktion weiterzugeben und dabei ihre Wertkategorie (Lvalue oder Rvalue) zu bewahren.\n[Referenz](https://en.cppreference.com/w/cpp/utility/forward)",
            "hint": null,
            "correctAnswer": [
              "Bewahren der Wertkategorie von Argumenten beim Übergeben an eine andere Funktion"
            ],
            "options": [
              "Weiterleitung ohne Fehler",
              "Bewahren der Wertkategorie von Argumenten beim Übergeben an eine andere Funktion",
              "Schnelle Parameterübergabe",
              "Vorwärtsdeklaration von Funktionen"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "35ff0f796808d3f3da0e1b31",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\n#include <iostream>\ntemplate<typename T>\nvoid func(T&& x) {\n    std::cout << std::is_lvalue_reference<T>::value;\n}\nint main() {\n    int a = 5;\n    func(a);\n    return 0;\n}\n```",
            "answer": "1",
            "explanation": "**Erklärung:**\nWenn ein Lvalue an eine universelle Referenz übergeben wird, wird T als Lvalue-Referenz abgeleitet, daher ist `std::is_lvalue_reference<T>::value` wahr (1).\n[Referenz](https://en.cppreference.com/w/cpp/language/reference)",
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["1", "0", "5", "Kompilierungsfehler"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d6af2daa0dcf31f2d0f39ee2",
            "question": "Was ist `std::invoke` in C++17?",
            "answer": "Ein Hilfsmittel zum Aufrufen beliebiger aufrufbarer Objekte mit gegebenen Argumenten",
            "explanation": "**Erklärung:**\n`std::invoke` bietet eine einheitliche Möglichkeit, beliebige aufrufbare Objekte (Funktion, Funktionszeiger, Mitgliedsfunktion, Funktor) mit Argumenten aufzurufen.\n[Referenz](https://en.cppreference.com/w/cpp/utility/functional/invoke)",
            "hint": null,
            "correctAnswer": [
              "Ein Hilfsmittel zum Aufrufen beliebiger aufrufbarer Objekte mit gegebenen Argumenten"
            ],
            "options": [
              "Eine Funktion zum Aufrufen von Programmen",
              "Ein Hilfsmittel zum Aufrufen beliebiger aufrufbarer Objekte mit gegebenen Argumenten",
              "Ein Methodenaufrufoperator",
              "Ein Aufrufer für Konstruktoren"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "197f3c0a6f8b2430d76e33a7",
            "question": "Was ist `if constexpr` in C++17?",
            "answer": "Eine Kompilierzeit-Bedingung, die Zweige zur Kompilierzeit verwirft",
            "explanation": "**Erklärung:**\n`if constexpr` wertet die Bedingung zur Kompilierzeit aus und instanziiert nur den genommenen Zweig, nützlich in der Template-Metaprogrammierung.\n[Referenz](https://en.cppreference.com/w/cpp/language/if)",
            "hint": null,
            "correctAnswer": [
              "Eine Kompilierzeit-Bedingung, die Zweige zur Kompilierzeit verwirft"
            ],
            "options": [
              "Eine konstante if-Anweisung",
              "Eine Kompilierzeit-Bedingung, die Zweige zur Kompilierzeit verwirft",
              "Eine if-Anweisung, die konstant sein muss",
              "Eine constexpr-Funktion mit if"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "de006276f3c1b9f75b2842dc",
            "question": "Was ist ein Fold-Ausdruck in C++17?",
            "answer": "Eine Möglichkeit, einen binären Operator auf alle Elemente eines Parameterpakets anzuwenden",
            "explanation": "**Erklärung:**\nFold-Ausdrücke bieten eine prägnante Syntax zum Anwenden binärer Operatoren auf Parameterpakete in variadischen Templates.\n[Referenz](https://en.cppreference.com/w/cpp/language/fold)",
            "hint": null,
            "correctAnswer": [
              "Eine Möglichkeit, einen binären Operator auf alle Elemente eines Parameterpakets anzuwenden"
            ],
            "options": [
              "Ein Ausdruck, der Code faltet",
              "Eine Möglichkeit, einen binären Operator auf alle Elemente eines Parameterpakets anzuwenden",
              "Ein Faltungsalgorithmus",
              "Ein Ausdruck zum Falten von Containern"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "619ce8bcbf16b6a80434fcee",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\n#include <iostream>\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int* p = arr;\n    std::cout << *(p + 3);\n    return 0;\n}\n```",
            "answer": "4",
            "explanation": "**Erklärung:**\nZeigerarithmetik: p + 3 zeigt auf das 4. Element (Index 3), das ist 4.\n[Referenz](https://en.cppreference.com/w/cpp/language/operator_arithmetic)",
            "hint": null,
            "correctAnswer": ["4"],
            "options": ["1", "2", "3", "4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c02d6e59825914fc569c6a7a",
            "question": "Was ist `std::filesystem` in C++17?",
            "answer": "Eine Bibliothek zur Durchführung von Operationen auf Dateisystemen und Pfaden",
            "explanation": "**Erklärung:**\n`std::filesystem` bietet Funktionen zur Durchführung von Operationen auf Dateisystemen und ihren Komponenten, wie Pfaden, regulären Dateien und Verzeichnissen.\n[Referenz](https://en.cppreference.com/w/cpp/filesystem)",
            "hint": null,
            "correctAnswer": [
              "Eine Bibliothek zur Durchführung von Operationen auf Dateisystemen und Pfaden"
            ],
            "options": [
              "Ein Dateisystemtreiber",
              "Eine Bibliothek zur Durchführung von Operationen auf Dateisystemen und Pfaden",
              "Ein virtuelles Dateisystem",
              "Eine Dateistream-Klasse"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "58eb2f40b35eb2f6be6df566",
            "question": "Wofür wird `std::atomic` verwendet?",
            "answer": "Thread-sichere Operationen auf gemeinsamen Variablen ohne Sperren",
            "explanation": "**Erklärung:**\n`std::atomic` bietet atomare Operationen auf gemeinsamen Variablen und gewährleistet thread-sicheren Zugriff ohne explizite Sperrung.\n[Referenz](https://en.cppreference.com/w/cpp/atomic/atomic)",
            "hint": null,
            "correctAnswer": ["Thread-sichere Operationen auf gemeinsamen Variablen ohne Sperren"],
            "options": [
              "Atomenergie-Berechnungen",
              "Thread-sichere Operationen auf gemeinsamen Variablen ohne Sperren",
              "Atomare Datentypen",
              "Unteilbare Operationen auf Atomen"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4bf7ce6589f48d32f73453aa",
            "question": "Was ist der Unterschied zwischen `std::mutex` und `std::recursive_mutex`?",
            "answer": "recursive_mutex kann mehrfach vom selben Thread gesperrt werden",
            "explanation": "**Erklärung:**\n`std::recursive_mutex` erlaubt es demselben Thread, ihn mehrfach zu sperren, während `std::mutex` zum Deadlock führen würde, wenn derselbe Thread versucht, ihn zweimal zu sperren.\n[Referenz](https://en.cppreference.com/w/cpp/thread/recursive_mutex)",
            "hint": null,
            "correctAnswer": ["recursive_mutex kann mehrfach vom selben Thread gesperrt werden"],
            "options": [
              "recursive_mutex kann mehrfach vom selben Thread gesperrt werden",
              "mutex ist schneller",
              "recursive_mutex ist veraltet",
              "Es gibt keinen Unterschied"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "28dca712d8384f2ecfeec303",
            "question": "Was ist `std::future` in C++11?",
            "answer": "Ein Objekt, das Zugriff auf das Ergebnis einer asynchronen Operation bietet",
            "explanation": "**Erklärung:**\n`std::future` wird verwendet, um das Ergebnis einer asynchronen Operation abzurufen, die mit `std::async` oder `std::promise` gestartet wurde.\n[Referenz](https://en.cppreference.com/w/cpp/thread/future)",
            "hint": null,
            "correctAnswer": [
              "Ein Objekt, das Zugriff auf das Ergebnis einer asynchronen Operation bietet"
            ],
            "options": [
              "Eine zukünftige Version von C++",
              "Ein Objekt, das Zugriff auf das Ergebnis einer asynchronen Operation bietet",
              "Eine zeitbasierte Klasse",
              "Eine zukünftige Deklaration"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e703fe927b2decff392ece55",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\n#include <iostream>\nclass Base {\npublic:\n    virtual void show() { std::cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void show() override { std::cout << \"Derived\"; }\n};\nint main() {\n    Base* b = new Derived();\n    b->show();\n    delete b;\n    return 0;\n}\n```",
            "answer": "Derived",
            "explanation": "**Erklärung:**\nAufgrund virtueller Funktionspolymorphie wird die show()-Methode der Derived-Klasse aufgerufen, obwohl der Zeiger vom Typ Base\\* ist.\n[Referenz](https://en.cppreference.com/w/cpp/language/virtual)",
            "hint": null,
            "correctAnswer": ["Derived"],
            "options": ["Base", "Derived", "Kompilierungsfehler", "Undefiniertes Verhalten"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "19af70bed0206c70e13c4e13",
            "question": "Wofür wird `std::enable_if` verwendet?",
            "answer": "Für SFINAE-basierte bedingte Template-Instanziierung",
            "explanation": "**Erklärung:**\n`std::enable_if` wird für SFINAE (Substitution Failure Is Not An Error) verwendet, um Template-Spezialisierungen bedingt zu aktivieren oder zu deaktivieren.\n[Referenz](https://en.cppreference.com/w/cpp/types/enable_if)",
            "hint": null,
            "correctAnswer": ["Für SFINAE-basierte bedingte Template-Instanziierung"],
            "options": [
              "Um if-Anweisungen zu aktivieren",
              "Für SFINAE-basierte bedingte Template-Instanziierung",
              "Um Funktionen zu aktivieren",
              "Um zu prüfen, ob etwas aktiviert ist"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "90763f3034f78129e9b447b9",
            "question": "Was ist `std::tuple` in C++11?",
            "answer": "Eine Sammlung fester Größe von heterogenen Werten",
            "explanation": "**Erklärung:**\n`std::tuple` ist eine Sammlung fester Größe, die Elemente verschiedener Typen enthalten kann und `std::pair` auf eine beliebige Anzahl von Elementen verallgemeinert.\n[Referenz](https://en.cppreference.com/w/cpp/utility/tuple)",
            "hint": null,
            "correctAnswer": ["Eine Sammlung fester Größe von heterogenen Werten"],
            "options": [
              "Ein Zwei-Elemente-Paar",
              "Eine Sammlung fester Größe von heterogenen Werten",
              "Ein Tripel von Werten",
              "Ein Tupel in der Mathematik"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bbe83d2a7ed3bf0f3e3f60c9",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\n#include <iostream>\nint main() {\n    int x = 10;\n    int& ref = x;\n    ref = 20;\n    std::cout << x;\n    return 0;\n}\n```",
            "answer": "20",
            "explanation": "**Erklärung:**\nref ist eine Referenz auf x. Das Ändern von ref ändert x direkt, daher wird x zu 20.\n[Referenz](https://en.cppreference.com/w/cpp/language/reference)",
            "hint": null,
            "correctAnswer": ["20"],
            "options": ["10", "20", "Kompilierungsfehler", "Undefiniert"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "64485726718724b6fcf4944e",
            "question": "Wofür wird `std::chrono` verwendet?",
            "answer": "Zeit-Hilfsmittel einschließlich Uhren, Zeitpunkten und Dauern",
            "explanation": "**Erklärung:**\n`std::chrono` ist eine Bibliothek für zeitbezogene Operationen, die Uhren, Zeitpunkte und Dauern mit Typsicherheit bereitstellt.\n[Referenz](https://en.cppreference.com/w/cpp/chrono)",
            "hint": null,
            "correctAnswer": ["Zeit-Hilfsmittel einschließlich Uhren, Zeitpunkten und Dauern"],
            "options": [
              "Chronologische Anordnung",
              "Zeit-Hilfsmittel einschließlich Uhren, Zeitpunkten und Dauern",
              "Chronometer-Funktionen",
              "Verwaltung chronischer Krankheiten"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ba0e51cb92eae67502f1ca1d",
            "question": "Was ist `std::regex` in C++11?",
            "answer": "Eine Bibliothek für Musterabgleich mit regulären Ausdrücken",
            "explanation": "**Erklärung:**\n`std::regex` bietet Unterstützung für reguläre Ausdrücke für Musterabgleich und Textverarbeitung in C++.\n[Referenz](https://en.cppreference.com/w/cpp/regex)",
            "hint": null,
            "correctAnswer": ["Eine Bibliothek für Musterabgleich mit regulären Ausdrücken"],
            "options": [
              "Eine Engine für reguläre Ausdrücke",
              "Eine Bibliothek für Musterabgleich mit regulären Ausdrücken",
              "Ein Textersetzungswerkzeug",
              "Ein Zeichenkettenformatierer"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a55f936c3f2cec043c3a99cc",
            "question": "Was ist `std::initializer_list`?",
            "answer": "Ein leichtgewichtiges Proxy-Objekt für den Zugriff auf Arrays von const T",
            "explanation": "**Erklärung:**\n`std::initializer_list` ermöglicht es Funktionen, geschweifte Klammern umschlossene Wertelisten zu akzeptieren und ermöglicht einheitliche Initialisierungssyntax.\n[Referenz](https://en.cppreference.com/w/cpp/utility/initializer_list)",
            "hint": null,
            "correctAnswer": [
              "Ein leichtgewichtiges Proxy-Objekt für den Zugriff auf Arrays von const T"
            ],
            "options": [
              "Eine Liste von Initialisierern",
              "Ein leichtgewichtiges Proxy-Objekt für den Zugriff auf Arrays von const T",
              "Eine Initialisierungsfunktion",
              "Ein Listen-Konstruktor"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2fde35fca9733e097acde794",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\n#include <iostream>\nint main() {\n    const int x = 10;\n    int* p = const_cast<int*>(&x);\n    *p = 20;\n    std::cout << x;\n    return 0;\n}\n```",
            "answer": "10 (undefiniertes Verhalten)",
            "explanation": "**Erklärung:**\nDies ist undefiniertes Verhalten. Das Ändern eines const-Objekts durch const_cast führt zu unvorhersehbaren Ergebnissen. Der Compiler kann aufgrund der const-Annahme optimieren.\n[Referenz](https://en.cppreference.com/w/cpp/language/const_cast)",
            "hint": null,
            "correctAnswer": ["10 (undefiniertes Verhalten)"],
            "options": ["10 (undefiniertes Verhalten)", "20", "Kompilierungsfehler", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c9252852ec79859fc4091e39",
            "question": "Was ist `std::function` in C++11?",
            "answer": "Ein universeller polymorpher Funktions-Wrapper",
            "explanation": "**Erklärung:**\n`std::function` ist ein typgelöschter Wrapper, der jedes aufrufbare Objekt (Funktion, Lambda, Funktor) mit einer bestimmten Signatur speichern kann.\n[Referenz](https://en.cppreference.com/w/cpp/utility/functional/function)",
            "hint": null,
            "correctAnswer": ["Ein universeller polymorpher Funktions-Wrapper"],
            "options": [
              "Eine Funktionsdeklaration",
              "Ein universeller polymorpher Funktions-Wrapper",
              "Ein Funktionszeiger",
              "Eine Bibliothek für funktionale Programmierung"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "daba74fa6e41f30ad805e032",
            "question": "Wofür wird `std::bind` verwendet?",
            "answer": "Um ein neues aufrufbares Objekt durch Binden von Argumenten an eine Funktion zu erstellen",
            "explanation": "**Erklärung:**\n`std::bind` erstellt ein neues Funktionsobjekt, indem einige Argumente an eine Funktion gebunden werden, nützlich für partielle Funktionsanwendung.\n[Referenz](https://en.cppreference.com/w/cpp/utility/functional/bind)",
            "hint": null,
            "correctAnswer": [
              "Um ein neues aufrufbares Objekt durch Binden von Argumenten an eine Funktion zu erstellen"
            ],
            "options": [
              "Um Variablen zusammenzubinden",
              "Um ein neues aufrufbares Objekt durch Binden von Argumenten an eine Funktion zu erstellen",
              "Um Klassen zu binden",
              "Um Speicher zu binden"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4ce8ee43ca1d927fb96a3058",
            "question": "Worauf basiert `std::unordered_map`?",
            "answer": "Hash-Tabelle",
            "explanation": "**Erklärung:**\n`std::unordered_map` ist mit einer Hash-Tabelle implementiert und bietet durchschnittlich O(1) Suchzeit im Vergleich zu O(log n) für `std::map`.\n[Referenz](https://en.cppreference.com/w/cpp/container/unordered_map)",
            "hint": null,
            "correctAnswer": ["Hash-Tabelle"],
            "options": ["Binärer Suchbaum", "Hash-Tabelle", "Verkettete Liste", "Array"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ab7e3097f954a002bf9bad39",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\n#include <iostream>\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    std::cout << sizeof(arr) / sizeof(arr[0]);\n    return 0;\n}\n```",
            "answer": "5",
            "explanation": "**Erklärung:**\nsizeof(arr) gibt die Gesamtbytes, sizeof(arr[0]) gibt Bytes pro Element. Die Division ergibt die Anzahl der Elemente: 5.\n[Referenz](https://en.cppreference.com/w/cpp/language/sizeof)",
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["4", "5", "20", "1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3b5eec4cbb300d1d9d685587",
            "question": "Was ist `std::make_unique` in C++14?",
            "answer": "Eine Funktion zum Erstellen von std::unique_ptr-Objekten",
            "explanation": "**Erklärung:**\n`std::make_unique` ist eine Hilfsfunktion, die ein `std::unique_ptr` erstellt und zurückgibt und Ausnahmesicherheit und sauberere Syntax bietet.\n[Referenz](https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique)",
            "hint": null,
            "correctAnswer": ["Eine Funktion zum Erstellen von std::unique_ptr-Objekten"],
            "options": [
              "Ein eindeutiger Identifikator-Generator",
              "Eine Funktion zum Erstellen von std::unique_ptr-Objekten",
              "Ein Eindeutigkeitsprüfer",
              "Ein Ersteller eindeutiger Werte"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "44cf999bb2a4ad264e36e301",
            "question": "Was ist `std::exchange` in C++14?",
            "answer": "Ersetzt einen Wert und gibt den alten Wert atomar zurück",
            "explanation": "**Erklärung:**\n`std::exchange` ersetzt den Wert eines Objekts und gibt seinen alten Wert in einer einzigen Operation zurück.\n[Referenz](https://en.cppreference.com/w/cpp/utility/exchange)",
            "hint": null,
            "correctAnswer": ["Ersetzt einen Wert und gibt den alten Wert atomar zurück"],
            "options": [
              "Ein Werteaustauschprogramm",
              "Ersetzt einen Wert und gibt den alten Wert atomar zurück",
              "Ein Austauschoperator",
              "Eine Swap-Funktion"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d25653c21ceec85ac868ce6b",
            "question": "Was ist `std::apply` in C++17?",
            "answer": "Ruft ein aufrufbares Objekt mit einem Tupel von Argumenten auf",
            "explanation": "**Erklärung:**\n`std::apply` ruft ein aufrufbares Objekt mit einem Tupel von Argumenten auf und entpackt das Tupel als Funktionsargumente.\n[Referenz](https://en.cppreference.com/w/cpp/utility/apply)",
            "hint": null,
            "correctAnswer": ["Ruft ein aufrufbares Objekt mit einem Tupel von Argumenten auf"],
            "options": [
              "Ein Anwendungsstarter",
              "Ruft ein aufrufbares Objekt mit einem Tupel von Argumenten auf",
              "Eine Apply-Funktion",
              "Ein Funktionsapplikator"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "36d4efea0d753b45745f0a0b",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    int y = ++x + x++;\n    std::cout << y;\n    return 0;\n}\n```",
            "answer": "Undefiniertes Verhalten",
            "explanation": "**Erklärung:**\nDas mehrfache Ändern von x zwischen Sequenzpunkten führt zu undefiniertem Verhalten. Das Ergebnis ist unvorhersehbar.\n[Referenz](https://en.cppreference.com/w/cpp/language/eval_order)",
            "hint": null,
            "correctAnswer": ["Undefiniertes Verhalten"],
            "options": ["11", "12", "Undefiniertes Verhalten", "13"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0cf0abc7ff2abf54b7382ca4",
            "question": "Was ist `std::decay` in C++11?",
            "answer": "Wendet Array-zu-Zeiger, Funktion-zu-Zeiger an und entfernt cv-Qualifizierer",
            "explanation": "**Erklärung:**\n`std::decay` wendet Typtransformationen ähnlich denen an, die beim Übergeben von Argumenten per Wert geschehen.\n[Referenz](https://en.cppreference.com/w/cpp/types/decay)",
            "hint": null,
            "correctAnswer": [
              "Wendet Array-zu-Zeiger, Funktion-zu-Zeiger an und entfernt cv-Qualifizierer"
            ],
            "options": [
              "Eine Decay-Funktion",
              "Wendet Array-zu-Zeiger, Funktion-zu-Zeiger an und entfernt cv-Qualifizierer",
              "Eine Veraltungsmarkierung",
              "Eine Zerfallskonstante"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7e57881fb532ac3a4af7e878",
            "question": "Was ist `std::conditional` in C++11?",
            "answer": "Wählt einen Typ oder einen anderen basierend auf einem Kompilierzeit-Boolean",
            "explanation": "**Erklärung:**\n`std::conditional` ist eine Metafunktion, die einen von zwei Typen basierend auf einer Kompilierzeit-booleschen Bedingung auswählt.\n[Referenz](https://en.cppreference.com/w/cpp/types/conditional)",
            "hint": null,
            "correctAnswer": [
              "Wählt einen Typ oder einen anderen basierend auf einem Kompilierzeit-Boolean"
            ],
            "options": [
              "Eine bedingte Anweisung",
              "Wählt einen Typ oder einen anderen basierend auf einem Kompilierzeit-Boolean",
              "Ein bedingter Operator",
              "Ein Bedingungsprüfer"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "10660e0ab57b6686d695b7b8",
            "question": "Wofür wird `std::is_same` verwendet?",
            "answer": "Um zur Kompilierzeit zu prüfen, ob zwei Typen gleich sind",
            "explanation": "**Erklärung:**\n`std::is_same` ist ein Type Trait, das zur Kompilierzeit prüft, ob zwei Typen identisch sind.\n[Referenz](https://en.cppreference.com/w/cpp/types/is_same)",
            "hint": null,
            "correctAnswer": ["Um zur Kompilierzeit zu prüfen, ob zwei Typen gleich sind"],
            "options": [
              "Um zu prüfen, ob Werte gleich sind",
              "Um zur Kompilierzeit zu prüfen, ob zwei Typen gleich sind",
              "Um Objekte zu vergleichen",
              "Um Gleichheit zu prüfen"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bb230259b9397772be494d5a",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\n#include <iostream>\nint main() {\n    int x = 10;\n    int* p = &x;\n    int** pp = &p;\n    std::cout << **pp;\n    return 0;\n}\n```",
            "answer": "10",
            "explanation": "**Erklärung:**\npp ist ein Zeiger auf Zeiger. \\*\\*pp dereferenziert zweimal, um den Wert von x zu erhalten, der 10 ist.\n[Referenz](https://en.cppreference.com/w/cpp/language/pointer)",
            "hint": null,
            "correctAnswer": ["10"],
            "options": ["10", "Adresse von x", "Adresse von p", "Kompilierungsfehler"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4719f46ac757cd86783711f7",
            "question": "Wofür wird `std::remove_if` verwendet?",
            "answer": "Um Elemente aus einem Bereich zu entfernen, die ein Prädikat erfüllen",
            "explanation": "**Erklärung:**\n`std::remove_if` entfernt Elemente aus einem Bereich, die ein gegebenes Prädikat erfüllen, wird mit erase für tatsächliches Löschen verwendet.\n[Referenz](https://en.cppreference.com/w/cpp/algorithm/remove)",
            "hint": null,
            "correctAnswer": [
              "Um Elemente aus einem Bereich zu entfernen, die ein Prädikat erfüllen"
            ],
            "options": [
              "Um if-Anweisungen zu entfernen",
              "Um Elemente aus einem Bereich zu entfernen, die ein Prädikat erfüllen",
              "Um Dateien bedingt zu entfernen",
              "Um Bedingungen zu entfernen"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5363c071118cff82901adcc9",
            "question": "Wofür wird `std::transform` verwendet?",
            "answer": "Um eine Funktion auf einen Bereich anzuwenden und Ergebnisse in einem anderen Bereich zu speichern",
            "explanation": "**Erklärung:**\n`std::transform` wendet eine gegebene Funktion auf einen Bereich von Elementen an und speichert das Ergebnis in einem anderen Bereich.\n[Referenz](https://en.cppreference.com/w/cpp/algorithm/transform)",
            "hint": null,
            "correctAnswer": [
              "Um eine Funktion auf einen Bereich anzuwenden und Ergebnisse in einem anderen Bereich zu speichern"
            ],
            "options": [
              "Um Code zu transformieren",
              "Um eine Funktion auf einen Bereich anzuwenden und Ergebnisse in einem anderen Bereich zu speichern",
              "Um Typen zu transformieren",
              "Um Transformationen durchzuführen"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3a8788b08fea8d98114944a9",
            "question": "Wofür wird `std::accumulate` verwendet?",
            "answer": "Um die Summe zu berechnen oder einen Bereich von Elementen zu falten",
            "explanation": "**Erklärung:**\n`std::accumulate` berechnet die Summe eines Bereichs von Elementen oder wendet eine binäre Operation an, um den Bereich zu falten.\n[Referenz](https://en.cppreference.com/w/cpp/algorithm/accumulate)",
            "hint": null,
            "correctAnswer": [
              "Um die Summe zu berechnen oder einen Bereich von Elementen zu falten"
            ],
            "options": [
              "Um Fehler zu akkumulieren",
              "Um die Summe zu berechnen oder einen Bereich von Elementen zu falten",
              "Um Daten zu akkumulieren",
              "Um Zahlen zu addieren"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cafab95a9d2ed6a50be79c36",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    int y = 10;\n    int z = x > y ? x : y;\n    std::cout << z;\n    return 0;\n}\n```",
            "answer": "10",
            "explanation": "**Erklärung:**\nDer ternäre Operator prüft, ob x > y. Da dies falsch ist, wird z y zugewiesen, was 10 ist.\n[Referenz](https://en.cppreference.com/w/cpp/language/operator_other)",
            "hint": null,
            "correctAnswer": ["10"],
            "options": ["5", "10", "1", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "311bc1751c965df8b903b42a",
            "question": "Wofür wird `std::copy` verwendet?",
            "answer": "Um Elemente von einem Bereich in einen anderen zu kopieren",
            "explanation": "**Erklärung:**\n`std::copy` kopiert Elemente von einem Quellbereich in einen Zielbereich.\n[Referenz](https://en.cppreference.com/w/cpp/algorithm/copy)",
            "hint": null,
            "correctAnswer": ["Um Elemente von einem Bereich in einen anderen zu kopieren"],
            "options": [
              "Um Dateien zu kopieren",
              "Um Elemente von einem Bereich in einen anderen zu kopieren",
              "Um Objekte zu duplizieren",
              "Um Speicher zu kopieren"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "86157de5b4e0c1df768238fd",
            "question": "Wofür wird `std::find` verwendet?",
            "answer": "Um das erste Vorkommen eines Werts in einem Bereich zu finden",
            "explanation": "**Erklärung:**\n`std::find` sucht nach dem ersten Vorkommen eines Werts in einem Bereich und gibt einen Iterator darauf zurück.\n[Referenz](https://en.cppreference.com/w/cpp/algorithm/find)",
            "hint": null,
            "correctAnswer": ["Um das erste Vorkommen eines Werts in einem Bereich zu finden"],
            "options": [
              "Um Dateien zu finden",
              "Um das erste Vorkommen eines Werts in einem Bereich zu finden",
              "Um nach Mustern zu suchen",
              "Um Objekte zu lokalisieren"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f6ead9f0c302519477fe7d74",
            "question": "Worauf basiert `std::sort`?",
            "answer": "Introsort (Hybrid aus Quicksort, Heapsort und Insertion Sort)",
            "explanation": "**Erklärung:**\n`std::sort` verwendet typischerweise Introsort, das Quicksort, Heapsort und Insertion Sort für optimale Leistung kombiniert.\n[Referenz](https://en.cppreference.com/w/cpp/algorithm/sort)",
            "hint": null,
            "correctAnswer": ["Introsort (Hybrid aus Quicksort, Heapsort und Insertion Sort)"],
            "options": [
              "Bubble Sort",
              "Introsort (Hybrid aus Quicksort, Heapsort und Insertion Sort)",
              "Nur Merge Sort",
              "Selection Sort"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c47b63dd1faed7de807b3ba0",
            "question": "Was ist die Ausgabe dieses Codes?\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\nint main() {\n    std::vector<int> v = {5, 2, 8, 1, 9};\n    std::sort(v.begin(), v.end());\n    std::cout << v[2];\n    return 0;\n}\n```",
            "answer": "5",
            "explanation": "**Erklärung:**\nNach dem Sortieren wird der Vektor zu {1, 2, 5, 8, 9}. v[2] ist das dritte Element, was 5 ist.\n[Referenz](https://en.cppreference.com/w/cpp/algorithm/sort)",
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["8", "2", "5", "1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-de",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          }
        ]
      },
      {
        "id": "72f5aa2d090f4b90bc8be471-en",
        "language": "en",
        "title": "C++",
        "description": "Seeded from c++/c++-quiz.md",
        "questions": [
          {
            "id": "d18a931432a1d1b2687b52af",
            "question": "What is the output of this code?\n```cpp\nvector<int> v(22);\nbool b = (v[6]);\nprintf(\"%d\", !b);\n```",
            "answer": "1",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["False", "0", "1", "This code has an error."],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1485f458df2e8cfaaafb6fc0",
            "question": "Which of the following is a reason why using this line is considered a bad practice? (_Alternative_: Why is using this line considered a bad practice?)\n```cpp\nusing namespace std;\n```",
            "answer": "If the code uses a function defined in two different libraries with the same prototype but possibly with different implementations, there will be a compilation error due to ambiguity.",
            "explanation": "[Reference](https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/)",
            "hint": null,
            "correctAnswer": [
              "If the code uses a function defined in two different libraries with the same prototype but possibly with different implementations, there will be a compilation error due to ambiguity."
            ],
            "options": [
              "The compiled code is always bigger because of all of the imported symbols.",
              "If the code uses a function defined in two different libraries with the same prototype but possibly with different implementations, there will be a compilation error due to ambiguity.",
              "It automatically includes all header files in the standard library (cstdint, cstdlib, cstdio, iostream, etc).",
              "It causes the compiler to enforce the exclusive inclusion of header files belonging to the standard library, generating a compilation error when a different header file is included."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a51e258841207976460858be",
            "question": "What is the smallest size a variable of the type child_t may occupy in memory?\n```cpp\ntypedef struct{\n    unsigned int  age    : 4;\n    unsigned char gender : 1;\n    unsigned int  size   : 2;\n}child_t;\n```",
            "answer": "1 byte.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": ["1 byte."],
            "options": ["7 bits.", "25 bytes.", "1 bit.", "1 byte."],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "479d0954a74ce5bcc85fbf45",
            "question": "What are the vectors v1 and v2 after executing the code?\n```cpp\nstd::vector<int> v1{1,2,3},v2;\nv2=v1;\nv1.push_back(4);\nv2.push_back(5);\n```",
            "answer": "v1:{1,2,3,4}; v2:{1,2,3,5};",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["v1:{1,2,3,4}; v2:{1,2,3,5};"],
            "options": [
              "Error",
              "v1:{1,2,3,4}; v2:{5};",
              "v1:{1,2,3,4,5}; v2:{1,2,3,4,5};",
              "v1:{1,2,3,4}; v2:{1,2,3,5};"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f9c21a9708f4d65d02c99683",
            "question": "Which of the following is a true statement about the difference between pointers and iterators?",
            "answer": "Incrementing an iterator always means accessing the next element in the container(if any), no matter the container. Incrementing the pointer means pointing to the next element in memory, not always the next element.",
            "explanation": "[Reference](https://stackoverflow.com/a/31128162)",
            "hint": null,
            "correctAnswer": [
              "Incrementing an iterator always means accessing the next element in the container(if any), no matter the container. Incrementing the pointer means pointing to the next element in memory, not always the next element."
            ],
            "options": [
              "While pointers are variables that hold memory addresses, iterators are generic functions used to traverse containers. This function allows the programmer to implement read and write code as the container is traversed.",
              "Incrementing an iterator always means accessing the next element in the container(if any), no matter the container. Incrementing the pointer means pointing to the next element in memory, not always the next element.",
              "Pointers are variables that hold memory address whereas iterator is unsigned integers that refer to offsets in arrays.",
              "All iterators are implemented with pointers so all iterators are pointers but not all pointers are iterators."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "54074966b6c8ec86d8a36ff1",
            "question": "What's the storage occupied by u1?\n```cpp\nunion {\n    uint16_t a;\n    uint32_t b;\n    int8_t c;\n} u1;\n```",
            "answer": "4 bytes",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/union)",
            "hint": null,
            "correctAnswer": ["4 bytes"],
            "options": ["4 bytes", "7 bytes", "8 bytes", "2 bytes"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c30524cbc9d94fa009b0c51c",
            "question": "Which of the following operator can be overloaded?",
            "answer": "`new`",
            "explanation": "[Reference](https://www.tutorialspoint.com/operators-that-cannot-be-overloaded-in-cplusplus)",
            "hint": null,
            "correctAnswer": ["`new`"],
            "options": ["`?:`", "`new`", "`::`", "`.`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3b97fc7fa4caf2501986674a",
            "question": "Which of the following shows the contents of the vector pointed by v1 and v2 after running this code?\n```cpp\nstd:: vector<int> *v1 = new std::vector<int>({1,2,3});\nstd:: vector<int> *v2;\nv2=v1;\nv1->push_back(4);\nv2->push_back(5);\n```",
            "answer": "`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`",
            "explanation": "v1 and v2 point to the same vector.",
            "hint": null,
            "correctAnswer": ["`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`"],
            "options": [
              "`*v1:{1,2,3,4}; *v2:{5};`",
              "`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`",
              "Error",
              "`*v1:{1,2,3,4}; *v2:{1,2,3,5};`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "866d64a26984e1d398f909f6",
            "question": "Which of the following is not a difference between a class and a struct?",
            "answer": "Template type parameters can be declared with classes, but not with the struct keyword.",
            "explanation": "Templates can be used with both classes and structs\n[Reference](https://docs.microsoft.com/en-us/cpp/cpp/struct-cpp?view=msvc-170)\n[Reference](https://www.fluentcpp.com/2017/06/13/the-real-difference-between-struct-class/)",
            "hint": null,
            "correctAnswer": [
              "Template type parameters can be declared with classes, but not with the struct keyword."
            ],
            "options": [
              "Because structs are part of the C programming language, there is some complexity between C and C++ structs. This is not the case with classes.",
              "Classes may have member functions; structs are private.",
              "The default access specifier for members of a struct is public, whereas, for members of the class, it is private.",
              "Template type parameters can be declared with classes, but not with the struct keyword."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1f1948836cc96b60bd7d2098",
            "question": "Suppose you need to keep a data struct with permission to access some resource based on the days of the week, but you can't use a bool variable for each day. You need to use one bit per day of the week. Which of the following is a correct implementation of a structure with bit fields for this application?",
            "answer": "A",
            "explanation": "```cpp\ntypedef struct {\nint sunday:1;\nint monday:1;\n// more days\nint friday:1;\nint saturday:1;\n} weekdays;\n```\n```cpp\ntypedef char[7]: weekdays;\n```\n```cpp\ntypedef struct {\nbit sunday:1;\nbit monday:1;\n// more days\nbit friday:1;\nbit saturday:1;\n} weekdays;\n```\n```cpp\ntypedef struct {\nbit sunday;\nbit monday;\n// more days\nbit friday;\nbit saturday;\n} weekdays;\n```\n[Reference](https://en.cppreference.com/w/cpp/language/bit_field) _NOTE_: Correct syntax is that each variable size is 1 bit. `bit` is not a type in C++.",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "de8a229bb77a1b243ab148bf",
            "question": "What is an lvalue?",
            "answer": "It's a location value, meaning a memory address suitable for assigning to a pointer or reference.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "It's a location value, meaning a memory address suitable for assigning to a pointer or reference."
            ],
            "options": [
              "It's a constant expression, meaning an expression composed of constants and operations.",
              "It's an expression that represents an object with an address.",
              "It's an expression suitable for the left-hand side operand in a binary operation.",
              "It's a location value, meaning a memory address suitable for assigning to a pointer or reference."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "84bae1ad6921f3c431d07824",
            "question": "What does auto type specifier do in this line of code (since C++11)?\n```cpp\nauto x = 4000.22;\n```",
            "answer": "It specifies that the type of x will be deduced from the initializer - in this case, double.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "It specifies that the type of x will be deduced from the initializer - in this case, double."
            ],
            "options": [
              "It specifies that the type of x will be deduced from the initializer - in this case, double.",
              "It specifies that the type of x is automatic meaning that it can be assigned different types of data throughout the program.",
              "It specifies that x is a variable with automatic storage duration.",
              "It specifies that more memory will be allocated for x in case it needs more space, avoiding loss of data due to overflow."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1275f41b9296998629c670ee",
            "question": "A class template is a \\_?",
            "answer": "class written with the generic programming paradigm, specifying behavior in terms of type parameter rather than specific type.",
            "explanation": "[Reference](https://www.mygreatlearning.com/blog/templates-in-cpp/)",
            "hint": null,
            "correctAnswer": [
              "class written with the generic programming paradigm, specifying behavior in terms of type parameter rather than specific type."
            ],
            "options": [
              "class written with the generic programming paradigm, specifying behavior in terms of type parameter rather than specific type.",
              "blank superclass intended for inheritance and polymorphism.",
              "class that only consists of a member variable, with no constructor, destructor, or member functions.",
              "skeleton source code for a class where the programmer has to fill in specific parts to define the data types and algorithms used."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f28b6741fd8e7b05933dba56",
            "question": "What is the ternary operator equivalent to this code snippet?\n```cpp\nif(x)\n    y=a;\nelse\n    y=b;\n```",
            "answer": "`y=x?a:b;`",
            "explanation": "[Reference](https://www.w3schools.com/cpp/cpp_conditions_shorthand.asp)",
            "hint": null,
            "correctAnswer": ["`y=x?a:b;`"],
            "options": ["`y=a?b:x;`", "`y=if(x?a:b);`", "`y=(x&a)?a:(x&b)?b:0;`", "`y=x?a:b;`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "052c5b2b76fb7432b9f70280",
            "question": "What is the output of the code given below?\n```cpp\n#include <iostream>\nint main(){\n    int x=10, y=20;\n    std::cout << \"x = \" << x++ << \" and y = \" << --y << std::endl;\n    std::cout << \"x = \" << x-- << \" and y = \" << ++y << std::endl;\n    return(0);\n}\n```",
            "answer": "`x = 10 and y = 19`",
            "explanation": "`x = 11 and y = 19`\n`x = 10 and y = 20`\n`x = 11 and y = 20`\n`x = 10 and y = 19`",
            "hint": null,
            "correctAnswer": ["`x = 10 and y = 19`"],
            "options": [
              "`x = 10 and y = 20`",
              "`x = 11 and y = 19`",
              "`x = 10 and y = 19`",
              "`x = 11 and y = 20`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "12fee1920d95ba101d87b604",
            "question": "What is the meaning of the two parts specified between parentheses in a range-based for loop, separated by a colon?",
            "answer": "The first is a variable declaration that will hold an element in a sequence. The second is the sequence to traverse.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "The first is a variable declaration that will hold an element in a sequence. The second is the sequence to traverse."
            ],
            "options": [
              "The first is a variable declaration that will hold an element in a sequence. The second is the sequence to traverse.",
              "The first is an iterator, and the second is the increment value to be added to the iterator.",
              "The first is the iterating variable. The second is a `std::pair` that specifies the range (start and end) in which the variable will iterate.",
              "The first is a container object. The second is a `std::pair` that specifies the range (start and end) in which the elements will be accessed within the loop."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5f5123f7b25f3a2073778587",
            "question": "What is the output of the code given below?\n```cpp\nint8_t a=200;\nuint8_t b=100;\nif(a>b)\n    std::cout<<\"greater\";\nelse\n    std::cout<<\"less\";\n```",
            "answer": "less",
            "explanation": "Note: a variant of the question below.",
            "hint": null,
            "correctAnswer": ["less"],
            "options": [
              "There is no output because there is an exception when comparing an int8_t with a uint8_t.",
              "greater",
              "less",
              "There is no output because there is a compiler error."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "889ce860c0b786f09ce7eafa",
            "question": "What is the output of this block of code?\n```cpp\nint8_t a=200;\nuint8_t b=100;\nstd::cout<<\"a=\"<<(int)a;\nstd::cout<<\", b=\"<<(int)b;\n```",
            "answer": "a=-56, b=100",
            "explanation": "Note: Implicit conversion from 'int' to 'int8_t' (aka 'signed char') changes value from 200 to -56",
            "hint": null,
            "correctAnswer": ["a=-56, b=100"],
            "options": ["a=-56, b=100", "a=-55, b=100", "a=200, b=-156", "a=200, b=100"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f2e3a2ee10350073a8d438c2",
            "question": "What is the output after executing this code snippet?\n```cpp\nint x=5, y=2;\nif(x & y) {\n    /*_part A_*/\n}\nelse {\n    /*_part B_*/\n}\n```",
            "answer": "Part B executes because (x & y) results in 0, or false.",
            "explanation": "[Reference](https://stackoverflow.com/questions/63867765/dont-understand-why-if-5-2-is-false)",
            "hint": null,
            "correctAnswer": ["Part B executes because (x & y) results in 0, or false."],
            "options": [
              "Part A executes because x==5 (true) and y==2 (true), thus the AND operation evaluates as true.",
              "Part B executes because (x & y) results in 0, or false.",
              "Part A executes because (x & y) results in a nonzero value, or true.",
              "Part B executes because the statement (x & y) is invalid, thus false."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "21828c8e256bba32fcd984e0",
            "question": "What is a valid definition for the `get_length` function, which returns the length of a null-terminated string?",
            "answer": "A",
            "explanation": "```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str[count++]);\nreturn count-1;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str!=NULL){\ncount++;\nstr++;\n}\nreturn count;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile((*str)++)\ncount++;\nreturn count;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str++)\ncount++;\nreturn count;\n}\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5bc7eaa96bd2ecdad6ffa16c",
            "question": "Which STL class is the best fit for implementing a collection of data that is always ordered so that the pop operation always gets the greatest of the elements? Suppose you are interested only in push and pop operations.",
            "answer": "`std::priority_queue`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`std::priority_queue`"],
            "options": ["`std::list`", "`std::vector`", "`std::priority_queue`", "`std::map`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f89b5f1c01134e667b2f4c18",
            "question": "What is the meaning of the three sections specified between parentheses in a for loop separated by semicolons?",
            "answer": "The first is the initialization block, the second is the condition to iterate, and the third is the increment block.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "The first is the initialization block, the second is the condition to iterate, and the third is the increment block."
            ],
            "options": [
              "The first is the iterating variable name, the second is the number of times to iterate, and the third is the desired increment or decrement (specified with a signed integer).",
              "The first is the initialization block, the second is the condition to iterate, and the third is the increment block.",
              "The first is the iterating variable, the second is the container in which it should operate, and the third is an exit condition to abort at any time.",
              "The first is the iterating variable name, the second is the starting value for the iterating variable, and the third is the stop value (the last value plus one)."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9459e248722c1d2d73f6753e",
            "question": "What does this code print?\n```cpp\nint i = 0;\nprintf(\"%d\", i++);\nprintf(\"%d\", i--);\nprintf(\"%d\", ++i);\nprintf(\"%d\", --i);\n```",
            "answer": "0,1,1,0",
            "explanation": "[Reference](https://www.geeksforgeeks.org/pre-increment-and-post-increment-in-c/)",
            "hint": null,
            "correctAnswer": ["0,1,1,0"],
            "options": ["0,1,1,0", "0,1,0,1", "0,0,1,0", "1,0,1,0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7656dfd4af82f1b4f0b4570a",
            "question": "What is true about the variable named `ptr`?\n```cpp\nvoid *ptr;\n```",
            "answer": "It is a pointer to a value with no specific type, so it may be cast to point to any type.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/pointer)",
            "hint": null,
            "correctAnswer": [
              "It is a pointer to a value with no specific type, so it may be cast to point to any type."
            ],
            "options": [
              "It is a pointer initialized at NULL.",
              "It is a pointer to a void function.",
              "That declaration causes a compiler error, as pointers must specify a type.",
              "It is a pointer to a value with no specific type, so it may be cast to point to any type."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d0a676ce67cf9dfd34ed0bf5",
            "question": "What is the output of the code given below?\n```cpp\nint c=3; char d='A';\nstd::printf(\"c is %d and d is %c\",c,d);\n```",
            "answer": "c is 3 and d is A",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["c is 3 and d is A"],
            "options": [
              "c is d and d is c",
              "c is A and d is 3",
              "c is 3 and d is A",
              "c is c and d is d"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fe303128859422dce03f8089",
            "question": "What is the output of this code?\n```cpp\nprintf(\"1/2 = %f\",(float)(1/2));\n```",
            "answer": "1/2 = 0.000000",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["1/2 = 0.000000"],
            "options": ["1/2 = 0.499999", "1/2 = 0", "1/2 = 0.000000", "1/2 = 0.5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1f1131a86d564dc0ae423891",
            "question": "What is the difference between a public and a private class member?",
            "answer": "Public members can be accessed by any function. Private members can be accessed only by the same class's member functions and the friends of the class.",
            "explanation": "[Reference](https://www.geeksforgeeks.org/difference-between-public-and-private-in-c-with-example/)",
            "hint": null,
            "correctAnswer": [
              "Public members can be accessed by any function. Private members can be accessed only by the same class's member functions and the friends of the class."
            ],
            "options": [
              "Public members are the same as global variables, so every part of the code has access to them. Private members are the same as automatic variables, so only their class has access to them.",
              "Public members are made accessible to any running application. Private members are made accessible only to the application where the object is instantiated.",
              "Public members will be compiled as shared variables in a multithreaded environment. Private members will be compiled as Thread-local variables.",
              "Public members can be accessed by any function. Private members can be accessed only by the same class's member functions and the friends of the class."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "35f3d694d64f777840319c50",
            "question": "What is the value of `x` after executing this code?\n```cpp\nint x=10, a=-3;\nx+=a;\n```",
            "answer": "7",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["7"],
            "options": ["3", "7", "-3", "13"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2f5e7856ea999d3db8afbcbf",
            "question": "Which statement is true?",
            "answer": "C++ supports multiple inheritance.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C++ supports multiple inheritance."],
            "options": [
              "Only classes can have member variables and methods.",
              "C++ supports multiple inheritance.",
              "C++ supports only single inheritance.",
              "Only structs can inherit."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "069691246fafa786af1f627c",
            "question": "Consider a pointer to void, named `ptr`, which has been set to point to a floating point variable `g`. Which choice is a valid way to dereference `ptr` to assign its pointed value to a float variable `f` later in the program?\n```cpp\nfloat g;\nvoid *ptr=&g;\n```",
            "answer": "`float f=*(float *)ptr;`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`float f=*(float *)ptr;`"],
            "options": [
              "`float f=*(float)ptr;`",
              "`float f=(float *)ptr;`",
              "`float f=(float)*ptr;`",
              "`float f=*(float *)ptr;`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0f228013acc832f92fd6e661",
            "question": "What is the `.*` operator and what does it do?",
            "answer": "It is the pointer to the member operator, and it allows you to access a member of an object through a pointer to that specific class member.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/operator_member_access)",
            "hint": null,
            "correctAnswer": [
              "It is the pointer to the member operator, and it allows you to access a member of an object through a pointer to that specific class member."
            ],
            "options": [
              "It is the same as the class member access operator, or arrow operator `(->)`, which allows you to access a member of an object through a pointer to the object.",
              "It is the pointer to the member operator, and it allows you to access a member of an object through a pointer to that specific class member.",
              "It is the member access with an address of the operator, which returns the address of a class or struct member.",
              "It is a combination of the member access operator `(.)` and the dereference operator `(*)`, so it allows you to access the object that a member pointer points to."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c9c5037d8aea871c4100c5bb",
            "question": "For these declarations, which choice shows four equivalent ways to assign the character \"y\" in the string to a char variable c?\n```cpp\nchar buff[50] = \"strings as arrays of characters are fun!\"\nchar *str = buff+11;\nchar c;\n```",
            "answer": "C",
            "explanation": "```cpp\nc = buff[16];\nc = str[5];\nc = *(buff+16);\nc = *(str+5);\n```\n```cpp\nc = *(buff[15]);\nc = *(str[4]);\nc = buff+15;\nc = str+4;\n```\n```cpp\nc = buff[15];\nc = str[4];\nc = *(buff+15);\nc = *(str+4);\n```\n```cpp\nc = *(buff[16]);\nc = *(str[5]);\nc = buff+16;\nc = str+5;\n```",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d70a879027ed61fd336cf130",
            "question": "Which choice is the correct declaration for the class named Dog, derived from the Animal class?\n```cpp\nclass Animal{\n    //....\n}\n```",
            "answer": "B",
            "explanation": "```cpp\nclass Dog :: public Animal {\n//....\n};\n```\n```cpp\nclass Dog : public Animal {\n//....\n};\n```\n```cpp\npublic class Animal :: Dog {\n//....\n};\n```\n```cpp\npublic class Dog extends Animal {\n//....\n};\n```",
            "hint": null,
            "correctAnswer": ["B"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "16bf284b85be8b531492d917",
            "question": "What is the output of this code given below?\n```cpp\n#include <cstdio>\nusing namespace std;\nint main(){\n    char c = 255;\n    if(c>10)\n        printf(\"c = %i, which is greater than 10\", c);\n    else\n        printf(\"c = %i, which is less than 10\", c);\n    return 0;\n}\n```",
            "answer": "c = -1, which is less than 10",
            "explanation": "Technically, whether a `char` is `signed` or `unsigned` is implementation-defined;\nin the latter case, the second answer would be correct.\n[Reference](https://en.cppreference.com/w/cpp/language/types)",
            "hint": null,
            "correctAnswer": ["c = -1, which is less than 10"],
            "options": [
              "c = -1, which is less than 10",
              "c = 255, which is greater than 10",
              "c = -1, which is greater than 10",
              "c = 255, which is less than 10"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "31f5ee1105b5f1c9ff568363",
            "question": "How can C++ code call a C function?",
            "answer": "by using extern \"C\"",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["by using extern \"C\""],
            "options": [
              "by simply calling the C code",
              "There is no way for C++ to call a C function",
              "by using extern \"C\"",
              "by importing the source C code"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5c0c56da979063f19610cc43",
            "question": "Which choice is _not_ a valid type definition of a structure that contains x and y coordinates as integers, and that can be used exactly as shown for the variable named `center`?\n```cpp\ncoord center;\ncenter.x = 5;\ncenter.y = 3;\n```",
            "answer": "A",
            "explanation": "```cpp\ntypedef struct coord {\nint x;\nint y;\n};\n```\n```cpp\ntypedef struct coord {\nint x;\nint y;\n} coord;\n```\n```cpp\ntypedef struct {\nint x;\nint y;\n} coord;\n```\n```cpp\nstruct coord {\nint x;\nint y;\n};\ntypedef struct coord coord;\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "98b406977e25500580f1423d",
            "question": "Which choice does _not_ produce the same output as this code snippet? Assume the variable `i` will not be used anywhere else in the code.\n```cpp\nfor (i=1;i<10;i++){\n    cout<<i<<endl;\n}\n```",
            "answer": "A",
            "explanation": "```cpp\ni=1;\nwhile(i<10){\ncout<<++i<<endl;\n}\n```\n```cpp\nfor (int i:{1,2,3,4,5,6,7,8,9}) {\ncout<<i<<endl;\n}\n```\n```cpp\ni = 1;\ndo {\ncout<<i++<<endl;\n} while(i<10);\n```\n```cpp\ni = 1;\nloop:\ncout<<i++<<endl;\nif(i<10) goto loop;\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "09fdfcc10d3cee156e47a3eb",
            "question": "What does this part of a main.cpp file do?\n```cpp\n#include \"library.h\"\n```",
            "answer": "It causes the replacement of the `#include` directive by the entire contents of the source file library.h. This is similar to the Copy-Paste operation of library.h into main.cpp.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "It causes the replacement of the `#include` directive by the entire contents of the source file library.h. This is similar to the Copy-Paste operation of library.h into main.cpp."
            ],
            "options": [
              "It causes the toolchain to compile all the contents of library.h so that its executable code is available when needed by the final application.",
              "It cherry-picks library.h for the declarations and definitions of all data and functions used in the remainder of the source file main.cpp, finally replacing the `#include` directive with those declarations and definitions.",
              "It informs the linker that some functions or data used in the source file main.cpp are contained in library.h, so that they can be called in run time. This is also known as dynamic linking.",
              "It causes the replacement of the `#include` directive by the entire contents of the source file library.h. This is similar to the Copy-Paste operation of library.h into main.cpp."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9e26fce914f33940af218838",
            "question": "Consider this function declaration of `is_even`, which takes in an integer and returns true if the argument is an even number and false otherwise. Which declarations are correct for overloaded versions of that function to support floating point numbers and string representations of numbers?\n```cpp\nbool is_even(int);\n```",
            "answer": "A",
            "explanation": "```cpp\nbool is_even(float f);\nbool is_even(char *str);\n```\n```cpp\nbool is_even(float f);\nbool is_even(char str);\n```\n```cpp\nbool is_even_float(float f);\nbool is_even_str(char *str);\n```\n```cpp\nfloat is_even(float f);\nchar *is_even(char *str);\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7d86077e2a40635945ff607c",
            "question": "Which choice is an include guard for the header file `my_library.h`?",
            "answer": "B",
            "explanation": "```cpp\n#ifdef MY_LIBRARY_H\n#define MY_LIBRARY_H\n// my_library.h content\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#ifndef MY_LIBRARY_H\n#define MY_LIBRARY_H\n// my_library.h content\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#ifdef MY_LIBRARY_H\n#undef MY_LIBRARY_H\n// my_library.h content\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#define MY_LIBRARY_H\n#include MY_LIBRARY_H\n// my_library.h content\n#undef MY_LIBRARY_H\n```",
            "hint": null,
            "correctAnswer": ["B"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "847bc8b983ce52a4742e1050",
            "question": "What's wrong with this definition when using a pre-C++11 compiler?\n```cpp\nstd::vector<std::vector<int>> thematrix;\n```",
            "answer": "`>>` is parsed as the shift-right operator, and thus results in a compile error.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "`>>` is parsed as the shift-right operator, and thus results in a compile error."
            ],
            "options": [
              "There's nothing wrong with it.",
              "An `std::vector` cannot contain more `std::vector` containers as its elements.",
              "The correct syntax should be: `std::vector[std::vector[int]] thematrix;`",
              "`>>` is parsed as the shift-right operator, and thus results in a compile error."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7af359aadb583b2df1f27191",
            "question": "What is the statement below equivalent to?",
            "answer": null,
            "explanation": null,
            "hint": null,
            "correctAnswer": [],
            "options": [],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "edf6aaa15a6e89255ee3ff77",
            "question": "b. What is the statement equivalent to?\n```cpp\nsprite->x\n```",
            "answer": "`(*sprite).x`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`(*sprite).x`"],
            "options": ["`sprite.x`", "`sprite.*x`", "`(*sprite).x`", "`*sprite.x`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "846a9600b2c698e0d5f4c2de",
            "question": "Consider a class named `complexNumber`. Which code will result in an equivalent object?\n```cpp\ncomplexNumber(float real, float im)\n: real_part(real),\n im_part(im){}\n```",
            "answer": "C",
            "explanation": "```cpp\ncomplexNumber(float real, float im) {\nthis->real = real_part;\nthis->im = im_part;\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part(real);\nthis->im_part(im);\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part = real;\nthis->im_part = im;\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part = &real;\nthis->im_part = &im;\n}\n```",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "abebec1527ae5d7dfa5d93b8",
            "question": "What is the result of executing this code snippet?\n```cpp\nbool x=true, y=false;\nif (~x || y) {\n    /*part A*/\n} else {\n    /*part B*/\n}\n```",
            "answer": "Part A executes because `~x` is not zero, meaning true.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Part A executes because `~x` is not zero, meaning true."],
            "options": [
              "Part A executes because the expression `(~x || y)` always results in true if `y==false`.",
              "Part B executes because the statement `(~x || y)` is invalid, thus false.",
              "Part A executes because `~x` is not zero, meaning true.",
              "Part B executes because `~x` is false and `y` is false, thus the `OR` operation evaluates as false."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "737617591139a7730205da20",
            "question": "What would be the output of this code?\n```cpp\nint32_t nums[3]={2,4,3};\nstd::cout << ( nums[0] << nums[1] << nums[2] );\n```",
            "answer": "256",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["256"],
            "options": [
              "The output is the addresses of `nums[0]`, `nums[1]`, and `nums[2]`, in that order, with no spaces.",
              "256",
              "`0`",
              "`243`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d637d40788fb8b3da8fcae79",
            "question": "What is the output of this code?\n```cpp\nfloat values[5]={0.54f, 2.71828f, 3.14159f, 5.499999f, 10.0f};\nfor(auto f:values)\n    printf(\"%i \",(int)(f+0.5f));\n```",
            "answer": "`1 3 3 5 10`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`1 3 3 5 10`"],
            "options": [
              "`0.54 2.71828 3.14159 5.499999 10.0`",
              "`1 3 4 6 11`",
              "`0 2 3 5 10`",
              "`1 3 3 5 10`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e582cb0ced4d25392f682882",
            "question": "Which of the following STL classes is the best fit for implementing a phonebook? Suppose each entry contains a name and a phone number, with no duplicates, and you want to have a lookup by name.",
            "answer": "`std::map`",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/container/map)",
            "hint": null,
            "correctAnswer": ["`std::map`"],
            "options": ["`std::priority_queue`", "`std::list`", "`std::vector`", "`std::map`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "388a8703adbd125c059040b1",
            "question": "What does this program do?\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\nint main(){\n    ifstream file1(\"text1.txt\", ios::binary);\n    ofstream file2(\"text2.txt\", ios::binary);\n    file2 << file1.rdbuf();\n}\n```",
            "answer": "It copies the contents of text1.txt into text2.txt - i.e., it makes a copy of text1.txt, named text2.txt.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/header/fstream)",
            "hint": null,
            "correctAnswer": [
              "It copies the contents of text1.txt into text2.txt - i.e., it makes a copy of text1.txt, named text2.txt."
            ],
            "options": [
              "It renames text1.txt to text2.txt.",
              "It makes a directory called text2.txt and moves text1.txt there.",
              "It copies the contents of text1.txt into text2.txt - i.e., it makes a copy of text1.txt, named text2.txt.",
              "It appends the contents of text1.txt into text2.txt - i.e., replaces the contents of text2.txt by the concatenation of text2.txt and text1.txt."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "afec57cd45eb134921773ce4",
            "question": "Which of the following is _not_ a consequence of declaring the member variable `count` of my_class as static? / Alt.: Which statement is true when declaring the member variable `count` as static?\n```cpp\nclass my_class {\n    public: static int count;\n}\n```",
            "answer": "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/static)",
            "hint": null,
            "correctAnswer": [
              "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it."
            ],
            "options": [
              "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it.",
              "The variable exists even when no objects of the class have been defined so it can be modified at any point in the source code.",
              "The variable is allocated only once, regardless of how many objects are instantiated because it is bound to the class itself, not its instances.",
              "All objects that try to access their count member variable actually refer to the only class-bound static count variable."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6810cd7f59f19b2997c5874b",
            "question": "What is the assumed type of a constant represented in the source code as `0.44`?",
            "answer": "double",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["double"],
            "options": ["double", "long float", "long double", "float"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "240494924171aa26d33d3668",
            "question": "What is an appropriate way of removing `my_object` as shown below?\n```cpp\nmy_class *my_object = new my_class();\n```",
            "answer": "`delete(my_object);`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`delete(my_object);`"],
            "options": [
              "`delete(my_object);`",
              "`free(my_object);`",
              "The garbage collector will destroy the object eventually.",
              "Exiting the scope will destroy the object."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6d94534aa2a880137a228a16",
            "question": "What is the correct way to call the `count` member function for the object pointer called `grades`?\n```cpp\nclass my_array{\n    public:\n        int count();\n};  // ... more members above\nint main(){\n    my_array *grades = new my_array();\n};  // ... more code above\n```",
            "answer": "`grades->count();`",
            "explanation": "[Reference](https://en.cppreference.com/w/c/language/operator_member_access)",
            "hint": null,
            "correctAnswer": ["`grades->count();`"],
            "options": [
              "`grades.count();`",
              "`my_array->count();`",
              "`grades->count();`",
              "`my_array.count();`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7ae889079a085135ecef215c",
            "question": "What would be the output of this code?\n```cpp\nint i0=4, i1=6, i2=8;\nint& nums[3]={i2,i0,i1};\nstd::cout<<nums[0]<<nums[1]<<nums[2];\n```",
            "answer": "There is no output. The code causes a compiler error because `nums` is an array of references, which is illegal.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/array)",
            "hint": null,
            "correctAnswer": [
              "There is no output. The code causes a compiler error because `nums` is an array of references, which is illegal."
            ],
            "options": [
              "There is no output. The code causes a compiler error because `nums` is an array of references, which is illegal.",
              "846",
              "The output is the addresses of `i2`, `i0`, and `i1`, in that order, with no spaces.",
              "468"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "43bd226790b0f95963c2644a",
            "question": "Does this code cause a compiler error? If so, why, and if not, what is `child_t`?\n```cpp\ntypedef struct{\n    unsigned int  age    : 4;\n    unsigned char gender : 1;\n    char                 : 0;\n    unsigned int  size   : 2;\n}child_t;\n```",
            "answer": "No, and `child_t` is a type defined as a structure with bit fields. It has 4 bits for age and 1 bit for gender in the first byte, and 2 bits for size in the second byte.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": [
              "No, and `child_t` is a type defined as a structure with bit fields. It has 4 bits for age and 1 bit for gender in the first byte, and 2 bits for size in the second byte."
            ],
            "options": [
              "Yes, it causes a compiler error because the colon character is not allowed in struct definitions.",
              "No, and `child_t` is a type defined as a structure with bit fields. It has 4 bits for age and 1 bit for gender in the first byte, and 2 bits for size in the second byte.",
              "Yes, it causes a compiler error because there is an unnamed field.",
              "Yes, it causes a compiler error because one field is defined as having a size of 0."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f0e102fbbb0069283c882572",
            "question": "What is this expression equivalent to?\n```cpp\nA->B\n```",
            "answer": "`(*A).B`",
            "explanation": "Note: a simpler variant of the question below.",
            "hint": null,
            "correctAnswer": ["`(*A).B`"],
            "options": ["`*(A.B)`", "`B=A`", "`(*A).B`", "`&A.B`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f04e79e5de7d0343fc922e2c",
            "question": "What is this expression equivalent to?\n```cpp\nA->B->C->D\n```",
            "answer": "`*(*((*A).B).C).D`",
            "explanation": "**Note:** a more complex variant of the question above.",
            "hint": null,
            "correctAnswer": ["`*(*((*A).B).C).D`"],
            "options": ["`A.B.C.D`", "`*A.*B.*C.*D`", "`&A.&B.&C.&D`", "`*(*((*A).B).C).D`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "70e954ec8be36c57f217fe7e",
            "question": "What does this function do?\n```cpp\nauto buff = new char[50];\nstd::memset(buff,20,50);\n```",
            "answer": "It writes the value 20 in every memory address from buff to buff+49.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/string/byte/memset)",
            "hint": null,
            "correctAnswer": [
              "It writes the value 20 in every memory address from buff to buff+49."
            ],
            "options": [
              "It declares a memory buffer named buff that starts at address 20 and ends at address 70.",
              "It sets all bits in the array named buffer from its element at index 20 to its element at index 50.",
              "It writes the value 20 in every memory address from buff to buff+49.",
              "It declares a memory buffer named buff that starts at address 20 and ends at address 50."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2d89ffc9602ad0cebb04e03c",
            "question": "Consider a class named `CustomData`. Which choice is a correct declaration syntax to overload the postfix `++` operator as a class member?",
            "answer": "`CustomData operator++(int);`",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/operators)",
            "hint": null,
            "correctAnswer": ["`CustomData operator++(int);`"],
            "options": [
              "`CustomData& operator++();`",
              "`void operator++(CustomData);`",
              "`CustomData operator++(CustomData);`",
              "`CustomData operator++(int);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "27bbb6bb74851e2786e5a036",
            "question": "You want to sort my_array, declared below. Which choice is the correct call to std::sort, using a lambda expression as the comparison function?\n```cpp\nstd::array<uint32_t, 50> my_array;\n```",
            "answer": "A",
            "explanation": "```cpp\nstd::sort(my_array.begin(), my_array.end(),\n[](uint32_t a, uint32_t b) {\nreturn a < b;\n})\n```\n```cpp\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n}\nstd::sort(my_array.begin(), my_array.end(), lambda);\n```\n```cpp\nstd::sort(my_array.begin(), my_array.end(),\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n})\n```\n```cpp\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n}\nstd::sort(my_array.begin(), my_array.end(), &lambda);\n```\n[Reference](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160)",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "910257858d3cef7af11db443",
            "question": "Which choice is the most reasonable implementation of the function std::mutex::lock() by using std::mutex::try_lock()?",
            "answer": "A",
            "explanation": "```cpp\nvoid std::mutex::lock(){\nwhile(!this->try_lock());\n}\n```\n```cpp\nvoid std::mutex::lock(){\nreturn (this->try_lock());\n}\n```\n```cpp\nvoid std::mutex::lock(){\nwhile(1)\nthis->try_lock();\n}\n```\n```cpp\nvoid std::mutex::lock(){\nwhile(this->try_lock());\n}\n```\nNote: variant of the question below.",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6f888c4df3a62383fff1a130",
            "question": "What is the main difference between these two Functions?\n```cpp\nstd::mutex::lock()\nstd::mutex::try_lock()\n```",
            "answer": "Both attempt to acquire a lock, but `lock()` blocks if the mutex is not available, whereas `try_lock()` returns whether the mutex is available or not.",
            "explanation": "Note: variant of the question above.\n[Reference](https://en.cppreference.com/w/cpp/thread/mutex/try_lock)",
            "hint": null,
            "correctAnswer": [
              "Both attempt to acquire a lock, but `lock()` blocks if the mutex is not available, whereas `try_lock()` returns whether the mutex is available or not."
            ],
            "options": [
              "`lock()` has a higher privilege over `try_lock()`. This means that you have a better chance of acquiring a mutex `with lock()`.",
              "Both attempt to acquire a lock, but `lock()` blocks if the mutex is not available, whereas `try_lock()` returns whether the mutex is available or not.",
              "`lock()` enforces preemption, whereas `try_lock()` suggests preemption.",
              "If the mutex is not available, `try_lock()` returns with a corresponding code, whereas `lock()` snatches the mutex from the thread that currently has it."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a977e0a29a40ecca66af37bb",
            "question": "What is the purpose of a destructor?",
            "answer": "It allows the programmer to write the necessary code to free the resources acquired by the object prior to deleting the object itself.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "It allows the programmer to write the necessary code to free the resources acquired by the object prior to deleting the object itself."
            ],
            "options": [
              "It allows the programmer to write the necessary code to free the resources acquired by the object prior to deleting the object itself.",
              "It deletes an object. One example of a destructor is the `delete()` function.",
              "It terminates a program. This may be achieved as a regular function call or as an exception.",
              "There are no destructors in C++."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bae6f066cbe4f05f2755dce0",
            "question": "What is one benefit of declaring the parameter as a `const` reference instead of declaring it as a regular object?\n```cpp\nint calculateMedian(const my_array& a)\n```",
            "answer": "The `const` qualifier forbids the code to modify the argument, so the programmer can rest assured that the source object will remain unchanged. / Alt.: The argument is passed as a reference, so if the passed my_array object is large, the program will require less time and memory.",
            "explanation": "[Reference](https://stackoverflow.com/a/2627179/10773894)",
            "hint": null,
            "correctAnswer": [
              "The `const` qualifier forbids the code to modify the argument, so the programmer can rest assured that the source object will remain unchanged. / Alt.: The argument is passed as a reference, so if the passed my_array object is large, the program will require less time and memory."
            ],
            "options": [
              "Actually, objects cannot be passed as regular variables, because they require a constructor call. Therefore, a `const` reference is the only way to pass class instances to functions.",
              "There are no benefits because a reference and an object are treated as the same thing.",
              "The `const` qualifier forbids the code to modify the argument, so the programmer can rest assured that the source object will remain unchanged. / Alt.: The argument is passed as a reference, so if the passed my_array object is large, the program will require less time and memory.",
              "The argument is passed as a reference, so the function receives a copy that can be modified without affecting the original variable."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fd93b5c44bf996681c6e9912",
            "question": "What is an include guard?",
            "answer": "a preprocessor statement that prevents a source file from being included more than once in a project",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "a preprocessor statement that prevents a source file from being included more than once in a project"
            ],
            "options": [
              "a preprocessor directive that prevents inconsistent behaviors in lines that contain the #ifdef, #ifndef, or #elif directives",
              "a compiler option that prevents the user code from including additional libraries",
              "a preprocessor statement that prevents a source file from being included more than once in a project",
              "a library that adds safety features such as mutexes, watchdog timers, and assertions to the project"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ee78feb867d185b67b89a77c",
            "question": "What would be the correct declaration of a default constructor for a class named Sprite?",
            "answer": "A",
            "explanation": "```cpp\npublic: Sprite();\n```\n```cpp\nprivate: void Sprite();\n```\n```cpp\npublic: void Sprite();\n```\n```cpp\nprivate: Sprite();\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b1691c064a063125b6555b03",
            "question": "What is the purpose of this line in a header file?\n```cpp\n#pragma once\n```",
            "answer": "to make the compiler parse that header file only once, even if it is included multiple times in the source",
            "explanation": "[reference here](https://en.cppreference.com/w/cpp/preprocessor/impl)",
            "hint": null,
            "correctAnswer": [
              "to make the compiler parse that header file only once, even if it is included multiple times in the source"
            ],
            "options": [
              "to restrict the use of its contents to only one source file",
              "to tell the compiler that only one variable can be instantiated from the classes or types contained in this header file",
              "to help the compiler finish faster by assuring that only one compiler pass is necessary for the code included in this header file",
              "to make the compiler parse that header file only once, even if it is included multiple times in the source"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f8333596180b077597700dae",
            "question": "What is a variable of type double?",
            "answer": "a floating point number",
            "explanation": "[Reference](https://www.educba.com/c-plus-plus-double/)",
            "hint": null,
            "correctAnswer": ["a floating point number"],
            "options": [
              "a 2-tuple",
              "an integer number",
              "a floating point number",
              "a string with more than 255 characters"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a17782145be1013dbeec1303",
            "question": "Other than shifting bits to the left, what is the << operator used for?",
            "answer": "inserting characters into an output stream like std::cout.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["inserting characters into an output stream like std::cout."],
            "options": [
              "shifting characters to the left in a string.",
              "inserting characters into an output stream like std::cout.",
              "comparing floating point numbers as less-than.",
              "assigning a variable to a reference."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "08db857304da92b194fc99d6",
            "question": "Which choice is a reason to specify the type of a pointer instead of using `void *`, which works as a pointer to any type?",
            "answer": "The compiler needs the data type to know how much memory to allocate for the pointer because different data types require different pointer lengths.",
            "explanation": "[Reference](https://stackoverflow.com/questions/9802585/why-is-the-data-type-needed-in-pointer-declarations)",
            "hint": null,
            "correctAnswer": [
              "The compiler needs the data type to know how much memory to allocate for the pointer because different data types require different pointer lengths."
            ],
            "options": [
              "The compiler needs the data type to make sure that the pointer is not going to be used on illegal non-pointable types such as functions, labels, pointers, and references.",
              "`void *` does not work for any type. The language does not allow assigning anything other than `void` to a pointer to `void *`.",
              "The compiler needs the data type to know how much memory to allocate for the pointer because different data types require different pointer lengths.",
              "Yes, it causes a compiler error because one field is defined as having a size of 0."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "66bcf7d7b173e4e3d41e67cb",
            "question": "What is wrong with this piece of code?\n```cpp\n#include <iostream>\nchar str[20];\nint main(){\n    std::cout << \"What's your name? \";\n    str << std::cin\n    std::cout << \"Hello, \" << str;\n    return 0;\n}\n```",
            "answer": "The input operator flow is inverted. it should start from `std::cin` and then flow (>>) into `str`.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "The input operator flow is inverted. it should start from `std::cin` and then flow (>>) into `str`."
            ],
            "options": [
              "The main function is supposed to have a void return type.",
              "`std::cin` and `std::cout` are invalid. The correct names for the character input and output streams are `cin` and `cout`.",
              "The address of `str` is supposed to be used. That is `&str` instead of `str`.",
              "The input operator flow is inverted. it should start from `std::cin` and then flow (>>) into `str`."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e8de8b4911318db327f5d22b",
            "question": "When placed in a valid execution context, which statement will dynamically allocate memory from the heap for an integer of value 11?",
            "answer": "`int* anInt = new int(11);`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`int* anInt = new int(11);`"],
            "options": [
              "`int anInt = new int(11);`",
              "`int* anInt = new int[11];`",
              "`int anInt = new int[11];`",
              "`int* anInt = new int(11);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "351824374a40b609b165506c",
            "question": "Which choice best describes the type `long`?",
            "answer": "an integer number of at least 32 bits",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["an integer number of at least 32 bits"],
            "options": [
              "an integer number of at least 32 bits",
              "a string with more than 255 characters",
              "a pointer",
              "a 64-bit floating point number"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "887acf8e5bd4ee879a356982",
            "question": "Which of the following types has the closest functionality to a class?",
            "answer": "`struct`",
            "explanation": "[Reference](https://en.cppreference.com/w/c/language/struct)",
            "hint": null,
            "correctAnswer": ["`struct`"],
            "options": ["`struct`", "`union`", "`enum`", "`namespace`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "39b5bf130eae3b8a42ba7fd6",
            "question": "Given these records in a map, how will you update the value for the key \"Sinead\" to 22?\n![image](images/Q79.png)",
            "answer": "`marks[\"Sinead\"] = 22`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`marks[\"Sinead\"] = 22`"],
            "options": [
              "`marks[\"Sinead\"] = 22`",
              "`marks[\"Sinead\"].22`",
              "`marks[\"Sinead\"] -> 22`",
              "`marks[\"Sinead\"].value = 22`"
            ],
            "nature": "ChooseOne",
            "attachments": [
              {
                "id": "7084d1102abcfe33644217da",
                "url": "/Users/arslankaleem/Workspace/Junk/linkedin-skill-assessments-quizzes/c++/images/Q79.png",
                "type": "question"
              }
            ],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e25a4fb7af53ef422784971b",
            "question": "Why can the std::sort receive a function object as one of its parameters?",
            "answer": "`The std::sort function is a template. The programmer is free to enter the sorting algorithm in a function object as an argument.`",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "`The std::sort function is a template. The programmer is free to enter the sorting algorithm in a function object as an argument.`"
            ],
            "options": [
              "`The std::sort function is a template. The programmer is free to enter the sorting algorithm in a function object as an argument.`",
              "`Actually, std::sort takes only one argument, which is the container to be sorted.`",
              "`std::sort operates on a template container. The compiler does not know how to relationally compare the values it contains, so a function must be provided to do the comparison.`",
              "`std::sort will use the parameter function as an error handler. The function will be called if an error occurs.`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "29ba632794ae66810684d689",
            "question": "What will happen when you execute this code snippet?\n```\n#include <iostream>\nint main() {\nfloat a = 5.51;\nint b = static_cast<int>(a);\nstd::cout << b;\n}\n```",
            "answer": "`5 will be printed on standard output, with no compilation warnings generated.`",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "`5 will be printed on standard output, with no compilation warnings generated.`"
            ],
            "options": [
              "`6 will be printed on standard output, with no compilation warnings generated.`",
              "`5 will be printed on standard output, with no compilation warnings generated.`",
              "`6 will be printed on standard output, with compilation warnings generated.`",
              "`5 will be printed on standard output, with compilation warnings generated.`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8fba62bfd01f918ce8e3cb5b",
            "question": "Which access specifier does not allow class members to be accessed from outside the class, but allows them to be accessed by derived classes?",
            "answer": "protected",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["protected"],
            "options": ["guarded", "protected", "public", "private"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cb1f0bd64940620418101e6a",
            "question": "The default executable generation on UNIX for a C++ program is \\_",
            "answer": "a.out",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["a.out"],
            "options": ["a.exe", "a", "a.out", "out.a"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "66a1f8a31b6b3ea96d2e447c",
            "question": "What will be the output of the following program?\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\n  int a=1;\n  cout<<(a++)*(++a)<<endl;\n  return 0;\n}\n```",
            "answer": "3",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["3"],
            "options": ["1", "2", "3", "6"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c5c02b653443a5bf61d9967c",
            "question": "What does \"c\" stand for in cout and cin?",
            "answer": "character",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["character"],
            "options": ["compiler", "console", "character", "standard namespace"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b67dcb7acea51c70424b3aaa",
            "question": "What is the use of tellp()?",
            "answer": "Current Output Pointer position",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Current Output Pointer position"],
            "options": [
              "Current Input Pointer position",
              "Current Output Pointer position",
              "Last Input Pointer position",
              "Last Output Pointer position"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ea14b2408e88d17974e6d3f3",
            "question": "What is callback function?",
            "answer": "Pointer for a function",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Pointer for a function"],
            "options": [
              "Pointer for a pointer",
              "Pointer for a function",
              "function for a pointer",
              "function for a class"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d33406cd0407390f5cd9a8f2",
            "question": "What is the correct syntax to output \"Hello World\" in C++?",
            "answer": "`cout << \"Hello World\";`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`cout << \"Hello World\";`"],
            "options": [
              "`cout << \"Hello World\";`",
              "`System.out.println(\"Hello World\");`",
              "`print(\"Hello World\");`",
              "Console.WriteLine(\"Hello World\");```"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0a58b6818809c15b59e2a6e6",
            "question": "How many categories of iterators are there in C++?",
            "answer": "5",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["4", "3", "7", "5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b9d3f528a0b9de7f45b44b52",
            "question": "What is the meaning of base class in C++ ?",
            "answer": "Another class got inherited from this class",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Another class got inherited from this class"],
            "options": [
              "It inherits other class",
              "It has a pointer variable",
              "It is the first class declared",
              "Another class got inherited from this class"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d169d30e606a683b5ef0eb6b",
            "question": "The size of C++ objects is expressed in terms of multiples of the size of a ** and the size of a char is **.",
            "answer": "char, 1",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["char, 1"],
            "options": ["char, 4", "float, 8", "int, 1", "char, 1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "64512b960dd5bf854b04a6ae",
            "question": "Implementation-dependent aspects about an implementation can be found in",
            "answer": "`<limits>`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`<limits>`"],
            "options": ["`<numeric>`", "`<limit>`", "`<limits>`", "`<implementation>`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ef596fa4bbf6ca62bca8def2",
            "question": "What is a default constructor?",
            "answer": "a constructor that can be used with no arguments",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["a constructor that can be used with no arguments"],
            "options": [
              "a constructor that can be used with no arguments",
              "a constructor that does not have a return value",
              "a constructor that is used by multiple classes",
              "a constructor that initializes all members of a class"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e790d14d6bdb0f9163e2b9b8",
            "question": "When protecting a header file, why would you use '#pragma once' instead of 'include' guard?",
            "answer": "An include guard uses a macro to achieve single inclusion, but the compiler cannot prevent the programmer from defining that macro elsewhere, which would result in no inclusion at all",
            "explanation": "defining that macro elsewhere, which would result in no inclusion at all\nmore than once in a project. This is not a problem with '#pragma once'",
            "hint": null,
            "correctAnswer": [
              "An include guard uses a macro to achieve single inclusion, but the compiler cannot prevent the programmer from defining that macro elsewhere, which would result in no inclusion at all"
            ],
            "options": [
              "There is no reason to choose because they serve different purposes",
              "An include guard uses a macro to achieve single inclusion, but the compiler cannot prevent the programmer from defining that macro elsewhere, which would result in no inclusion at all",
              "'#pragma once' guarantees that the header code will never be changed because it is enforced by the compiler",
              "Include guards refer to the header file in the file system, not to the code, so they are not helpful if the header file exists"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a17c389de35641438548db5f",
            "question": "Which of the following statements is valid?",
            "answer": "We can not change the operator templates.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["We can not change the operator templates."],
            "options": [
              "We can create a new C++ operator.",
              "We can change the precedence of the C++ operator.",
              "We can not change the operator templates.",
              "We can change the associativity of the C++ operators."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ba5f9094d1398326f918ced9",
            "question": "Which of the following is/are automatically added to every class, if we do not write our own?",
            "answer": "All of the above",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["All of the above"],
            "options": [
              "Copy Constructor",
              "Assignment Operator",
              "A constructor without any parameter",
              "All of the above"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "05fbf5c8d63bde42a678ddaf",
            "question": "The if-else statement can be replaced by which operator?",
            "answer": "selective structure",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["selective structure"],
            "options": [
              "certain structure",
              "choosing structure",
              "selective structure",
              "None of the Above"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "40a7275bdb5153229c450c2d",
            "question": "Which choice would be a recursive solution to the factorial n! problem?",
            "answer": "&shy;",
            "explanation": "```cpp\nvoid fact(int n) {\nif (n <= 0)\nreturn 0;\nelse\nreturn 1;\n}\n```\n```cpp\nint fact(int n) {\nif (n <= 0)\nreturn 1;\nelse\nreturn (fact(n) * (n-1));\n}\n```\n```cpp\nint fact(int n) {\nif (n >= 0)\nreturn 1;\nelse\nreturn (fact(n-1) * n);\n}\n```\n```cpp\nint fact(int n) {\nif (n <= 0)\nreturn 1;\nelse\nreturn (fact(n-1) * n);\n}\n```",
            "hint": null,
            "correctAnswer": ["&shy;"],
            "options": ["&shy;", "&shy;", "&shy;", "&shy;"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9916f95c092a23601106f529",
            "question": "A class destructor can be called when a variety of situations occur. Which choice is not one of those situations?",
            "answer": "The garbage collector detects that an object is no longer going to be used.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "The garbage collector detects that an object is no longer going to be used."
            ],
            "options": [
              "The program is terminated. This calls the destructor of static duration objects.",
              "The delete () function is called for an object pointer assigned with the new operator.",
              "The garbage collector detects that an object is no longer going to be used.",
              "An automatic storage duration object goes out of scope."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fd9f56b4e1a18834d8d0b4e4",
            "question": "You are designing a foreign exchange payments system in C++, You need to model a transaction of a currency that has an integer as its quantity and a float as its price. You then want to declare an actual object of this type. How will you achieve this?",
            "answer": "A",
            "explanation": "```cpp\nstruct currencyDeal {\nfloat price;\nint quantity;\n};\ncurrencyDeal firstDeal;\n```\n```cpp\nunion currencyDeal {\nfloat price;\nint quantity;\n};\ncurrencyDeal firstDeal;\n```\n```cpp\nstruct currencyDeal {\nfloat price;\nint quantity;\n};\n```\n```cpp\nunion currencyDeal {\nfloat price;\nint quantity;\n};\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "989a346bb71528c38d4c43af",
            "question": "What will happen if you attempt to call this function with checkConcatThreshold(\"a\");?\n```cpp\nint checkConcatThreshold(string a, string b) {\n    return (a + b).length () > 120;\n}\n```",
            "answer": "A compilation error will occur.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["A compilation error will occur."],
            "options": [
              "A compilation warning will occur and the second argument will be given a default value of b.",
              "A compilation warning will occur and the second argument will be given a default value of the empty string.",
              "A compilation error will occur.",
              "No compilation errors will occur and no compilation warnings will occur."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9b749c02578b98531598c387",
            "question": "You need to define a C++ lambda function. You want the function to have access to only the variables that are local to it. The function should receive a single parameter, and a name, and construct a simple greeting. How will you achieve this?",
            "answer": "C",
            "explanation": "```cpp\nauto myVeryFirstLambda = [=] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nmyVeryFirstLambda = [&] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nauto myVeryFirstLambda = [] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nmyVeryFirstLambda = [] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n[Reference](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160)",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c9911bbe44421ce559a40a69",
            "question": "What is the value of X after running this code?\n```cpp\nint x=10, a=-3;\nX+=a;\n```",
            "answer": "7",
            "explanation": "**Explanation :** `+=` means increasing value. So `x += a` is equivalent to `x = x + a`",
            "hint": null,
            "correctAnswer": ["7"],
            "options": ["-3", "7", "13", "3"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "dd5dedbb195cf580cc83f2d1",
            "question": "Once you are done writing to a file, what method will you call on the `ofstream` to notify the operating system?",
            "answer": "close()",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["close()"],
            "options": ["printout()", "close()", "destroy()", "flush()"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fc6b985287802b7a6446b02b",
            "question": "Which choice is not a C++ keyword?",
            "answer": "comPl",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["comPl"],
            "options": ["static_assert", "reinterpret_cast", "comPl", "alignas"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3a5dc21fa3fb985b068bffe3",
            "question": "The size_in_bits function seems to take any type of parameter. This can be done by overloading the function, or by letting the compiler take care of it by writing a template. Which choice is an implementation of that template?\n```cpp\nint main()\n{\ncout « size_in_bits(21) « endl;\ncout « size_in_bits('f') « endl;\ncout « size_in_bits(32.1f) « endl;\ncout « size_in_bits(32.1) « endl;\nreturn 0;\n}\n```",
            "answer": "A; C",
            "explanation": "```cpp\ntemplate <typename T>\nsize_t size_in_bits(const T& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\ntemplate size_t size_in_bits(const {int,float,double,char,long}& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\ntemplate <typename T {int,float,double,char,long>\nsize_t size_in_bits(const T& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\nsize_t size_in_bits(void * a){\nreturn sizeof(a)*8;\n}\n```",
            "hint": null,
            "correctAnswer": ["A", "C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e50c781e7c6f443500acb296",
            "question": "To use the keyboard as input the iostream library is included. To read input from files as input what library is needed?",
            "answer": "fstream",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["fstream"],
            "options": ["fstream", "cstdlib", "filestream", "iostream"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "802b3d13bb746b89192f411c",
            "question": "What will this object-oriented program print?\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Vehicle {\npublic:\n\tstring fuel = \"none\";\n};\nclass MotorizedVehicle : public Vehicle {\npublic:\n\tstring fuel = \"fossil\";\n};\nclass NextgenMotorizedVehicle : public MotorizedVehicle {\npublic:\n\tstring fuel = \"hydrogen\";\n};\nint main() {\n\tMotorizedVehicle aCar;\n\tcout << aCar.fuel;\n\treturn 0;\n}\n```",
            "answer": "fossil",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["fossil"],
            "options": ["fossil", "fossil none", "hydrogen", "none"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "afe3a7e4a88cd4cfefcb1bf5",
            "question": "The program below is handling a stack container. What is the output of running the program?\n```cpp\n#include <iostream>\n#include <stack>\nint main()\n{\n\tstd::stack<int> stack;\n\tstack.push(1);\n\tstack.push(2);\n\tstack.push(3);\n\tstack.pop();\n\tstack.push(4);\n\tstack.top();\n\tstack.pop();\n\tstd::cout << stack.top();\n}\n```",
            "answer": "2",
            "explanation": "#Detailed explanation:\nNow here we are supposed to implement a stack data structure that follows the **FILO** or (First IN Last Out) principle,\n_stack.push()_ -> pushes an element into the from the end array.\n_stack.pop()_ -> removes an element from the end of the array.\n_stack.top()_ -> Just gives us the topmost element of the array.\nNow following the sequences of push and pop: **[1,2,3]** then pop function is used,\nThe newly formed array is: **[1,2,4]** then the top is used to retrieve the topmost element '4' then again the pop function is used which removes 4.\nthus, the resulting array is: 1,2.\nThen it prints the topmost element (ie: 2).",
            "hint": null,
            "correctAnswer": ["2"],
            "options": ["1", "2", "3", "4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0916384a51940bbc6dccb6a1",
            "question": "Which choice is a valid way to overload the ternary conditional operator?",
            "answer": "`The ternary operator is not overloadable.`",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/operators)",
            "hint": null,
            "correctAnswer": ["`The ternary operator is not overloadable.`"],
            "options": [
              "`void& operator ?:(const bool cond, const void& iftrue, const void& iffalse);`",
              "`The ternary operator is not overloadable.`",
              "`void& operator conditional(const bool cond, const void& iftrue, const void& iffalse);`",
              "`void* operator ?:(const bool cond, const void* iftrue, const void* iffalse);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "eb974ec12a64186cda3633af",
            "question": "Which class hierarchy represents an example of multilevel inheritance?",
            "answer": "In the same program, at different points, a given class derives individually from more than two different classes.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "In the same program, at different points, a given class derives individually from more than two different classes."
            ],
            "options": [
              "In the same program, at different points, a given class derives individually from more than one different class.",
              "A first-class derives directly, at the same time, from a second and third class.",
              "In the same program, at different points, a given class derives individually from more than two different classes.",
              "A first classderives from a second class, and that second class is already derived from a third class"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ff90655ce41a90a6ad441140",
            "question": "Which of the following is the correct syntax to print the message in C++ language?",
            "answer": "cout <<\"Hello world!\";",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/io/cout)",
            "hint": null,
            "correctAnswer": ["cout <<\"Hello world!\";"],
            "options": [
              "Out <<\"Hello world!",
              "Cout << Hello world! ;",
              "cout <<\"Hello world!\";",
              "None of the above"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4205f5a947b3349bab48e051",
            "question": "Consider the following program. What will be the output/error?\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nbool compare(char c1, char c2){\nreturn tolower(c1) > tolower(c2);    //LINE-1\n}\nint main(){\nchar arr1[20] = \"C++ Program\", arr2[20] = \"C Program\";\ncout << lexicographical_compare(arr1, arr1+strlen(arr1), arr2, arr2+strlen(arr2),\ncompare);\nreturn 0;\n}\n```",
            "answer": "1",
            "explanation": "[Reference](https://www.geeksforgeeks.org/tolower-function-in-cpp/)",
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["1", "0", "-1", "Compilation Error: function is not defined"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "917e77fb010888895edea3b9",
            "question": "Consider the following code segment. Fill in the blank at LINE-1 so that the program will print \"not found\"?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint data[] = {1,2,3,4,5};\nint key = 5;\nif(binary_search(__________))    //LINE-1\ncout << \"found\";\nelse\ncout << \"not found\";\nreturn 0;\n}\n```",
            "answer": "&data[0], &data[4], key; data+1, data+4, key",
            "explanation": "[Reference](https://www.geeksforgeeks.org/binary-search-algorithms-the-c-standard-template-library-stl/)",
            "hint": null,
            "correctAnswer": ["&data[0], &data[4], key", "data+1, data+4, key"],
            "options": [
              "&data[0], &data[5], key",
              "data, data+5, key",
              "&data[0], &data[4], key",
              "data+1, data+4, key"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c072f809e80ea30a10b7b4c0",
            "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main () {\nint data[] = {50, 30, 40, 10, 20};\nsort (&data[1], &data[4]);\nfor (int i = 0; i < 5; i++)\ncout << data[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "50 10 30 40 20",
            "explanation": "[Reference](https://cplusplus.com/reference/algorithm/sort/)",
            "hint": null,
            "correctAnswer": ["50 10 30 40 20"],
            "options": ["10 20 30 40 50", "10 30 40 50 20", "50 10 30 40 20", "50 10 20 30 40"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a037ba1ca8ed1004219c45c9",
            "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint element[5];\nfor(int i = 1; i <= 5; i++)\n*(element + i - 1) = i * 5;\nrotate(element, element + 4, element + 5);\nrotate(element, element + 1, element + 4);\nfor (int i = 0; i < 5; ++i)\ncout << element[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "5 10 15 25 20",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/algorithm/rotate)",
            "hint": null,
            "correctAnswer": ["5 10 15 25 20"],
            "options": ["5 10 15 20 25", "5 10 15 25 20", "20 10 15 25 5", "25 5 10 15 20"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "45f9b5d75408200aec50fa22",
            "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nconst int size = 3, c = 65;\nvector<char> vc(size, ’A’);\nfor (int i = 1; i <= 2; i++)\nvc.push_back(65 + i);\nvc.resize(10, 90);\nvc.resize(8);\nfor (int i = 0; i < vc.size(); i++)\ncout << vc[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "A A A B C Z Z Z",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/container/vector)",
            "hint": null,
            "correctAnswer": ["A A A B C Z Z Z"],
            "options": ["A A A B C Z Z Z", "A A B B C Z Z Z", "A A A B C Z Z", "A A A B C Z Z Z Z"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0a51260f2a1b9355c9d994a3",
            "question": "Consider the following code segment. Choose the appropriate option to fill in the blank at LINE-1, such that the output of the code would be: a C++ Program.\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nint main(void) {\nstring s1 = \"C++ \";\nstring s2 = \"Program\";\n__________________;    //LINE-1\ncout << s1;\nreturn 0;\n}\n```",
            "answer": "s1 += s2; s1.append(s2)",
            "explanation": "[Reference](https://www.geeksforgeeks.org/stdstringappend-in-c/)",
            "hint": null,
            "correctAnswer": ["s1 += s2", "s1.append(s2)"],
            "options": ["s1 += s2", "strcat(s1, s2)", "s1.append(s2)", "s1.insert(s2)"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7843c51ffaa6152b2a7ac997",
            "question": "Consider the following code segment. Fill in the blank at LINE-1 such that the output is 5 2 3 4 5\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint data[] = { 1, 2, 3, 4, 5 };\nfor (int i = 0; i < 1; i++) {\nint j = data[i];\nreplace(data, data + 5, j, *(_________________));    //LINE-1\n}\nfor (int i = 0; i < 5; ++i)\ncout << data[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "data + 4 - i",
            "explanation": "[Reference](https://www.geeksforgeeks.org/stdstringreplace-stdstringreplace_if-c/)",
            "hint": null,
            "correctAnswer": ["data + 4 - i"],
            "options": ["data + 4 - i", "data + 5 - i", "data + i - 4", "data + i - 5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "445061f350ebab0b58c1e7ed",
            "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\n#include <cstring>\n#include <stack>\nusing namespace std;\nint main(){\nchar str[10] = \"123456789\";\nstack<char> s1, s2;\nint i;\nfor(i = 0; i < strlen(str)/2; i++)\ns1.push(str[i]);\nfor(i=i-1; i < strlen(str); i++)\ns2.push(str[i]);\nwhile (!s1.empty()) {\ns2.push(s1.top()); s1.pop();\n}\nwhile (!s2.empty()) {\ncout << s2.top(); s2.pop();\n}\nreturn 0;\n}\n```",
            "answer": "1234987654",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/container/stack)",
            "hint": null,
            "correctAnswer": ["1234987654"],
            "options": ["1234987654", "123498765", "1234897654", "123459876"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4c78ecb90d7b0875488d9e1c",
            "question": "Consider the following code segment. Which statement/statements is/are correct?\n```cpp\nint i = 5;\nconst int *p = &i;\nint * const q = &i;\nint const *r = &i;\nint const * const s = &i;\n*p = 10; //STMT-1\n*q = 10; //STMT-2\n*r = 10; //STMT-3\n*s = 10; //STMT-4\n```",
            "answer": "STMT-2",
            "explanation": "[Reference](https://www.geeksforgeeks.org/const-keyword-in-cpp/)",
            "hint": null,
            "correctAnswer": ["STMT-2"],
            "options": ["STMT-1", "STMT-2", "STMT-3", "STMT-4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9f1b1761ba67e51d815a7f8a",
            "question": "Consider the following program. What will be the output/error(s)?\n```cpp\n#include <iostream>\nusing namespace std;\nchar add(char c1 = ’a’) { return c1; }\nchar add(char c1 = ’a’, char c2 = ’b’) { return c1 + c2 - ’a’;}\nchar add(char c1 = ’a’, int d1 = 100){ return c1 + d1 - ’a’; }\nchar add(char c1 = ’a’, char c2 = ’b’, char c3) { return c1 + c2 + c3 - ’a’; }\nint main() {\nchar c = add(’o’, ’k’);\ncout << c << endl;\nreturn 0;\n}\n```",
            "answer": "Compilation Error: default argument missing for \"char add(char, char, char)\"; Compilation Error: call of overload \"add(char, char)\" is ambiguous",
            "explanation": "[Reference](https://learn.microsoft.com/en-us/cpp/cpp/function-overloading?view=msvc-170)",
            "hint": null,
            "correctAnswer": [
              "Compilation Error: default argument missing for \"char add(char, char, char)\"",
              "Compilation Error: call of overload \"add(char, char)\" is ambiguous"
            ],
            "options": [
              "y",
              "z",
              "Compilation Error: default argument missing for \"char add(char, char, char)\"",
              "Compilation Error: call of overload \"add(char, char)\" is ambiguous"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c44b1e9710d5a91652443841",
            "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\nusing namespace std;\n#define SQR(x) (x)*(x)\nint main() {\nint a=3;\ncout << SQR(a++) << endl;\nreturn 0;\n}\n```",
            "answer": "12",
            "explanation": "[Reference](https://www.geeksforgeeks.org/output-of-the-program-use-macros-carefully/)",
            "hint": null,
            "correctAnswer": ["12"],
            "options": ["12", "25", "9", "16"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b5bd3f4fcb30d4e3da956f95",
            "question": "Consider the following code segment. Which line/s will give you an error?\n```cpp\n#include<iostream>\n#define X 1\nusing namespace std;\nint main(){\nint i;\nconst int i1 = 2;\nconst int i2 = i1; //LINE-1\ni2 = X;\ni = i1;\ni1 = i;\nreturn 0;\n//LINE-2\n//LINE-3\n//LINE-4\n}\n```",
            "answer": "LINE-2; LINE-4",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["LINE-2", "LINE-4"],
            "options": ["LINE-1", "LINE-2", "LINE-3", "LINE-4"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1861f2891187be69cff4cd4b",
            "question": "Consider the following code segment. What will be the output/error?\n```cpp\n#include<iostream>\nusing namespace std;\nint main(){\nint a = 5;\nint &b = a+1;\na = a*b;\ncout << a << \" \" << b;\nreturn 0;\n}\n```",
            "answer": "Compilation Error: invalid initialization of non-const reference",
            "explanation": "#Detailed explanation:\nThe error is occurring because it is trying to create a reference to a temporary value. In the line int &b = a+1; we are attempting to create a reference b to the result of the expression a + 1, which is a temporary value. References must be bound to an actual object, not a temporary value or an expression that does not have a memory location.",
            "hint": null,
            "correctAnswer": ["Compilation Error: invalid initialization of non-const reference"],
            "options": [
              "36",
              "30",
              "25",
              "Compilation Error: invalid initialization of non-const reference"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c22fa9cc1f7433aff3c16f4a",
            "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\nusing namespace std;\nint& func(int& i) {     //LINE-1\nreturn i = i+5;\n}\nint main() {\nint x = 1, y = 2;\nint& z = func(x);\ncout << x << \" \" << z << \" \";\nfunc(x) = y;\ncout << x << \" \" << z;\nreturn 0;\n}\n```",
            "answer": "6 6 2 2",
            "explanation": "[Reference](https://www.ibm.com/docs/en/zos/2.4.0?topic=calls-pass-by-reference-c-only)",
            "hint": null,
            "correctAnswer": ["6 6 2 2"],
            "options": ["6 6 2 2", "6 6 7 7", "1 1 2 2", "1 1 7 7"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "105e2823b56eea9fee868beb",
            "question": "Consider the following code segment. Choose the appropriate option to fill in the blanks at LINE-1, such that the output of the code would be: 300 20000.\n```cpp\n#include <iostream>\nusing namespace std;\nvoid compute(int n1, int n2, ________, ________){ //LINE-1\nn3 = n1 + n2;\n*n4 = n1 * n2;\n}\nint main(){\nint a = 100, b = 200, c = 0, d = 0;\ncompute(a, b, c, &d); //LINE-2\ncout << c << \", \";\ncout << d;\nreturn 0;\n}\n```",
            "answer": "int& n3, int \\*n4",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["int& n3, int \\*n4"],
            "options": [
              "int n3, int\\* n4",
              "int& n3, int \\*n4",
              "int* n3, int* n4",
              "int& n3, int& n4"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3976bead37c89a9601c1d0a2",
            "question": "Consider the following code segment. What will be the output/error?\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\nint a = 2, *b;\n*b = 5;\nint * const ptr;    // LINE-1\n// LINE-2\nptr = b;\ncout << *ptr;\nreturn 0;\n}\n```",
            "answer": "Compilation Error at LINE-1: uninitialized const ’ptr’; Compilation Error at LINE-2: assignment of read-only variable ’ptr’",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Compilation Error at LINE-1: uninitialized const ’ptr’",
              "Compilation Error at LINE-2: assignment of read-only variable ’ptr’"
            ],
            "options": [
              "`<garbage value>`",
              "5",
              "Compilation Error at LINE-1: uninitialized const ’ptr’",
              "Compilation Error at LINE-2: assignment of read-only variable ’ptr’"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "848e8665b1dabc38e7fe2104",
            "question": "Consider the following code segment. What will be the output/error?\n```cpp\n#include <iostream>\nusing namespace std;\nvoid fun(int a = 5) { cout << a << endl; }\n//LINE-1\nint fun(int x = 10) { cout << x << endl; return 0; }    //LINE-2\nint main() {\nfun();\nreturn 0;\n}\n```",
            "answer": "Compilation error at LINE-2: ambiguating new declaration of ’int fun(int)’",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Compilation error at LINE-2: ambiguating new declaration of ’int fun(int)’"
            ],
            "options": [
              "5",
              "10",
              "5",
              "Compilation error at LINE-2: ambiguating new declaration of ’int fun(int)’"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "77548aa1e07055936a9e447d",
            "question": "Consider the following code segment. Fill in the blank at LINE-1 such that the program will print 5 + i3\n```cpp\n#include<iostream>\nusing namespace std;\nstruct complex{\nint re, im;\nvoid show(){ cout << re << \" + i\" << im; }\n};\n______________________________________{ //Line-1\nc2.re = c1.re+c2.re;\nc2.im = c1.im+c2.im;\nreturn c2;\n}\nint main(){\nstruct complex c1={2,5},c2{3,-2};\nstruct complex t = c1 + c2;\nt.show();\nreturn 0;\n}\n```",
            "answer": "complex operator+(complex &c1, complex &c2)",
            "explanation": "[Reference](https://www.w3schools.com/cpp/cpp_structs.asp)",
            "hint": null,
            "correctAnswer": ["complex operator+(complex &c1, complex &c2)"],
            "options": [
              "complex operator+(complex &c1, complex &c2)",
              "complex operator+(const complex &c1, const complex &c2)",
              "operator+(complex &c1, complex &c2)",
              "complex +(complex &c1, complex &c2)"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d7c10dc2075fb5a0030653b9",
            "question": "Consider the following program. Which line/s will generate an error?\n```cpp\n#include<iostream>\nusing namespace std;\nclass myClass{\nint pra = 5;\npublic:\nint pub = 10;\nvoid set_pr(int x){ pra = x; }\nvoid set_pu(int x){ pub = x; }\n};\nint main(){\nmyClass m;\nint a, b;\na = m.pra; //LINE-1\nb = m.pub; //LINE-2\nm.set_pr(100); //LINE-3\nm.set_pu(200); //LINE-4\nreturn 0;\n}\n```",
            "answer": "LINE-1",
            "explanation": "[Reference](https://stackoverflow.com/questions/4855422/c-classes-public-private-and-protected)",
            "hint": null,
            "correctAnswer": ["LINE-1"],
            "options": ["LINE-1", "LINE-2", "LINE-3", "LINE-4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "36025b6b3995b082481ad52d",
            "question": "Consider the following class. Fill in the blanks with proper access specifiers so that member y can be accessed from outside of the class but member x cannot be accessed.\n```cpp\nclass Test{\n________:\nint x;\n________:\nint y;\n/* Some more code */\n};\n```",
            "answer": "private, private",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["private, private"],
            "options": ["public, public", "public, private", "private, public", "private, private"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c9d77581509969e0325cdb05",
            "question": "Which C++ Standard did add in-class default member initializers?",
            "answer": "C++11",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C++11"],
            "options": ["C++98", "C++11", "C++14", "C++17."],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9d9379bdc7e375f1308de2c6",
            "question": "Can you use auto type deduction for non-static data members?",
            "answer": "No",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["No"],
            "options": ["Yes, since C++11", "No", "Yes, since C++20"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a6c660c883d76dc31c0d4bfd",
            "question": "Do you need to define a static inline data member in a cpp file?",
            "answer": "No, the definition happens at the same place where a static inline member is declared.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": [
              "No, the definition happens at the same place where a static inline member is declared."
            ],
            "options": [
              "No, the definition happens at the same place where a static inline member is declared.",
              "Yes, the compiler needs the definition in a cpp file.",
              "Yes, the compiler needs a definition in all translation units that use this variable."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2ac91f7c3503315c729187fa",
            "question": "What's the output of the following code:\n```cpp\nstruct S {\n    int a { 10 };\n    int b { 42 };\n};\nS s { 1 };\nstd::cout << s.a << \", \" << s.b;\n```",
            "answer": "Output is: 1, 42",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Output is: 1, 42"],
            "options": ["Output is: 1, 0", "Output is: 10, 42", "Output is: 1, 42"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0cda5cacc5338f08d79f75bb",
            "question": "Can a static inline variable be non-constant?",
            "answer": "Yes, it's just a regular variable.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Yes, it's just a regular variable."],
            "options": [
              "Yes, it's just a regular variable.",
              "No, inline variables must be constant."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "822e5c3fca7961b0bf862b89",
            "question": "Consider the following code:\n```cpp\nstruct C {\n    C(int x) : a(x) { }\n    int a { 10 };\n    int b { 42 };\n};\nC c(0);\n```",
            "answer": "C::a is initialized only once with 0 in the constructor.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C::a is initialized only once with 0 in the constructor."],
            "options": [
              "C::a is initialized twice. The first time, it's initialized with 10, and then the second time with 0 in the constructor.",
              "C::a is initialized only once with 0 in the constructor.",
              "The code doesn't compile because the compiler cannot decide how to initialize the C::a member.",
              "2 bytes"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "87a9656720d9ccd09ccd9829",
            "question": "What happens when you throw an exception from a constructor?",
            "answer": "The object is considered \"partially created,\" and thus, the compiler won't call its destructor.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "The object is considered \"partially created,\" and thus, the compiler won't call its destructor."
            ],
            "options": [
              "The object is considered \"created\" so it will follow the regular lifetime of an object.",
              "The object is considered \"partially created,\" and thus, the compiler won't call its destructor.",
              "he compiler calls std::terminate as you cannot throw exceptions from constructors."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d8c163531e115f25fbee45b7",
            "question": "What happens when you compile this code?\n```cpp\nstruct Point { int x; int y; };\nPoint pt {.y = 10, .x = 11 };\nstd::cout << pt.x << \", \" << pt.y;\n```",
            "answer": "The code doesn't compile. Designators have to be in the same order as the data members in the Point class.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "The code doesn't compile. Designators have to be in the same order as the data members in the Point class."
            ],
            "options": [
              "The code doesn't compile. Designators have to be in the same order as the data members in the Point class.",
              "The code compiles and prints 11, 10.",
              "The code compiles and prints 10, 11."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d071b05a4ce810358818f081",
            "question": "Will this code work in C++11?\n```cpp\nstruct User { std::string name = \"unknown\"; unsigned age { 0 }; };\nUser u { \"John\", 101 };\n```",
            "answer": "The code compiles starting with C++14 mode.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["The code compiles starting with C++14 mode."],
            "options": [
              "Yes, the code compiles in C++11 mode.",
              "The code compiles starting with C++14 mode.",
              "The code doesn't compile even in C++20."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1c4047ff66b5f70456f857a5",
            "question": "Assume you have a std::map<string, int> m;. Select the single true statement about the following loop:\n```cpp\nfor (const pair<string, int>& elem : m)\n```",
            "answer": "A The loop properly iterates over the map, creating no extra copies.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "A The loop properly iterates over the map, creating no extra copies."
            ],
            "options": [
              "A The loop properly iterates over the map, creating no extra copies.",
              "B The loop will create a copy of each element in the map as the type of elem mismatches.",
              "C The code won't compile as a const pair cannot bind to a map."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6f0c9079329ff4c77b44ace5",
            "question": "Identify the correct extension of the user-defined header file in C++.",
            "answer": ".h",
            "explanation": null,
            "hint": null,
            "correctAnswer": [".h"],
            "options": [".cpp", ".hg", ".h", ".hf"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bb2abd1d8d46f1a52862834e",
            "question": "Identify the incorrect constructor type.\n```cpp\nauto x = 4000.22;\n```",
            "answer": "Friend Constructor",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Friend Constructor"],
            "options": [
              "Friend Constructor",
              "Default Constructor",
              "Parameterised Constructor",
              "CopyConstructor"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "375eef5809794ed1dc222819",
            "question": "Which of the following data types is supported in C++ but not in C?",
            "answer": "bool",
            "explanation": "[Reference]: https://stackoverflow.com/questions/1608318/is-bool-a-native-c-type",
            "hint": null,
            "correctAnswer": ["bool"],
            "options": ["bool", "int", "double", "float"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bb7490e14daa98d8014b144a",
            "question": "Identify the correct syntax for declaring arrays in C++.",
            "answer": "int arr[10]",
            "explanation": "[Reference]: (https://en.cppreference.com/w/cpp/language/array)",
            "hint": null,
            "correctAnswer": ["int arr[10]"],
            "options": ["int arr[10]", "array arr[10]", "array{10}", "int arr"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0b7c67cb9c39c2d8654bb2de",
            "question": "Size of wchat_t is.",
            "answer": "Depends on the number of bits in the system",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Depends on the number of bits in the system"],
            "options": ["2", "4", "2 or 4", "Depends on the number of bits in the system"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "55e4a19fa6248bb40e6fb765",
            "question": "Which of the following loops is best when we know the number of iterations?",
            "answer": "for",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["for"],
            "options": ["while", "for", "do", "All of the above"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4ef44bc74c96c60f583fe31d",
            "question": "Which keyword is used to define the macros in C++?",
            "answer": "#define",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["#define"],
            "options": ["#macro", "#define", "macro", "keyword"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "289b3f43676cc201614cbd95",
            "question": "Which of the following operators should be preferred to overload as a global function rather than a member method?",
            "answer": "Comparison Operator",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Comparison Operator"],
            "options": ["Postfix ++", "Comparison Operator", "Insertion Operator <<", "Prefix++"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6cbcf883d13e0e4775c2dfa6",
            "question": "How can we restrict the dynamic allocation of objects of a class using new?",
            "answer": "By making an empty private new and new[] operators",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["By making an empty private new and new[] operators"],
            "options": [
              "By overloading new operator",
              "By making an empty private new operator.",
              "By making an empty private new and new[] operators",
              "By overloading new operators and new[] operators"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "978fe8d194ca827413592d22",
            "question": "What is the time complexity of the below code?\n```cpp\nfor(int i=0;i<n;i++){\n   for(int j=0;j<n;j++){\n       cout<<\"hello\";\n    }\n}\n```",
            "answer": "O(n^2)",
            "explanation": "[Reference](<https://medium.com/enjoy-algorithm/analysis-of-loop-in-programming-cc9a644ef8cd#:~:text=At%20each%20step%20of%20the%20iteration%2C%20the%20nested%20loop%20is,%20%3D%20O(n%C2%B2)>)",
            "hint": null,
            "correctAnswer": ["O(n^2)"],
            "options": ["O(n^3)", "O(n^2)", "O(n)", "O(1)"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "883570603123aebb5a94bb27",
            "question": "What is the output of the code given below?\n```cpp\nint a=10;\nint k=++a;\nint m=a++;\ncout<<k+m;\n```",
            "answer": "22",
            "explanation": "Both **++a** and **a++** increase the value of a by 1 (ie: 11) and hence k+m becomes 22.",
            "hint": null,
            "correctAnswer": ["22"],
            "options": ["20", "21", "22", "23"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0d1026e3c2f876dd3ac2df07",
            "question": "Which C++ construct is used for exception handling?",
            "answer": "try-catch",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["try-catch"],
            "options": ["try-catch", "if-else", "for loop", "switch-case"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9e3ee021f9b118f07b878c5e",
            "question": "What is the purpose of the `break` statement in a loop in C++?",
            "answer": "Terminate the loop",
            "explanation": "[Reference]: (https://www.tutorialspoint.com/cprogramming/c_break_statement.htm)",
            "hint": null,
            "correctAnswer": ["Terminate the loop"],
            "options": [
              "Exit the program",
              "Skip the current iteration and continue with the next one",
              "Terminate the loop",
              "Return a value"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "77ccba8cf068b9cea199a394",
            "question": "In C++, what is the purpose of the `const` keyword when used with a variable?",
            "answer": "It makes the variable immutable",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["It makes the variable immutable"],
            "options": [
              "It makes the variable immutable",
              "It changes the data type",
              "It defines a constant function",
              "It makes the variable a pointer"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "482163b9cc01772cea9a7278",
            "question": "Which is more effective while calling the C++ functions??",
            "answer": "Call by reference",
            "explanation": "[Reference]: (https://www.algbly.com/More/MCQs/Cpp-mcq/Cpp-functions.html)",
            "hint": null,
            "correctAnswer": ["Call by reference"],
            "options": ["Call by reference", "Call by value", "Call by pointer", "Call by object"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "af19d47dd3eb092553fe90cd",
            "question": "What will be the output of the following C++ program?\n```cpp\n#include <iostream>\nusing namespace std;\nclass A{\npublic:\n\tA(){\n\t\tcout<<\"Constructor called\\n\";\n\t   }\n\t~A(){\n\t\tcout<<\"Destructor called\\n\";\n\t    }\n};\nint main(int argc, char const *argv[])\n{\n\tA *a = new A[5];\n\tdelete[] a;\n\treturn 0;\n}\n```",
            "answer": "“Constructor called” five times and then “Destructor called” five times",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "“Constructor called” five times and then “Destructor called” five times"
            ],
            "options": [
              "Segmentation fault",
              "“Constructor called” five times and then “Destructor called” five times",
              "“Constructor called” five times and then “Destructor called” once",
              "Error"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "acef0234dc730ba8b165a185",
            "question": "Which choice is _not_ related to declaring the member variable count as static in my_class?\n```cpp\nclass my_class{\n    public: static int count;\n}\n```",
            "answer": "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it."
            ],
            "options": [
              "All objects that try to access their count member variable actually refer to the only class-bound static count variable.",
              "The variable exists even when no objects of the class have been defined, so it can be modified at any point in the source code.",
              "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it.",
              "The variable is allocated only once, regardless of how many objects are instantiated, because it is bound to the class itself, not its instances."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6f0c4cb2931634dc5be4e352",
            "question": "What is the purpose of the `constexpr` keyword in C++?",
            "answer": "`constexpr` is used to indicate that an expression can be evaluated at compile-time, making it suitable for use in constant expressions.",
            "explanation": "[Ref](https://learn.microsoft.com/en-us/cpp/cpp/constexpr-cpp?view=msvc-170#:~:text=constexpr%20indicates%20that%20the%20value,template%20arguments%20and%20array%20declarations.)",
            "hint": null,
            "correctAnswer": [
              "`constexpr` is used to indicate that an expression can be evaluated at compile-time, making it suitable for use in constant expressions."
            ],
            "options": [
              "It is used to define constants in C++.",
              "`constexpr` is used to specify that a variable is a constant pointer.",
              "`constexpr` is used to indicate that an expression can be evaluated at compile-time, making it suitable for use in constant expressions.",
              "It is a keyword used to create asynchronous functions."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4063ff12fe5b1e76ff679a66",
            "question": "What is a template metaprogram in C++?\n- Ref(https://www.geeksforgeeks.org/template-metaprogramming-in-c/)",
            "answer": "A template metaprogram is a compile-time computation, where templates and template specialization are used to perform computations at compile time.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "A template metaprogram is a compile-time computation, where templates and template specialization are used to perform computations at compile time."
            ],
            "options": [
              "A template metaprogram is a high-level programming language.",
              "It refers to metaprogramming that uses templates in C++.",
              "It's a type of user interface design pattern.",
              "A template metaprogram is a compile-time computation, where templates and template specialization are used to perform computations at compile time."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "24dbb8ebde1d1eb2dbde45e7",
            "question": "Identify the correct example for a pre-increment operator.",
            "answer": "++i",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["++i"],
            "options": ["++i", "i++", "--i", "+i"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5553033b8e18c6a9467bc1ff",
            "question": "What will be the output of following code?\n```cpp\n{% raw %}\nint matrix[3][3] = {{1, 2, 3},{4, 5, 6},{7, 8, 9}};\nfor(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n        int a = matrix[i][j];\n        matrix[i][j] = matrix[j][i];\n        matrix[j][i] = a;\n    }\n}\n{% endraw %}\n```",
            "answer": "Same matrix",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Same matrix"],
            "options": [
              "Transpose of matrix",
              "Same matrix",
              "Mirror image of Matrix",
              "Inverted matrix"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "867b9882d17276d275c18b14",
            "question": "What is a race condition in C++?",
            "answer": "A condition where multiple threads access shared data concurrently, and the outcome depends on the timing of their execution",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/memory_model)",
            "hint": null,
            "correctAnswer": [
              "A condition where multiple threads access shared data concurrently, and the outcome depends on the timing of their execution"
            ],
            "options": [
              "A condition where the program runs faster than expected",
              "A condition where multiple threads access shared data concurrently, and the outcome depends on the timing of their execution",
              "A condition where two threads compete for CPU time",
              "A condition where a loop executes too quickly and needs to be slowed down"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9c0d0e66095ee2f1baaeb29d",
            "question": "Consider the following code that has a race condition. What is the correct way to fix it?\n```cpp\n#include <thread>\n#include <vector>\nint counter = 0;\nvoid incrementCounter() {\n    for(int i = 0; i < 1000; i++) {\n        counter++;\n    }\n}\nint main() {\n    std::vector<std::thread> threads;\n    for(int i = 0; i < 10; i++) {\n        threads.push_back(std::thread(incrementCounter));\n    }\n    for(auto& t : threads) {\n        t.join();\n    }\n    return 0;\n}\n```",
            "answer": "Use `std::mutex` to lock/unlock around `counter++` in the critical section",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/thread/mutex)",
            "hint": null,
            "correctAnswer": [
              "Use `std::mutex` to lock/unlock around `counter++` in the critical section"
            ],
            "options": [
              "Add `volatile` keyword: `volatile int counter = 0;`",
              "Use `std::mutex` to lock/unlock around `counter++` in the critical section",
              "Use `std::this_thread::sleep_for()` to delay each increment",
              "Change `counter++` to `++counter` for atomic operation"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "471ec15d4c9771452a6c4e2c",
            "question": "What is the purpose of `std::move` in C++11?",
            "answer": "To cast an object to an rvalue reference, enabling move semantics",
            "explanation": "**Explanation:**\n`std::move` is a cast that produces an rvalue reference to its argument, allowing resources to be moved rather than copied. It doesn't actually move anything itself, but enables move constructors and move assignment operators to be called.\n[Reference](https://en.cppreference.com/w/cpp/utility/move)",
            "hint": null,
            "correctAnswer": ["To cast an object to an rvalue reference, enabling move semantics"],
            "options": [
              "To copy an object to a new location",
              "To cast an object to an rvalue reference, enabling move semantics",
              "To physically move memory from one address to another",
              "To delete an object and create a new one"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4e7c1bc092b7320a2a472202",
            "question": "What is the output of this code?\n```cpp\n#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v1 = {1, 2, 3};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v1.size() << \" \" << v2.size();\n    return 0;\n}\n```",
            "answer": "0 3",
            "explanation": "**Explanation:**\nAfter `std::move(v1)`, v1 is in a valid but unspecified state. Typically, it becomes empty (size 0) and v2 takes ownership of the elements.\n[Reference](https://en.cppreference.com/w/cpp/utility/move)",
            "hint": null,
            "correctAnswer": ["0 3"],
            "options": ["3 3", "0 3", "3 0", "Compilation error"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8bacd5cbe39e7d5e06b3d21d",
            "question": "What is a lambda expression in C++?",
            "answer": "An anonymous function object that can capture variables from its enclosing scope",
            "explanation": "**Explanation:**\nLambda expressions, introduced in C++11, allow you to write inline anonymous functions. They can capture variables from the surrounding scope and are often used with STL algorithms.\n[Reference](https://en.cppreference.com/w/cpp/language/lambda)",
            "hint": null,
            "correctAnswer": [
              "An anonymous function object that can capture variables from its enclosing scope"
            ],
            "options": [
              "A mathematical function",
              "An anonymous function object that can capture variables from its enclosing scope",
              "A template function",
              "A macro definition"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f5e846d6054b0eb4eb624d88",
            "question": "What does `auto` keyword do in C++11?",
            "answer": "Automatically deduces the type of a variable from its initializer",
            "explanation": "**Explanation:**\nThe `auto` keyword in C++11 enables automatic type deduction from the initializer, making code more concise and easier to maintain.\n[Reference](https://en.cppreference.com/w/cpp/language/auto)",
            "hint": null,
            "correctAnswer": ["Automatically deduces the type of a variable from its initializer"],
            "options": [
              "Makes a variable automatic storage duration",
              "Automatically deduces the type of a variable from its initializer",
              "Makes a function inline",
              "Declares a global variable"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "146c0771c914a28e57761d51",
            "question": "What is the difference between `std::unique_ptr` and `std::shared_ptr`?",
            "answer": "unique_ptr has exclusive ownership, shared_ptr allows multiple owners",
            "explanation": "**Explanation:**\n`std::unique_ptr` provides exclusive ownership - only one unique_ptr can own a resource. `std::shared_ptr` uses reference counting to allow multiple shared_ptrs to own the same resource.\n[Reference](https://en.cppreference.com/w/cpp/memory/unique_ptr)",
            "hint": null,
            "correctAnswer": [
              "unique_ptr has exclusive ownership, shared_ptr allows multiple owners"
            ],
            "options": [
              "unique_ptr has exclusive ownership, shared_ptr allows multiple owners",
              "unique_ptr is faster but less safe",
              "shared_ptr can only be used with classes",
              "There is no difference"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b8ea88088615326c78d8bee5",
            "question": "What is RAII in C++?",
            "answer": "Resource Acquisition Is Initialization",
            "explanation": "**Explanation:**\nRAII is a C++ programming idiom where resource acquisition is tied to object lifetime. Resources are acquired in constructors and released in destructors, ensuring proper cleanup.\n[Reference](https://en.cppreference.com/w/cpp/language/raii)",
            "hint": null,
            "correctAnswer": ["Resource Acquisition Is Initialization"],
            "options": [
              "Random Access Iterator Interface",
              "Resource Acquisition Is Initialization",
              "Recursive Algorithm Implementation Interface",
              "Runtime Allocation and Initialization"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "09a86b4231cae4d6d0568acf",
            "question": "What is the output of this code?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    auto lambda = [x]() mutable { x += 10; return x; };\n    std::cout << lambda() << \" \" << x;\n    return 0;\n}\n```",
            "answer": "15 5",
            "explanation": "**Explanation:**\nThe lambda captures x by value. The `mutable` keyword allows modification of the captured copy. The original x remains unchanged.\n[Reference](https://en.cppreference.com/w/cpp/language/lambda)",
            "hint": null,
            "correctAnswer": ["15 5"],
            "options": ["5 5", "15 5", "15 15", "5 15"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e07b32aae8c1144bd48cf52c",
            "question": "What is `constexpr` in C++11?",
            "answer": "Specifies that a function or variable can be evaluated at compile time",
            "explanation": "**Explanation:**\n`constexpr` indicates that a value or function can be evaluated at compile time, enabling compile-time computation and optimization.\n[Reference](https://en.cppreference.com/w/cpp/language/constexpr)",
            "hint": null,
            "correctAnswer": [
              "Specifies that a function or variable can be evaluated at compile time"
            ],
            "options": [
              "A constant expression that can only be used with integers",
              "Specifies that a function or variable can be evaluated at compile time",
              "A macro for defining constants",
              "A keyword for declaring const pointers"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "638f5fd5c72236ae640a9702",
            "question": "What is the purpose of `std::forward`?",
            "answer": "To preserve the value category (lvalue/rvalue) of a forwarded argument",
            "explanation": "**Explanation:**\n`std::forward` is used in template functions to perfectly forward arguments while preserving their value category, essential for implementing perfect forwarding.\n[Reference](https://en.cppreference.com/w/cpp/utility/forward)",
            "hint": null,
            "correctAnswer": [
              "To preserve the value category (lvalue/rvalue) of a forwarded argument"
            ],
            "options": [
              "To move an object forward in memory",
              "To preserve the value category (lvalue/rvalue) of a forwarded argument",
              "To iterate forward through a container",
              "To declare a forward declaration"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c1b31808ee1f1d48e1e6b3a3",
            "question": "What is a variadic template?",
            "answer": "A template that accepts a variable number of template parameters",
            "explanation": "**Explanation:**\nVariadic templates, introduced in C++11, allow templates to accept any number of template arguments, enabling flexible generic programming.\n[Reference](https://en.cppreference.com/w/cpp/language/parameter_pack)",
            "hint": null,
            "correctAnswer": ["A template that accepts a variable number of template parameters"],
            "options": [
              "A template with varying return types",
              "A template that accepts a variable number of template parameters",
              "A template that can be instantiated multiple times",
              "A template with optional parameters"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c75dc05d54a5276e3ec29967",
            "question": "What does `nullptr` represent?",
            "answer": "A null pointer constant with type std::nullptr_t",
            "explanation": "**Explanation:**\n`nullptr` is a keyword introduced in C++11 that represents a null pointer. It's type-safe unlike NULL or 0.\n[Reference](https://en.cppreference.com/w/cpp/language/nullptr)",
            "hint": null,
            "correctAnswer": ["A null pointer constant with type std::nullptr_t"],
            "options": [
              "A null character",
              "A null pointer constant with type std::nullptr_t",
              "An empty string",
              "Zero value"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bf884be8c79104370da18629",
            "question": "What is the output of this code?\n```cpp\n#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> p1 = std::make_shared<int>(42);\n    std::shared_ptr<int> p2 = p1;\n    std::cout << p1.use_count();\n    return 0;\n}\n```",
            "answer": "2",
            "explanation": "**Explanation:**\nBoth p1 and p2 share ownership of the same integer, so the reference count is 2.\n[Reference](https://en.cppreference.com/w/cpp/memory/shared_ptr)",
            "hint": null,
            "correctAnswer": ["2"],
            "options": ["1", "2", "42", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bc5bc17f85ed7bddbc01c222",
            "question": "What is `std::optional` in C++17?",
            "answer": "A wrapper that may or may not contain a value",
            "explanation": "**Explanation:**\n`std::optional` is a template class that represents an optional value - it either contains a value or is empty, providing a type-safe way to represent \"no value\".\n[Reference](https://en.cppreference.com/w/cpp/utility/optional)",
            "hint": null,
            "correctAnswer": ["A wrapper that may or may not contain a value"],
            "options": [
              "An optional parameter in a function",
              "A wrapper that may or may not contain a value",
              "A template for optional compilation",
              "A keyword for optional types"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f46d1184bba08842a8707478",
            "question": "What is structured binding in C++17?\n```cpp\nauto [x, y, z] = std::make_tuple(1, 2, 3);\n```",
            "answer": "A feature that unpacks tuple-like objects into individual variables",
            "explanation": "**Explanation:**\nStructured bindings allow decomposing objects into their constituent elements, making code more readable when working with tuples, pairs, or structs.\n[Reference](https://en.cppreference.com/w/cpp/language/structured_binding)",
            "hint": null,
            "correctAnswer": [
              "A feature that unpacks tuple-like objects into individual variables"
            ],
            "options": [
              "A way to bind structures together",
              "A feature that unpacks tuple-like objects into individual variables",
              "A method for creating structured data",
              "A binding for struct members"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c00aa49d90960c70797ea4b8",
            "question": "What is `std::string_view` in C++17?",
            "answer": "A non-owning reference to a string that avoids copying",
            "explanation": "**Explanation:**\n`std::string_view` provides a lightweight, non-owning reference to a string, avoiding unnecessary copies and improving performance.\n[Reference](https://en.cppreference.com/w/cpp/string/basic_string_view)",
            "hint": null,
            "correctAnswer": ["A non-owning reference to a string that avoids copying"],
            "options": [
              "A view of a string in a GUI",
              "A non-owning reference to a string that avoids copying",
              "A string that can only be viewed, not modified",
              "A view class for displaying strings"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "080706e5f816fd44dd573e8f",
            "question": "What are concepts in C++20?",
            "answer": "Named sets of requirements for template parameters",
            "explanation": "**Explanation:**\nConcepts are a C++20 feature that allows you to specify constraints on template parameters, making template code more readable and providing better error messages.\n[Reference](https://en.cppreference.com/w/cpp/language/constraints)",
            "hint": null,
            "correctAnswer": ["Named sets of requirements for template parameters"],
            "options": [
              "Abstract ideas in programming",
              "Named sets of requirements for template parameters",
              "Conceptual design patterns",
              "Documentation comments"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8d8e64cabd938b4faada4ed4",
            "question": "What is the three-way comparison operator (<=>) in C++20?",
            "answer": "An operator that returns ordering information (less, equal, greater)",
            "explanation": "**Explanation:**\nThe spaceship operator (<=>) performs three-way comparison and returns an ordering category, simplifying comparison operator definitions.\n[Reference](https://en.cppreference.com/w/cpp/language/operator_comparison)",
            "hint": null,
            "correctAnswer": [
              "An operator that returns ordering information (less, equal, greater)"
            ],
            "options": [
              "A comparison of three values",
              "An operator that returns ordering information (less, equal, greater)",
              "Three separate comparison operators",
              "A ternary comparison"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "40d8e91646a3ee96ae4c1bef",
            "question": "What is `std::span` in C++20?",
            "answer": "A non-owning view over a contiguous sequence of objects",
            "explanation": "**Explanation:**\n`std::span` provides a view over a contiguous sequence of objects without owning them, useful for passing array-like data without copying.\n[Reference](https://en.cppreference.com/w/cpp/container/span)",
            "hint": null,
            "correctAnswer": ["A non-owning view over a contiguous sequence of objects"],
            "options": [
              "A time span measurement",
              "A non-owning view over a contiguous sequence of objects",
              "A spanning tree data structure",
              "A span element in HTML"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ae3f92fba2e931c1921d068d",
            "question": "What is the output of this code?\n```cpp\n#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v = {1, 2, 3, 4, 5};\n    for (auto& x : v) {\n        x *= 2;\n    }\n    std::cout << v[2];\n    return 0;\n}\n```",
            "answer": "6",
            "explanation": "**Explanation:**\nThe range-based for loop with `auto&` modifies each element in place. v[2] (originally 3) becomes 6.\n[Reference](https://en.cppreference.com/w/cpp/language/range-for)",
            "hint": null,
            "correctAnswer": ["6"],
            "options": ["3", "6", "2", "12"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7902447682ecf0235ba201ce",
            "question": "What is `std::variant` in C++17?",
            "answer": "A type-safe union that can hold one of several types",
            "explanation": "**Explanation:**\n`std::variant` is a type-safe union that can hold a value of one of several specified types, providing safer alternative to C unions.\n[Reference](https://en.cppreference.com/w/cpp/utility/variant)",
            "hint": null,
            "correctAnswer": ["A type-safe union that can hold one of several types"],
            "options": [
              "A variable that can vary",
              "A type-safe union that can hold one of several types",
              "A variant of a class",
              "A variable template"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "114d9043e53506fd634cd128",
            "question": "What is `std::any` in C++17?",
            "answer": "A type-safe container for single values of any type",
            "explanation": "**Explanation:**\n`std::any` can store a single value of any copy-constructible type, providing type-safe storage with runtime type checking.\n[Reference](https://en.cppreference.com/w/cpp/utility/any)",
            "hint": null,
            "correctAnswer": ["A type-safe container for single values of any type"],
            "options": [
              "Any type of variable",
              "A type-safe container for single values of any type",
              "A wildcard type",
              "An optional type"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "328b8e89141cd4c73801e21d",
            "question": "What is the difference between `std::array` and C-style arrays?",
            "answer": "std::array knows its size and provides member functions",
            "explanation": "**Explanation:**\n`std::array` is a container that encapsulates fixed-size arrays, providing size information and STL container interface while maintaining performance of C-style arrays.\n[Reference](https://en.cppreference.com/w/cpp/container/array)",
            "hint": null,
            "correctAnswer": ["std::array knows its size and provides member functions"],
            "options": [
              "std::array knows its size and provides member functions",
              "std::array is slower",
              "C-style arrays are safer",
              "There is no difference"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e9adf85584b38e5737301f32",
            "question": "What is perfect forwarding?",
            "answer": "Preserving the value category of arguments when passing them to another function",
            "explanation": "**Explanation:**\nPerfect forwarding uses `std::forward` and universal references to pass arguments to another function while preserving their value category (lvalue or rvalue).\n[Reference](https://en.cppreference.com/w/cpp/utility/forward)",
            "hint": null,
            "correctAnswer": [
              "Preserving the value category of arguments when passing them to another function"
            ],
            "options": [
              "Forwarding without errors",
              "Preserving the value category of arguments when passing them to another function",
              "Fast parameter passing",
              "Forward declaration of functions"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cb08038620fce4d405ee7e95",
            "question": "What is the output of this code?\n```cpp\n#include <iostream>\ntemplate<typename T>\nvoid func(T&& x) {\n    std::cout << std::is_lvalue_reference<T>::value;\n}\nint main() {\n    int a = 5;\n    func(a);\n    return 0;\n}\n```",
            "answer": "1",
            "explanation": "**Explanation:**\nWhen an lvalue is passed to a universal reference, T is deduced as an lvalue reference, so `std::is_lvalue_reference<T>::value` is true (1).\n[Reference](https://en.cppreference.com/w/cpp/language/reference)",
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["1", "0", "5", "Compilation error"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5478f07503e7bcad9b2b27f6",
            "question": "What is `std::invoke` in C++17?",
            "answer": "A utility to call any callable object with given arguments",
            "explanation": "**Explanation:**\n`std::invoke` provides a uniform way to call any callable (function, function pointer, member function, functor) with arguments.\n[Reference](https://en.cppreference.com/w/cpp/utility/functional/invoke)",
            "hint": null,
            "correctAnswer": ["A utility to call any callable object with given arguments"],
            "options": [
              "A function to invoke programs",
              "A utility to call any callable object with given arguments",
              "A method invocation operator",
              "An invoker for constructors"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "50979491a4c55c87a77de295",
            "question": "What is `if constexpr` in C++17?",
            "answer": "A compile-time conditional that discards branches at compile time",
            "explanation": "**Explanation:**\n`if constexpr` evaluates the condition at compile time and only instantiates the taken branch, useful in template metaprogramming.\n[Reference](https://en.cppreference.com/w/cpp/language/if)",
            "hint": null,
            "correctAnswer": ["A compile-time conditional that discards branches at compile time"],
            "options": [
              "A constant if statement",
              "A compile-time conditional that discards branches at compile time",
              "An if statement that must be constant",
              "A constexpr function with if"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7659059cd3ac62926c5f6c91",
            "question": "What is fold expression in C++17?",
            "answer": "A way to apply a binary operator to all elements of a parameter pack",
            "explanation": "**Explanation:**\nFold expressions provide a concise syntax for applying binary operators to parameter packs in variadic templates.\n[Reference](https://en.cppreference.com/w/cpp/language/fold)",
            "hint": null,
            "correctAnswer": [
              "A way to apply a binary operator to all elements of a parameter pack"
            ],
            "options": [
              "An expression that folds code",
              "A way to apply a binary operator to all elements of a parameter pack",
              "A folding algorithm",
              "An expression for folding containers"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c3ef049343eddd814177d272",
            "question": "What is the output of this code?\n```cpp\n#include <iostream>\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int* p = arr;\n    std::cout << *(p + 3);\n    return 0;\n}\n```",
            "answer": "4",
            "explanation": "**Explanation:**\nPointer arithmetic: p + 3 points to the 4th element (index 3), which is 4.\n[Reference](https://en.cppreference.com/w/cpp/language/operator_arithmetic)",
            "hint": null,
            "correctAnswer": ["4"],
            "options": ["1", "2", "3", "4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3b569cb65a4b8b07d22f7b19",
            "question": "What is `std::filesystem` in C++17?",
            "answer": "A library for performing operations on file systems and paths",
            "explanation": "**Explanation:**\n`std::filesystem` provides facilities for performing operations on file systems and their components, such as paths, regular files, and directories.\n[Reference](https://en.cppreference.com/w/cpp/filesystem)",
            "hint": null,
            "correctAnswer": ["A library for performing operations on file systems and paths"],
            "options": [
              "A file system driver",
              "A library for performing operations on file systems and paths",
              "A virtual file system",
              "A file stream class"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "871d9cdd36dc795e5dcd3c09",
            "question": "What is `std::atomic` used for?",
            "answer": "Thread-safe operations on shared variables without locks",
            "explanation": "**Explanation:**\n`std::atomic` provides atomic operations on shared variables, ensuring thread-safe access without explicit locking.\n[Reference](https://en.cppreference.com/w/cpp/atomic/atomic)",
            "hint": null,
            "correctAnswer": ["Thread-safe operations on shared variables without locks"],
            "options": [
              "Atomic energy calculations",
              "Thread-safe operations on shared variables without locks",
              "Atomic data types",
              "Indivisible operations on atoms"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d4aca407705d6ef924a47bf1",
            "question": "What is the difference between `std::mutex` and `std::recursive_mutex`?",
            "answer": "recursive_mutex can be locked multiple times by the same thread",
            "explanation": "**Explanation:**\n`std::recursive_mutex` allows the same thread to lock it multiple times, while `std::mutex` would deadlock if the same thread tries to lock it twice.\n[Reference](https://en.cppreference.com/w/cpp/thread/recursive_mutex)",
            "hint": null,
            "correctAnswer": ["recursive_mutex can be locked multiple times by the same thread"],
            "options": [
              "recursive_mutex can be locked multiple times by the same thread",
              "mutex is faster",
              "recursive_mutex is deprecated",
              "There is no difference"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "87cc0e0ae6341a27dc7d2393",
            "question": "What is `std::future` in C++11?",
            "answer": "An object that provides access to the result of an asynchronous operation",
            "explanation": "**Explanation:**\n`std::future` is used to retrieve the result of an asynchronous operation started with `std::async` or `std::promise`.\n[Reference](https://en.cppreference.com/w/cpp/thread/future)",
            "hint": null,
            "correctAnswer": [
              "An object that provides access to the result of an asynchronous operation"
            ],
            "options": [
              "A future version of C++",
              "An object that provides access to the result of an asynchronous operation",
              "A time-based class",
              "A future declaration"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "73529af636606cfc5326a844",
            "question": "What is the output of this code?\n```cpp\n#include <iostream>\nclass Base {\npublic:\n    virtual void show() { std::cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void show() override { std::cout << \"Derived\"; }\n};\nint main() {\n    Base* b = new Derived();\n    b->show();\n    delete b;\n    return 0;\n}\n```",
            "answer": "Derived",
            "explanation": "**Explanation:**\nDue to virtual function polymorphism, the Derived class's show() is called even though the pointer is of type Base\\*.\n[Reference](https://en.cppreference.com/w/cpp/language/virtual)",
            "hint": null,
            "correctAnswer": ["Derived"],
            "options": ["Base", "Derived", "Compilation error", "Undefined behavior"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b243c61681f81cad8350ff76",
            "question": "What is `std::enable_if` used for?",
            "answer": "For SFINAE-based conditional template instantiation",
            "explanation": "**Explanation:**\n`std::enable_if` is used for SFINAE (Substitution Failure Is Not An Error) to conditionally enable or disable template specializations.\n[Reference](https://en.cppreference.com/w/cpp/types/enable_if)",
            "hint": null,
            "correctAnswer": ["For SFINAE-based conditional template instantiation"],
            "options": [
              "To enable if statements",
              "For SFINAE-based conditional template instantiation",
              "To enable features",
              "To check if something is enabled"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c439c461f321db303395ab68",
            "question": "What is `std::tuple` in C++11?",
            "answer": "A fixed-size collection of heterogeneous values",
            "explanation": "**Explanation:**\n`std::tuple` is a fixed-size collection that can hold elements of different types, generalizing `std::pair` to any number of elements.\n[Reference](https://en.cppreference.com/w/cpp/utility/tuple)",
            "hint": null,
            "correctAnswer": ["A fixed-size collection of heterogeneous values"],
            "options": [
              "A two-element pair",
              "A fixed-size collection of heterogeneous values",
              "A triple of values",
              "A tuple in mathematics"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a67da1ce43146fb373003af3",
            "question": "What is the output of this code?\n```cpp\n#include <iostream>\nint main() {\n    int x = 10;\n    int& ref = x;\n    ref = 20;\n    std::cout << x;\n    return 0;\n}\n```",
            "answer": "20",
            "explanation": "**Explanation:**\nref is a reference to x. Modifying ref modifies x directly, so x becomes 20.\n[Reference](https://en.cppreference.com/w/cpp/language/reference)",
            "hint": null,
            "correctAnswer": ["20"],
            "options": ["10", "20", "Compilation error", "Undefined"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "85161d447d421a60e5b70bb5",
            "question": "What is `std::chrono` used for?",
            "answer": "Time utilities including clocks, time points, and durations",
            "explanation": "**Explanation:**\n`std::chrono` is a library for time-related operations, providing clocks, time points, and durations with type safety.\n[Reference](https://en.cppreference.com/w/cpp/chrono)",
            "hint": null,
            "correctAnswer": ["Time utilities including clocks, time points, and durations"],
            "options": [
              "Chronological ordering",
              "Time utilities including clocks, time points, and durations",
              "Chronometer functions",
              "Chronic disease management"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "34b427b1d68eba6899c985a7",
            "question": "What is `std::regex` in C++11?",
            "answer": "A library for regular expression pattern matching",
            "explanation": "**Explanation:**\n`std::regex` provides regular expression support for pattern matching and text processing in C++.\n[Reference](https://en.cppreference.com/w/cpp/regex)",
            "hint": null,
            "correctAnswer": ["A library for regular expression pattern matching"],
            "options": [
              "A regular expression engine",
              "A library for regular expression pattern matching",
              "A text replacement tool",
              "A string formatter"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e423cd80eddde783e589bc6b",
            "question": "What is `std::initializer_list`?",
            "answer": "A lightweight proxy object for accessing arrays of const T",
            "explanation": "**Explanation:**\n`std::initializer_list` allows functions to accept brace-enclosed lists of values, enabling uniform initialization syntax.\n[Reference](https://en.cppreference.com/w/cpp/utility/initializer_list)",
            "hint": null,
            "correctAnswer": ["A lightweight proxy object for accessing arrays of const T"],
            "options": [
              "A list of initializers",
              "A lightweight proxy object for accessing arrays of const T",
              "An initialization function",
              "A list constructor"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "507906d6af5f491d2f41c4a6",
            "question": "What is the output of this code?\n```cpp\n#include <iostream>\nint main() {\n    const int x = 10;\n    int* p = const_cast<int*>(&x);\n    *p = 20;\n    std::cout << x;\n    return 0;\n}\n```",
            "answer": "10 (undefined behavior)",
            "explanation": "**Explanation:**\nThis is undefined behavior. Modifying a const object through const_cast leads to unpredictable results. The compiler may optimize based on const assumption.\n[Reference](https://en.cppreference.com/w/cpp/language/const_cast)",
            "hint": null,
            "correctAnswer": ["10 (undefined behavior)"],
            "options": ["10 (undefined behavior)", "20", "Compilation error", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7fff8431a5b6c2cfba37f0c7",
            "question": "What is `std::function` in C++11?",
            "answer": "A general-purpose polymorphic function wrapper",
            "explanation": "**Explanation:**\n`std::function` is a type-erased wrapper that can store any callable object (function, lambda, functor) with a specific signature.\n[Reference](https://en.cppreference.com/w/cpp/utility/functional/function)",
            "hint": null,
            "correctAnswer": ["A general-purpose polymorphic function wrapper"],
            "options": [
              "A function declaration",
              "A general-purpose polymorphic function wrapper",
              "A function pointer",
              "A functional programming library"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "06ce5f9e78955c23a46854d9",
            "question": "What is `std::bind` used for?",
            "answer": "To create a new callable by binding arguments to a function",
            "explanation": "**Explanation:**\n`std::bind` creates a new function object by binding some arguments to a function, useful for partial function application.\n[Reference](https://en.cppreference.com/w/cpp/utility/functional/bind)",
            "hint": null,
            "correctAnswer": ["To create a new callable by binding arguments to a function"],
            "options": [
              "To bind variables together",
              "To create a new callable by binding arguments to a function",
              "To bind classes",
              "To bind memory"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "823a998a6857b6b88eef2c6b",
            "question": "What is `std::unordered_map` based on?",
            "answer": "Hash table",
            "explanation": "**Explanation:**\n`std::unordered_map` is implemented using a hash table, providing average O(1) lookup time compared to O(log n) for `std::map`.\n[Reference](https://en.cppreference.com/w/cpp/container/unordered_map)",
            "hint": null,
            "correctAnswer": ["Hash table"],
            "options": ["Binary search tree", "Hash table", "Linked list", "Array"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b62de08beea644af4f69c015",
            "question": "What is the output of this code?\n```cpp\n#include <iostream>\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    std::cout << sizeof(arr) / sizeof(arr[0]);\n    return 0;\n}\n```",
            "answer": "5",
            "explanation": "**Explanation:**\nsizeof(arr) gives total bytes, sizeof(arr[0]) gives bytes per element. Division gives number of elements: 5.\n[Reference](https://en.cppreference.com/w/cpp/language/sizeof)",
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["4", "5", "20", "1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4a73b69656346eeca4c0909d",
            "question": "What is `std::make_unique` in C++14?",
            "answer": "A function to create std::unique_ptr objects",
            "explanation": "**Explanation:**\n`std::make_unique` is a utility function that creates and returns a `std::unique_ptr`, providing exception safety and cleaner syntax.\n[Reference](https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique)",
            "hint": null,
            "correctAnswer": ["A function to create std::unique_ptr objects"],
            "options": [
              "A unique identifier generator",
              "A function to create std::unique_ptr objects",
              "A uniqueness checker",
              "A unique value creator"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "dbcc499eb8e03d3c0b04d770",
            "question": "What is `std::exchange` in C++14?",
            "answer": "Replaces a value and returns the old value atomically",
            "explanation": "**Explanation:**\n`std::exchange` replaces the value of an object and returns its old value in a single operation.\n[Reference](https://en.cppreference.com/w/cpp/utility/exchange)",
            "hint": null,
            "correctAnswer": ["Replaces a value and returns the old value atomically"],
            "options": [
              "A value exchange program",
              "Replaces a value and returns the old value atomically",
              "An exchange operator",
              "A swap function"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5bcf763aebe02b16f427265e",
            "question": "What is `std::apply` in C++17?",
            "answer": "Invokes a callable with a tuple of arguments",
            "explanation": "**Explanation:**\n`std::apply` invokes a callable object with a tuple of arguments, unpacking the tuple as function arguments.\n[Reference](https://en.cppreference.com/w/cpp/utility/apply)",
            "hint": null,
            "correctAnswer": ["Invokes a callable with a tuple of arguments"],
            "options": [
              "An application launcher",
              "Invokes a callable with a tuple of arguments",
              "An apply function",
              "A function applicator"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "702014ff2c881d61daeaf1a7",
            "question": "What is the output of this code?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    int y = ++x + x++;\n    std::cout << y;\n    return 0;\n}\n```",
            "answer": "Undefined behavior",
            "explanation": "**Explanation:**\nModifying x multiple times between sequence points leads to undefined behavior. The result is unpredictable.\n[Reference](https://en.cppreference.com/w/cpp/language/eval_order)",
            "hint": null,
            "correctAnswer": ["Undefined behavior"],
            "options": ["11", "12", "Undefined behavior", "13"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2ac8b6bc6357e086e104a280",
            "question": "What is `std::decay` in C++11?",
            "answer": "Applies array-to-pointer, function-to-pointer, and removes cv-qualifiers",
            "explanation": "**Explanation:**\n`std::decay` applies type transformations similar to what happens when passing arguments by value.\n[Reference](https://en.cppreference.com/w/cpp/types/decay)",
            "hint": null,
            "correctAnswer": [
              "Applies array-to-pointer, function-to-pointer, and removes cv-qualifiers"
            ],
            "options": [
              "A decay function",
              "Applies array-to-pointer, function-to-pointer, and removes cv-qualifiers",
              "A deprecation marker",
              "A decay constant"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6ae49f95214d1d899e6e3706",
            "question": "What is `std::conditional` in C++11?",
            "answer": "Chooses one type or another based on a compile-time boolean",
            "explanation": "**Explanation:**\n`std::conditional` is a metafunction that selects one of two types based on a compile-time boolean condition.\n[Reference](https://en.cppreference.com/w/cpp/types/conditional)",
            "hint": null,
            "correctAnswer": ["Chooses one type or another based on a compile-time boolean"],
            "options": [
              "A conditional statement",
              "Chooses one type or another based on a compile-time boolean",
              "A conditional operator",
              "A condition checker"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "69af74b498bd4c3232dd03ca",
            "question": "What is `std::is_same` used for?",
            "answer": "To check if two types are the same at compile time",
            "explanation": "**Explanation:**\n`std::is_same` is a type trait that checks if two types are identical at compile time.\n[Reference](https://en.cppreference.com/w/cpp/types/is_same)",
            "hint": null,
            "correctAnswer": ["To check if two types are the same at compile time"],
            "options": [
              "To check if values are the same",
              "To check if two types are the same at compile time",
              "To compare objects",
              "To check sameness"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1b23984af735eb05d823da0d",
            "question": "What is the output of this code?\n```cpp\n#include <iostream>\nint main() {\n    int x = 10;\n    int* p = &x;\n    int** pp = &p;\n    std::cout << **pp;\n    return 0;\n}\n```",
            "answer": "10",
            "explanation": "**Explanation:**\npp is a pointer to pointer. \\*\\*pp dereferences twice to get the value of x, which is 10.\n[Reference](https://en.cppreference.com/w/cpp/language/pointer)",
            "hint": null,
            "correctAnswer": ["10"],
            "options": ["10", "Address of x", "Address of p", "Compilation error"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1f249b98e7bb69d9664d495c",
            "question": "What is `std::remove_if` used for?",
            "answer": "To remove elements from a range that satisfy a predicate",
            "explanation": "**Explanation:**\n`std::remove_if` removes elements from a range that satisfy a given predicate, used with erase for actual deletion.\n[Reference](https://en.cppreference.com/w/cpp/algorithm/remove)",
            "hint": null,
            "correctAnswer": ["To remove elements from a range that satisfy a predicate"],
            "options": [
              "To remove if statements",
              "To remove elements from a range that satisfy a predicate",
              "To conditionally remove files",
              "To remove conditions"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1acea54de7293630d4000f64",
            "question": "What is `std::transform` used for?",
            "answer": "To apply a function to a range and store results in another range",
            "explanation": "**Explanation:**\n`std::transform` applies a given function to a range of elements and stores the result in another range.\n[Reference](https://en.cppreference.com/w/cpp/algorithm/transform)",
            "hint": null,
            "correctAnswer": ["To apply a function to a range and store results in another range"],
            "options": [
              "To transform code",
              "To apply a function to a range and store results in another range",
              "To transform types",
              "To perform transformations"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a02e8c7b337d3305bb1fa70c",
            "question": "What is `std::accumulate` used for?",
            "answer": "To compute the sum or fold a range of elements",
            "explanation": "**Explanation:**\n`std::accumulate` computes the sum of a range of elements or applies a binary operation to fold the range.\n[Reference](https://en.cppreference.com/w/cpp/algorithm/accumulate)",
            "hint": null,
            "correctAnswer": ["To compute the sum or fold a range of elements"],
            "options": [
              "To accumulate errors",
              "To compute the sum or fold a range of elements",
              "To accumulate data",
              "To add numbers"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3fc247298194729c4807f11b",
            "question": "What is the output of this code?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    int y = 10;\n    int z = x > y ? x : y;\n    std::cout << z;\n    return 0;\n}\n```",
            "answer": "10",
            "explanation": "**Explanation:**\nThe ternary operator checks if x > y. Since it's false, z is assigned y, which is 10.\n[Reference](https://en.cppreference.com/w/cpp/language/operator_other)",
            "hint": null,
            "correctAnswer": ["10"],
            "options": ["5", "10", "1", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "966fcabeb1941d420d592eb1",
            "question": "What is `std::copy` used for?",
            "answer": "To copy elements from one range to another",
            "explanation": "**Explanation:**\n`std::copy` copies elements from a source range to a destination range.\n[Reference](https://en.cppreference.com/w/cpp/algorithm/copy)",
            "hint": null,
            "correctAnswer": ["To copy elements from one range to another"],
            "options": [
              "To copy files",
              "To copy elements from one range to another",
              "To duplicate objects",
              "To copy memory"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "469b065bdf91bb44c2d2fb6a",
            "question": "What is `std::find` used for?",
            "answer": "To find the first occurrence of a value in a range",
            "explanation": "**Explanation:**\n`std::find` searches for the first occurrence of a value in a range and returns an iterator to it.\n[Reference](https://en.cppreference.com/w/cpp/algorithm/find)",
            "hint": null,
            "correctAnswer": ["To find the first occurrence of a value in a range"],
            "options": [
              "To find files",
              "To find the first occurrence of a value in a range",
              "To search for patterns",
              "To locate objects"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cd47b452948dcb34c471841b",
            "question": "What is `std::sort` based on?",
            "answer": "Introsort (hybrid of quicksort, heapsort, and insertion sort)",
            "explanation": "**Explanation:**\n`std::sort` typically uses introsort, which combines quicksort, heapsort, and insertion sort for optimal performance.\n[Reference](https://en.cppreference.com/w/cpp/algorithm/sort)",
            "hint": null,
            "correctAnswer": ["Introsort (hybrid of quicksort, heapsort, and insertion sort)"],
            "options": [
              "Bubble sort",
              "Introsort (hybrid of quicksort, heapsort, and insertion sort)",
              "Merge sort only",
              "Selection sort"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "72108542c89d92f9ded64a9c",
            "question": "What is the output of this code?\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\nint main() {\n    std::vector<int> v = {5, 2, 8, 1, 9};\n    std::sort(v.begin(), v.end());\n    std::cout << v[2];\n    return 0;\n}\n```",
            "answer": "5",
            "explanation": "**Explanation:**\nAfter sorting, the vector becomes {1, 2, 5, 8, 9}. v[2] is the third element, which is 5.\n[Reference](https://en.cppreference.com/w/cpp/algorithm/sort)",
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["8", "2", "5", "1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9dd16826d7c987a304b8e7fc",
            "question": "In modern C++ (C++17 and above), what does the `std::optional<T>` class template help achieve in function design?",
            "answer": "It provides a type-safe way to represent a value that may or may not be present, avoiding the need for sentinel values or pointers",
            "explanation": "**Explanation:**\n`std::optional<T>` represents an optional value — it either contains a value of type `T` or nothing (`std::nullopt`). It’s safer than returning `nullptr` or using flags for missing values.",
            "hint": null,
            "correctAnswer": [
              "It provides a type-safe way to represent a value that may or may not be present, avoiding the need for sentinel values or pointers"
            ],
            "options": [
              "It provides a type-safe way to represent a value that may or may not be present, avoiding the need for sentinel values or pointers",
              "It allows multiple values of the same type to be returned simultaneously",
              "It replaces the need for exception handling in all cases",
              "It is used to store polymorphic objects dynamically"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5dbc3efa7e7bb2706841ae03",
            "question": "What happens if a class has a virtual destructor but the base class pointer deletes an object of a derived class that has already been partially destructed?",
            "answer": "Undefined behavior — deleting an already destructed object leads to double destruction and memory corruption",
            "explanation": "**Explanation:**\nOnce an object is destructed, any subsequent deletion of the same memory through a base pointer leads to undefined behavior — even if destructors are virtual.",
            "hint": null,
            "correctAnswer": [
              "Undefined behavior — deleting an already destructed object leads to double destruction and memory corruption"
            ],
            "options": [
              "Undefined behavior — deleting an already destructed object leads to double destruction and memory corruption",
              "The base class destructor will be called twice safely",
              "The compiler automatically prevents deletion of derived objects",
              "The derived destructor will execute twice but without side effects"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b3b41b182d5af0f23cd6de83",
            "question": "In C++20, which of the following best describes the role of **concepts**?",
            "answer": "They constrain template parameters to ensure that only types meeting specific requirements can be used",
            "explanation": "**Explanation:**\nConcepts provide **compile-time constraints** for templates, improving error messages and enforcing type correctness. For example, `template <Sortable T>` ensures the type meets the `Sortable` concept’s requirements.",
            "hint": null,
            "correctAnswer": [
              "They constrain template parameters to ensure that only types meeting specific requirements can be used"
            ],
            "options": [
              "They constrain template parameters to ensure that only types meeting specific requirements can be used",
              "They define runtime type checks for polymorphic objects",
              "They replace templates with runtime dispatching",
              "They allow implicit conversions between template types"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9a6a1774cc89a2ef63306373",
            "question": "What is the purpose of the **placement new** operator in C++?",
            "answer": "It constructs an object at a specific pre-allocated memory address",
            "explanation": "**Explanation:**\nPlacement new allows you to explicitly specify the address where an object should be constructed, e.g. `new (buffer) MyClass();`. It’s used in performance-critical systems and custom memory allocators.",
            "hint": null,
            "correctAnswer": ["It constructs an object at a specific pre-allocated memory address"],
            "options": [
              "It constructs an object at a specific pre-allocated memory address",
              "It allocates memory on the heap and initializes the object",
              "It creates multiple objects in a single memory block automatically",
              "It performs garbage collection for dynamic memory"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5c1aff5a2268e393d7e23a84",
            "question": "Suppose two threads access a shared variable without synchronization — one writes while the other reads. In C++, what is this condition called, and what does the standard say about it?",
            "answer": "It’s a data race, leading to undefined behavior under the C++ memory model",
            "explanation": "**Explanation:**\nC++ defines **data races** as undefined behavior. Concurrent unsynchronized reads and writes on the same memory violate the memory model’s atomicity rules.",
            "hint": null,
            "correctAnswer": [
              "It’s a data race, leading to undefined behavior under the C++ memory model"
            ],
            "options": [
              "It’s a data access warning but still well-defined behavior",
              "It’s a data race, leading to undefined behavior under the C++ memory model",
              "It’s automatically handled by the compiler’s memory barrier insertion",
              "It’s only a problem if both threads write to the same variable"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ee36ea1178227690604e9ca7",
            "question": "In C++, which of the following statements is TRUE about the virtual keyword when used with destructors?",
            "answer": "A virtual destructor allows correct destruction of derived objects through a base class pointer.",
            "explanation": "**Explanation:**\nA virtual destructor is needed so that when you delete an object using a base class pointer, the derived class destructor also runs. Without this, you get memory leaks or undefined behavior.",
            "hint": null,
            "correctAnswer": [
              "A virtual destructor allows correct destruction of derived objects through a base class pointer."
            ],
            "options": [
              "A virtual destructor prevents object slicing automatically.",
              "A virtual destructor ensures that dynamic binding happens for all member functions in the class.",
              "A virtual destructor allows correct destruction of derived objects through a base class pointer.",
              "A virtual destructor makes the class abstract automatically."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "591748873cf8d227306a1b1b",
            "question": "Which of the following correctly describes the behavior of static members in a C++ class?",
            "answer": "Static data members are shared by all objects of the class and exist even if no objects are created.",
            "explanation": "**Explanation:**\nStatic members belong to the class, so every object shares the same copy and they are created even before any object exists and live for the entire program.",
            "hint": null,
            "correctAnswer": [
              "Static data members are shared by all objects of the class and exist even if no objects are created."
            ],
            "options": [
              "Each object gets its own copy of every static data member.",
              "Static data members are shared by all objects of the class and exist even if no objects are created.",
              "Static member functions can access both static and non-static members directly.",
              "Static data members must be initialized inside the constructor of the class."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-en",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          }
        ]
      },
      {
        "id": "72f5aa2d090f4b90bc8be471-es",
        "language": "es",
        "title": "C++",
        "description": "Seeded from c++/c++-quiz-es.md",
        "questions": [
          {
            "id": "123173709decbc61033882d7",
            "question": "¿Cuál es la salida de este código?\n```cpp\nvector<int> v(22);\nbool b = (v[6]);\nprintf(\"%d\", !b);\n```",
            "answer": "1",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["Falso", "0", "1", "Este código tiene un error."],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "70649df81ef86b794c08a88b",
            "question": "¿Cuál de las siguientes es una razón por la que usar esta línea se considera una mala práctica? (_Alternativa_: ¿Por qué usar esta línea se considera una mala práctica?)\n```cpp\nusing namespace std;\n```",
            "answer": "Si el código utiliza una función definida en dos bibliotecas diferentes con el mismo prototipo pero posiblemente con diferentes implementaciones, habrá un error de compilación debido a la ambigüedad.",
            "explanation": "[Referencia](https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/)",
            "hint": null,
            "correctAnswer": [
              "Si el código utiliza una función definida en dos bibliotecas diferentes con el mismo prototipo pero posiblemente con diferentes implementaciones, habrá un error de compilación debido a la ambigüedad."
            ],
            "options": [
              "El código compilado siempre es más grande debido a todos los símbolos importados.",
              "Si el código utiliza una función definida en dos bibliotecas diferentes con el mismo prototipo pero posiblemente con diferentes implementaciones, habrá un error de compilación debido a la ambigüedad.",
              "Incluye automáticamente todos los archivos de encabezado en la biblioteca estándar (cstdint, cstdlib, cstdio, iostream, etc).",
              "Hace que el compilador aplique la inclusión exclusiva de archivos de encabezado pertenecientes a la biblioteca estándar, generando un error de compilación cuando se incluye un archivo de encabezado diferente."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a992dfaf44cdc6b267edc070",
            "question": "¿Cuál es el tamaño más pequeño que una variable de tipo child_t puede ocupar en memoria?\n```cpp\ntypedef struct{\n    unsigned int  age    : 4;\n    unsigned char gender : 1;\n    unsigned int  size   : 2;\n}child_t;\n```",
            "answer": "1 byte.",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": ["1 byte."],
            "options": ["7 bits.", "25 bytes.", "1 bit.", "1 byte."],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "834a86b1bb4316254b3252ff",
            "question": "¿Cuáles son los vectores v1 y v2 después de ejecutar el código?\n```cpp\nstd::vector<int> v1{1,2,3},v2;\nv2=v1;\nv1.push_back(4);\nv2.push_back(5);\n```",
            "answer": "v1:{1,2,3,4}; v2:{1,2,3,5};",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["v1:{1,2,3,4}; v2:{1,2,3,5};"],
            "options": [
              "Error",
              "v1:{1,2,3,4}; v2:{5};",
              "v1:{1,2,3,4,5}; v2:{1,2,3,4,5};",
              "v1:{1,2,3,4}; v2:{1,2,3,5};"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8689eb871781447b05a4a434",
            "question": "¿Cuál de las siguientes es una afirmación verdadera sobre la diferencia entre punteros e iteradores?",
            "answer": "Incrementar un iterador siempre significa acceder al siguiente elemento en el contenedor (si existe), sin importar el contenedor. Incrementar el puntero significa apuntar al siguiente elemento en memoria, no siempre el siguiente elemento.",
            "explanation": "[Referencia](https://stackoverflow.com/a/31128162)",
            "hint": null,
            "correctAnswer": [
              "Incrementar un iterador siempre significa acceder al siguiente elemento en el contenedor (si existe), sin importar el contenedor. Incrementar el puntero significa apuntar al siguiente elemento en memoria, no siempre el siguiente elemento."
            ],
            "options": [
              "Mientras que los punteros son variables que contienen direcciones de memoria, los iteradores son funciones genéricas utilizadas para recorrer contenedores. Esta función permite al programador implementar código de lectura y escritura mientras se recorre el contenedor.",
              "Incrementar un iterador siempre significa acceder al siguiente elemento en el contenedor (si existe), sin importar el contenedor. Incrementar el puntero significa apuntar al siguiente elemento en memoria, no siempre el siguiente elemento.",
              "Los punteros son variables que contienen direcciones de memoria, mientras que el iterador son enteros sin signo que se refieren a desplazamientos en arreglos.",
              "Todos los iteradores se implementan con punteros, por lo que todos los iteradores son punteros, pero no todos los punteros son iteradores."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2e29b80d327739b12830ca69",
            "question": "¿Cuál es el almacenamiento ocupado por u1?\n```cpp\nunion {\n    uint16_t a;\n    uint32_t b;\n    int8_t c;\n} u1;\n```",
            "answer": "4 bytes",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/language/union)",
            "hint": null,
            "correctAnswer": ["4 bytes"],
            "options": ["4 bytes", "7 bytes", "8 bytes", "2 bytes"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ce526017efd8ed77609dc7c6",
            "question": "¿Cuál de los siguientes operadores puede ser sobrecargado?",
            "answer": "`new`",
            "explanation": "[Referencia](https://www.tutorialspoint.com/operators-that-cannot-be-overloaded-in-cplusplus)",
            "hint": null,
            "correctAnswer": ["`new`"],
            "options": ["`?:`", "`new`", "`::`", "`.`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6a254d9b06643dda50ba2b27",
            "question": "¿Cuál de las siguientes muestra el contenido del vector apuntado por v1 y v2 después de ejecutar este código?\n```cpp\nstd:: vector<int> *v1 = new std::vector<int>({1,2,3});\nstd:: vector<int> *v2;\nv2=v1;\nv1->push_back(4);\nv2->push_back(5);\n```",
            "answer": "`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`",
            "explanation": "v1 y v2 apuntan al mismo vector.",
            "hint": null,
            "correctAnswer": ["`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`"],
            "options": [
              "`*v1:{1,2,3,4}; *v2:{5};`",
              "`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`",
              "Error",
              "`*v1:{1,2,3,4}; *v2:{1,2,3,5};`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "042b95c05f2b12cae814b431",
            "question": "¿Cuál de las siguientes NO es una diferencia entre una clase y una estructura?",
            "answer": "Los parámetros de tipo de plantilla se pueden declarar con clases, pero no con la palabra clave struct.",
            "explanation": "Las plantillas se pueden usar tanto con clases como con estructuras\n[Referencia](https://docs.microsoft.com/en-us/cpp/cpp/struct-cpp?view=msvc-170)\n[Referencia](https://www.fluentcpp.com/2017/06/13/the-real-difference-between-struct-class/)",
            "hint": null,
            "correctAnswer": [
              "Los parámetros de tipo de plantilla se pueden declarar con clases, pero no con la palabra clave struct."
            ],
            "options": [
              "Debido a que las estructuras son parte del lenguaje de programación C, hay cierta complejidad entre las estructuras de C y C++. Este no es el caso con las clases.",
              "Las clases pueden tener funciones miembro; las estructuras son privadas.",
              "El especificador de acceso predeterminado para miembros de una estructura es público, mientras que para miembros de la clase es privado.",
              "Los parámetros de tipo de plantilla se pueden declarar con clases, pero no con la palabra clave struct."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a8c0eeb10fecf5847982a4d7",
            "question": "Suponga que necesita mantener una estructura de datos con permiso para acceder a algún recurso basado en los días de la semana, pero no puede usar una variable bool para cada día. Necesita usar un bit por día de la semana. ¿Cuál de las siguientes es una implementación correcta de una estructura con campos de bits para esta aplicación?",
            "answer": "A",
            "explanation": "```cpp\ntypedef struct {\nint sunday:1;\nint monday:1;\n// más días\nint friday:1;\nint saturday:1;\n} weekdays;\n```\n```cpp\ntypedef char[7]: weekdays;\n```\n```cpp\ntypedef struct {\nbit sunday:1;\nbit monday:1;\n// más días\nbit friday:1;\nbit saturday:1;\n} weekdays;\n```\n```cpp\ntypedef struct {\nbit sunday;\nbit monday;\n// más días\nbit friday;\nbit saturday;\n} weekdays;\n```\n[Referencia](https://en.cppreference.com/w/cpp/language/bit_field) _NOTA_: La sintaxis correcta es que cada variable tiene un tamaño de 1 bit. `bit` no es un tipo en C++.",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d5f29a0f6e45ef25a3eaa191",
            "question": "¿Qué es un lvalue?",
            "answer": "Es un valor de ubicación, es decir, una dirección de memoria adecuada para asignar a un puntero o referencia.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Es un valor de ubicación, es decir, una dirección de memoria adecuada para asignar a un puntero o referencia."
            ],
            "options": [
              "Es una expresión constante, es decir, una expresión compuesta de constantes y operaciones.",
              "Es una expresión que representa un objeto con una dirección.",
              "Es una expresión adecuada para el operando del lado izquierdo en una operación binaria.",
              "Es un valor de ubicación, es decir, una dirección de memoria adecuada para asignar a un puntero o referencia."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d1f3f28b2bdb67ccfab7a8f0",
            "question": "¿Qué hace el especificador de tipo auto en esta línea de código (desde C++11)?\n```cpp\nauto x = 4000.22;\n```",
            "answer": "Especifica que el tipo de x se deducirá del inicializador - en este caso, double.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Especifica que el tipo de x se deducirá del inicializador - en este caso, double."
            ],
            "options": [
              "Especifica que el tipo de x se deducirá del inicializador - en este caso, double.",
              "Especifica que el tipo de x es automático, lo que significa que puede ser asignado a diferentes tipos de datos a lo largo del programa.",
              "Especifica que x es una variable con duración de almacenamiento automático.",
              "Especifica que se asignará más memoria para x en caso de que necesite más espacio, evitando la pérdida de datos debido al desbordamiento."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0dfe2c96bc122fa9ee4a2b8e",
            "question": "Una plantilla de clase es ¿qué?",
            "answer": "Una clase escrita con el paradigma de programación genérica, especificando comportamiento en términos de parámetro de tipo en lugar de tipo específico.",
            "explanation": "[Referencia](https://www.mygreatlearning.com/blog/templates-in-cpp/)",
            "hint": null,
            "correctAnswer": [
              "Una clase escrita con el paradigma de programación genérica, especificando comportamiento en términos de parámetro de tipo en lugar de tipo específico."
            ],
            "options": [
              "Una clase escrita con el paradigma de programación genérica, especificando comportamiento en términos de parámetro de tipo en lugar de tipo específico.",
              "Una superclase en blanco destinada a la herencia y el polimorfismo.",
              "Una clase que solo consiste en una variable miembro, sin constructor, destructor o funciones miembro.",
              "Código fuente esqueleto para una clase donde el programador debe completar partes específicas para definir los tipos de datos y algoritmos utilizados."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "48725347d042b3480c7d70e5",
            "question": "¿Cuál es el operador ternario equivalente a este fragmento de código?\n```cpp\nif(x)\n    y=a;\nelse\n    y=b;\n```",
            "answer": "`y=x?a:b;`",
            "explanation": "[Referencia](https://www.w3schools.com/cpp/cpp_conditions_shorthand.asp)",
            "hint": null,
            "correctAnswer": ["`y=x?a:b;`"],
            "options": ["`y=a?b:x;`", "`y=if(x?a:b);`", "`y=(x&a)?a:(x&b)?b:0;`", "`y=x?a:b;`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d752de0474c504a28ce034b1",
            "question": "¿Cuál es la salida del código dado a continuación?\n```cpp\n#include <iostream>\nint main(){\n    int x=10, y=20;\n    std::cout << \"x = \" << x++ << \" and y = \" << --y << std::endl;\n    std::cout << \"x = \" << x-- << \" and y = \" << ++y << std::endl;\n    return(0);\n}\n```",
            "answer": "`x = 10 and y = 19`",
            "explanation": "`x = 11 and y = 19`\n`x = 10 and y = 20`\n`x = 11 and y = 20`\n`x = 10 and y = 19`",
            "hint": null,
            "correctAnswer": ["`x = 10 and y = 19`"],
            "options": [
              "`x = 10 and y = 20`",
              "`x = 11 and y = 19`",
              "`x = 10 and y = 19`",
              "`x = 11 and y = 20`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fa8ec4a21ff8bb65601ff4cf",
            "question": "¿Cuál es el significado de las dos partes especificadas entre paréntesis en un bucle for basado en rango, separadas por dos puntos?",
            "answer": "La primera es una declaración de variable que contendrá un elemento en una secuencia. La segunda es la secuencia a recorrer.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "La primera es una declaración de variable que contendrá un elemento en una secuencia. La segunda es la secuencia a recorrer."
            ],
            "options": [
              "La primera es una declaración de variable que contendrá un elemento en una secuencia. La segunda es la secuencia a recorrer.",
              "La primera es un iterador, y la segunda es el valor de incremento que se agregará al iterador.",
              "La primera es la variable iteradora. La segunda es un `std::pair` que especifica el rango (inicio y fin) en el que la variable iterará.",
              "La primera es un objeto contenedor. La segunda es un `std::pair` que especifica el rango (inicio y fin) en el que se accederá a los elementos dentro del bucle."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "dbd608a2e6d3bf7df430cbb2",
            "question": "¿Cuál es la salida del código dado a continuación?\n```cpp\nint8_t a=200;\nuint8_t b=100;\nif(a>b)\n    std::cout<<\"greater\";\nelse\n    std::cout<<\"less\";\n```",
            "answer": "less",
            "explanation": "Nota: una variante de la pregunta a continuación.",
            "hint": null,
            "correctAnswer": ["less"],
            "options": [
              "No hay salida porque hay una excepción al comparar un int8_t con un uint8_t.",
              "greater",
              "less",
              "No hay salida porque hay un error del compilador."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fc76ec2110e349b41df76166",
            "question": "¿Cuál es la salida de este bloque de código?\n```cpp\nint8_t a=200;\nuint8_t b=100;\nstd::cout<<\"a=\"<<(int)a;\nstd::cout<<\", b=\"<<(int)b;\n```",
            "answer": "a=-56, b=100",
            "explanation": "Nota: Conversión implícita de 'int' a 'int8_t' (también conocido como 'signed char') cambia el valor de 200 a -56",
            "hint": null,
            "correctAnswer": ["a=-56, b=100"],
            "options": ["a=-56, b=100", "a=-55, b=100", "a=200, b=-156", "a=200, b=100"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "87a661e6e9531c7520d6c1fe",
            "question": "¿Cuál es la salida después de ejecutar este fragmento de código?\n```cpp\nint x=5, y=2;\nif(x & y) {\n    /*_parte A_*/\n}\nelse {\n    /*_parte B_*/\n}\n```",
            "answer": "La parte B se ejecuta porque (x & y) resulta en 0, o falso.",
            "explanation": "[Referencia](https://stackoverflow.com/questions/63867765/dont-understand-why-if-5-2-is-false)",
            "hint": null,
            "correctAnswer": ["La parte B se ejecuta porque (x & y) resulta en 0, o falso."],
            "options": [
              "La parte A se ejecuta porque x==5 (verdadero) e y==2 (verdadero), por lo tanto la operación AND se evalúa como verdadero.",
              "La parte B se ejecuta porque (x & y) resulta en 0, o falso.",
              "La parte A se ejecuta porque (x & y) resulta en un valor distinto de cero, o verdadero.",
              "La parte B se ejecuta porque la declaración (x & y) no es válida, por lo tanto falso."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e5c19c591bc545884f62a6f8",
            "question": "¿Cuál es una definición válida para la función `get_length`, que devuelve la longitud de una cadena terminada en nulo?",
            "answer": "A",
            "explanation": "```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str[count++]);\nreturn count-1;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str!=NULL){\ncount++;\nstr++;\n}\nreturn count;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile((*str)++)\ncount++;\nreturn count;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str++)\ncount++;\nreturn count;\n}\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "16e1e99f19e6e141c9ba8565",
            "question": "¿Qué clase STL es la más adecuada para implementar una colección de datos que siempre está ordenada de modo que la operación pop siempre obtenga el mayor de los elementos? Suponga que solo está interesado en las operaciones push y pop.",
            "answer": "`std::priority_queue`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`std::priority_queue`"],
            "options": ["`std::list`", "`std::vector`", "`std::priority_queue`", "`std::map`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "35a8dda7216aad49c76af009",
            "question": "¿Cuál es el significado de las tres secciones especificadas entre paréntesis en un bucle for separadas por punto y coma?",
            "answer": "La primera es el bloque de inicialización, la segunda es la condición para iterar, y la tercera es el bloque de incremento.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "La primera es el bloque de inicialización, la segunda es la condición para iterar, y la tercera es el bloque de incremento."
            ],
            "options": [
              "La primera es el nombre de la variable iteradora, la segunda es el número de veces a iterar, y la tercera es el incremento o decremento deseado (especificado con un entero con signo).",
              "La primera es el bloque de inicialización, la segunda es la condición para iterar, y la tercera es el bloque de incremento.",
              "La primera es la variable iteradora, la segunda es el contenedor en el que debe operar, y la tercera es una condición de salida para abortar en cualquier momento.",
              "La primera es el nombre de la variable iteradora, la segunda es el valor inicial para la variable iteradora, y la tercera es el valor de parada (el último valor más uno)."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8460d3150b1386ed7663286b",
            "question": "¿Qué imprime este código?\n```cpp\nint i = 0;\nprintf(\"%d\", i++);\nprintf(\"%d\", i--);\nprintf(\"%d\", ++i);\nprintf(\"%d\", --i);\n```",
            "answer": "0,1,1,0",
            "explanation": "[Referencia](https://www.geeksforgeeks.org/pre-increment-and-post-increment-in-c/)",
            "hint": null,
            "correctAnswer": ["0,1,1,0"],
            "options": ["0,1,1,0", "0,1,0,1", "0,0,1,0", "1,0,1,0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b11515a9213b69cb54835761",
            "question": "¿Qué es verdad sobre la variable llamada `ptr`?\n```cpp\nvoid *ptr;\n```",
            "answer": "Es un puntero a un valor sin tipo específico, por lo que puede ser convertido para apuntar a cualquier tipo.",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/language/pointer)",
            "hint": null,
            "correctAnswer": [
              "Es un puntero a un valor sin tipo específico, por lo que puede ser convertido para apuntar a cualquier tipo."
            ],
            "options": [
              "Es un puntero inicializado en NULL.",
              "Es un puntero a una función void.",
              "Esa declaración causa un error del compilador, ya que los punteros deben especificar un tipo.",
              "Es un puntero a un valor sin tipo específico, por lo que puede ser convertido para apuntar a cualquier tipo."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d638826a7b896be3f444cc11",
            "question": "¿Cuál es la salida del código dado a continuación?\n```cpp\nint c=3; char d='A';\nstd::printf(\"c is %d and d is %c\",c,d);\n```",
            "answer": "c is 3 and d is A",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["c is 3 and d is A"],
            "options": [
              "c is d and d is c",
              "c is A and d is 3",
              "c is 3 and d is A",
              "c is c and d is d"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "53b550ba512d577c0a282eb7",
            "question": "¿Cuál es la salida de este código?\n```cpp\nprintf(\"1/2 = %f\",(float)(1/2));\n```",
            "answer": "1/2 = 0.000000",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["1/2 = 0.000000"],
            "options": ["1/2 = 0.499999", "1/2 = 0", "1/2 = 0.000000", "1/2 = 0.5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "00df4ea82dbc782057fc42d5",
            "question": "¿Cuál es la diferencia entre un miembro de clase público y uno privado?",
            "answer": "Los miembros públicos pueden ser accedidos por cualquier función. Los miembros privados solo pueden ser accedidos por las funciones miembro de la misma clase y los amigos de la clase.",
            "explanation": "[Referencia](https://www.geeksforgeeks.org/difference-between-public-and-private-in-c-with-example/)",
            "hint": null,
            "correctAnswer": [
              "Los miembros públicos pueden ser accedidos por cualquier función. Los miembros privados solo pueden ser accedidos por las funciones miembro de la misma clase y los amigos de la clase."
            ],
            "options": [
              "Los miembros públicos son iguales a las variables globales, por lo que cada parte del código tiene acceso a ellos. Los miembros privados son iguales a las variables automáticas, por lo que solo su clase tiene acceso a ellos.",
              "Los miembros públicos son accesibles a cualquier aplicación en ejecución. Los miembros privados son accesibles solo a la aplicación donde se instancia el objeto.",
              "Los miembros públicos se compilarán como variables compartidas en un entorno multihilo. Los miembros privados se compilarán como variables locales de hilo.",
              "Los miembros públicos pueden ser accedidos por cualquier función. Los miembros privados solo pueden ser accedidos por las funciones miembro de la misma clase y los amigos de la clase."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "77ae19249718ac8fdc2d5634",
            "question": "¿Cuál es el valor de `x` después de ejecutar este código?\n```cpp\nint x=10, a=-3;\nx+=a;\n```",
            "answer": "7",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["7"],
            "options": ["3", "7", "-3", "13"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "de8975cc097c3074e16b2e29",
            "question": "¿Cuál afirmación es verdadera?",
            "answer": "C++ soporta herencia múltiple.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C++ soporta herencia múltiple."],
            "options": [
              "Solo las clases pueden tener variables miembro y métodos.",
              "C++ soporta herencia múltiple.",
              "C++ soporta solo herencia simple.",
              "Solo las estructuras pueden heredar."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3b599289cc057f296dddafa4",
            "question": "Considere un puntero a void, llamado `ptr`, que ha sido configurado para apuntar a una variable de punto flotante `g`. ¿Cuál opción es una forma válida de desreferenciar `ptr` para asignar su valor apuntado a una variable float `f` más adelante en el programa?\n```cpp\nfloat g;\nvoid *ptr=&g;\n```",
            "answer": "`float f=*(float *)ptr;`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`float f=*(float *)ptr;`"],
            "options": [
              "`float f=*(float)ptr;`",
              "`float f=(float *)ptr;`",
              "`float f=(float)*ptr;`",
              "`float f=*(float *)ptr;`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3bac6d41525d14ccf6826b7b",
            "question": "¿Qué es el operador `.*` y qué hace?",
            "answer": "Es el operador de puntero a miembro, y permite acceder a un miembro de un objeto a través de un puntero a ese miembro de clase específico.",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/language/operator_member_access)",
            "hint": null,
            "correctAnswer": [
              "Es el operador de puntero a miembro, y permite acceder a un miembro de un objeto a través de un puntero a ese miembro de clase específico."
            ],
            "options": [
              "Es lo mismo que el operador de acceso a miembro de clase, o operador de flecha `(->)`, que permite acceder a un miembro de un objeto a través de un puntero al objeto.",
              "Es el operador de puntero a miembro, y permite acceder a un miembro de un objeto a través de un puntero a ese miembro de clase específico.",
              "Es el operador de acceso a miembro con dirección del operador, que devuelve la dirección de un miembro de clase o estructura.",
              "Es una combinación del operador de acceso a miembro `(.)` y el operador de desreferencia `(*)`, por lo que permite acceder al objeto al que apunta un puntero de miembro."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7770e2487ca0d5eb19a4464d",
            "question": "Para estas declaraciones, ¿cuál opción muestra cuatro formas equivalentes de asignar el carácter \"y\" en la cadena a una variable char c?\n```cpp\nchar buff[50] = \"strings as arrays of characters are fun!\"\nchar *str = buff+11;\nchar c;\n```",
            "answer": "C",
            "explanation": "```cpp\nc = buff[16];\nc = str[5];\nc = *(buff+16);\nc = *(str+5);\n```\n```cpp\nc = *(buff[15]);\nc = *(str[4]);\nc = buff+15;\nc = str+4;\n```\n```cpp\nc = buff[15];\nc = str[4];\nc = *(buff+15);\nc = *(str+4);\n```\n```cpp\nc = *(buff[16]);\nc = *(str[5]);\nc = buff+16;\nc = str+5;\n```",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f0f73c62c81aeb7965677e9a",
            "question": "¿Cuál opción es la declaración correcta para la clase llamada Dog, derivada de la clase Animal?\n```cpp\nclass Animal{\n    //....\n}\n```",
            "answer": "B",
            "explanation": "```cpp\nclass Dog :: public Animal {\n//....\n};\n```\n```cpp\nclass Dog : public Animal {\n//....\n};\n```\n```cpp\npublic class Animal :: Dog {\n//....\n};\n```\n```cpp\npublic class Dog extends Animal {\n//....\n};\n```",
            "hint": null,
            "correctAnswer": ["B"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "30901879d6bd2cb2bd17f455",
            "question": "¿Cuál es la salida de este código dado a continuación?\n```cpp\n#include <cstdio>\nusing namespace std;\nint main(){\n    char c = 255;\n    if(c>10)\n        printf(\"c = %i, which is greater than 10\", c);\n    else\n        printf(\"c = %i, which is less than 10\", c);\n    return 0;\n}\n```",
            "answer": "c = -1, which is less than 10",
            "explanation": "Técnicamente, si un `char` es `signed` o `unsigned` depende de la implementación;\nen el último caso, la segunda respuesta sería correcta.\n[Referencia](https://en.cppreference.com/w/cpp/language/types)",
            "hint": null,
            "correctAnswer": ["c = -1, which is less than 10"],
            "options": [
              "c = -1, which is less than 10",
              "c = 255, which is greater than 10",
              "c = -1, which is greater than 10",
              "c = 255, which is less than 10"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f7d52810133d4acb3fb2e573",
            "question": "¿Cómo puede el código C++ llamar a una función C?",
            "answer": "usando extern \"C\"",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["usando extern \"C\""],
            "options": [
              "simplemente llamando al código C",
              "No hay forma de que C++ llame a una función C",
              "usando extern \"C\"",
              "importando el código fuente C"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e8c9ea4d3f70968b6a772419",
            "question": "¿Cuál opción NO es una definición de tipo válida de una estructura que contiene coordenadas x e y como enteros, y que puede usarse exactamente como se muestra para la variable llamada `center`?\n```cpp\ncoord center;\ncenter.x = 5;\ncenter.y = 3;\n```",
            "answer": "A",
            "explanation": "```cpp\ntypedef struct coord {\nint x;\nint y;\n};\n```\n```cpp\ntypedef struct coord {\nint x;\nint y;\n} coord;\n```\n```cpp\ntypedef struct {\nint x;\nint y;\n} coord;\n```\n```cpp\nstruct coord {\nint x;\nint y;\n};\ntypedef struct coord coord;\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "10e8638eab17532ca7a711d9",
            "question": "¿Cuál opción NO produce la misma salida que este fragmento de código? Suponga que la variable `i` no se usará en ningún otro lugar del código.\n```cpp\nfor (i=1;i<10;i++){\n    cout<<i<<endl;\n}\n```",
            "answer": "A",
            "explanation": "```cpp\ni=1;\nwhile(i<10){\ncout<<++i<<endl;\n}\n```\n```cpp\nfor (int i:{1,2,3,4,5,6,7,8,9}) {\ncout<<i<<endl;\n}\n```\n```cpp\ni = 1;\ndo {\ncout<<i++<<endl;\n} while(i<10);\n```\n```cpp\ni = 1;\nloop:\ncout<<i++<<endl;\nif(i<10) goto loop;\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4bc04afb38b815535e1fbd46",
            "question": "¿Qué hace esta parte de un archivo main.cpp?\n```cpp\n#include \"library.h\"\n```",
            "answer": "Causa el reemplazo de la directiva `#include` por todo el contenido del archivo fuente library.h. Esto es similar a la operación de Copiar-Pegar de library.h en main.cpp.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Causa el reemplazo de la directiva `#include` por todo el contenido del archivo fuente library.h. Esto es similar a la operación de Copiar-Pegar de library.h en main.cpp."
            ],
            "options": [
              "Hace que la cadena de herramientas compile todo el contenido de library.h para que su código ejecutable esté disponible cuando sea necesario por la aplicación final.",
              "Selecciona cuidadosamente library.h para las declaraciones y definiciones de todos los datos y funciones utilizadas en el resto del archivo fuente main.cpp, finalmente reemplazando la directiva `#include` con esas declaraciones y definiciones.",
              "Informa al enlazador que algunas funciones o datos utilizados en el archivo fuente main.cpp están contenidos en library.h, para que puedan ser llamados en tiempo de ejecución. Esto también se conoce como enlace dinámico.",
              "Causa el reemplazo de la directiva `#include` por todo el contenido del archivo fuente library.h. Esto es similar a la operación de Copiar-Pegar de library.h en main.cpp."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "18d031c86f4972615dd65d9b",
            "question": "Considere esta declaración de función de `is_even`, que toma un entero y devuelve true si el argumento es un número par y false en caso contrario. ¿Cuáles declaraciones son correctas para versiones sobrecargadas de esa función para soportar números de punto flotante y representaciones de cadena de números?\n```cpp\nbool is_even(int);\n```",
            "answer": "A",
            "explanation": "```cpp\nbool is_even(float f);\nbool is_even(char *str);\n```\n```cpp\nbool is_even(float f);\nbool is_even(char str);\n```\n```cpp\nbool is_even_float(float f);\nbool is_even_str(char *str);\n```\n```cpp\nfloat is_even(float f);\nchar *is_even(char *str);\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "752d187dd518cac21a8be4c4",
            "question": "¿Cuál opción es un guardia de inclusión para el archivo de encabezado `my_library.h`?",
            "answer": "B",
            "explanation": "```cpp\n#ifdef MY_LIBRARY_H\n#define MY_LIBRARY_H\n// contenido de my_library.h\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#ifndef MY_LIBRARY_H\n#define MY_LIBRARY_H\n// contenido de my_library.h\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#ifdef MY_LIBRARY_H\n#undef MY_LIBRARY_H\n// contenido de my_library.h\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#define MY_LIBRARY_H\n#include MY_LIBRARY_H\n// contenido de my_library.h\n#undef MY_LIBRARY_H\n```",
            "hint": null,
            "correctAnswer": ["B"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7722b94e756bec9fcf9086d3",
            "question": "¿Qué está mal con esta definición cuando se usa un compilador pre-C++11?\n```cpp\nstd::vector<std::vector<int>> thematrix;\n```",
            "answer": "`>>` se analiza como el operador de desplazamiento a la derecha, y por lo tanto resulta en un error de compilación.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "`>>` se analiza como el operador de desplazamiento a la derecha, y por lo tanto resulta en un error de compilación."
            ],
            "options": [
              "No hay nada malo con ella.",
              "Un `std::vector` no puede contener más contenedores `std::vector` como sus elementos.",
              "La sintaxis correcta debería ser: `std::vector[std::vector[int]] thematrix;`",
              "`>>` se analiza como el operador de desplazamiento a la derecha, y por lo tanto resulta en un error de compilación."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5790eec2af562e8fc8df44eb",
            "question": "¿A qué es equivalente la declaración a continuación?",
            "answer": null,
            "explanation": null,
            "hint": null,
            "correctAnswer": [],
            "options": [],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "92f65963f73e2e4a23f80507",
            "question": "b. ¿A qué es equivalente la declaración?\n```cpp\nsprite->x\n```",
            "answer": "`(*sprite).x`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`(*sprite).x`"],
            "options": ["`sprite.x`", "`sprite.*x`", "`(*sprite).x`", "`*sprite.x`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "53981802f65c40d03c262f1c",
            "question": "Considere una clase llamada `complexNumber`. ¿Qué código resultará en un objeto equivalente?\n```cpp\ncomplexNumber(float real, float im)\n: real_part(real),\n im_part(im){}\n```",
            "answer": "C",
            "explanation": "```cpp\ncomplexNumber(float real, float im) {\nthis->real = real_part;\nthis->im = im_part;\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part(real);\nthis->im_part(im);\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part = real;\nthis->im_part = im;\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part = &real;\nthis->im_part = &im;\n}\n```",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "60ccee16c3dd2bc75aa07332",
            "question": "¿Cuál es el resultado de ejecutar este fragmento de código?\n```cpp\nbool x=true, y=false;\nif (~x || y) {\n    /*parte A*/\n} else {\n    /*parte B*/\n}\n```",
            "answer": "La parte A se ejecuta porque `~x` no es cero, lo que significa verdadero.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "La parte A se ejecuta porque `~x` no es cero, lo que significa verdadero."
            ],
            "options": [
              "La parte A se ejecuta porque la expresión `(~x || y)` siempre resulta en verdadero si `y==false`.",
              "La parte B se ejecuta porque la declaración `(~x || y)` no es válida, por lo tanto falso.",
              "La parte A se ejecuta porque `~x` no es cero, lo que significa verdadero.",
              "La parte B se ejecuta porque `~x` es falso e `y` es falso, por lo tanto la operación OR se evalúa como falso."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7c43847d66ca8167823a851c",
            "question": "¿Cuál sería la salida de este código?\n```cpp\nint32_t nums[3]={2,4,3};\nstd::cout << ( nums[0] << nums[1] << nums[2] );\n```",
            "answer": "256",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["256"],
            "options": [
              "La salida son las direcciones de `nums[0]`, `nums[1]`, y `nums[2]`, en ese orden, sin espacios.",
              "256",
              "`0`",
              "`243`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "286fe32eb12ac59536941b9c",
            "question": "¿Cuál es la salida de este código?\n```cpp\nfloat values[5]={0.54f, 2.71828f, 3.14159f, 5.499999f, 10.0f};\nfor(auto f:values)\n    printf(\"%i \",(int)(f+0.5f));\n```",
            "answer": "`1 3 3 5 10`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`1 3 3 5 10`"],
            "options": [
              "`0.54 2.71828 3.14159 5.499999 10.0`",
              "`1 3 4 6 11`",
              "`0 2 3 5 10`",
              "`1 3 3 5 10`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c9e8207a291665dcea8be837",
            "question": "¿Cuál de las siguientes clases STL es la más adecuada para implementar una guía telefónica? Suponga que cada entrada contiene un nombre y un número de teléfono, sin duplicados, y desea tener una búsqueda por nombre.",
            "answer": "`std::map`",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/container/map)",
            "hint": null,
            "correctAnswer": ["`std::map`"],
            "options": ["`std::priority_queue`", "`std::list`", "`std::vector`", "`std::map`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "569084ff447613ea12662f78",
            "question": "¿Qué hace este programa?\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\nint main(){\n    ifstream file1(\"text1.txt\", ios::binary);\n    ofstream file2(\"text2.txt\", ios::binary);\n    file2 << file1.rdbuf();\n}\n```",
            "answer": "Copia el contenido de text1.txt en text2.txt - es decir, hace una copia de text1.txt, llamada text2.txt.",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/header/fstream)",
            "hint": null,
            "correctAnswer": [
              "Copia el contenido de text1.txt en text2.txt - es decir, hace una copia de text1.txt, llamada text2.txt."
            ],
            "options": [
              "Renombra text1.txt a text2.txt.",
              "Crea un directorio llamado text2.txt y mueve text1.txt allí.",
              "Copia el contenido de text1.txt en text2.txt - es decir, hace una copia de text1.txt, llamada text2.txt.",
              "Añade el contenido de text1.txt en text2.txt - es decir, reemplaza el contenido de text2.txt por la concatenación de text2.txt y text1.txt."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "baf0fa861c0600c5cf4d60c7",
            "question": "¿Cuál de las siguientes NO es una consecuencia de declarar la variable miembro `count` de my_class como static? / Alt.: ¿Cuál afirmación es verdadera al declarar la variable miembro `count` como static?\n```cpp\nclass my_class {\n    public: static int count;\n}\n```",
            "answer": "La variable no puede ser modificada por ninguna parte del código en la misma aplicación o hilo. Sin embargo, otros hilos pueden modificarla.",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/language/static)",
            "hint": null,
            "correctAnswer": [
              "La variable no puede ser modificada por ninguna parte del código en la misma aplicación o hilo. Sin embargo, otros hilos pueden modificarla."
            ],
            "options": [
              "La variable no puede ser modificada por ninguna parte del código en la misma aplicación o hilo. Sin embargo, otros hilos pueden modificarla.",
              "La variable existe incluso cuando no se han definido objetos de la clase, por lo que puede ser modificada en cualquier punto del código fuente.",
              "La variable se asigna solo una vez, independientemente de cuántos objetos se instancien, porque está vinculada a la clase misma, no a sus instancias.",
              "Todos los objetos que intentan acceder a su variable miembro count realmente se refieren a la única variable count vinculada a la clase static."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0931aee733ad245ffd64e89c",
            "question": "¿Cuál es el tipo asumido de una constante representada en el código fuente como `0.44`?",
            "answer": "double",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["double"],
            "options": ["double", "long float", "long double", "float"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "36b59b7bb1083c6f8536ae3a",
            "question": "¿Cuál es una forma apropiada de eliminar `my_object` como se muestra a continuación?\n```cpp\nmy_class *my_object = new my_class();\n```",
            "answer": "`delete(my_object);`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`delete(my_object);`"],
            "options": [
              "`delete(my_object);`",
              "`free(my_object);`",
              "El recolector de basura destruirá el objeto eventualmente.",
              "Salir del alcance destruirá el objeto."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "89c9ac83cd1d2d23929fc529",
            "question": "¿Cuál es la forma correcta de llamar a la función miembro `count` para el puntero de objeto llamado `grades`?\n```cpp\nclass my_array{\n    public:\n        int count();\n};  // ... más miembros arriba\nint main(){\n    my_array *grades = new my_array();\n};  // ... más código arriba\n```",
            "answer": "`grades->count();`",
            "explanation": "[Referencia](https://en.cppreference.com/w/c/language/operator_member_access)",
            "hint": null,
            "correctAnswer": ["`grades->count();`"],
            "options": [
              "`grades.count();`",
              "`my_array->count();`",
              "`grades->count();`",
              "`my_array.count();`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "251a4a2f29b73f21bdcaf444",
            "question": "¿Cuál sería la salida de este código?\n```cpp\nint i0=4, i1=6, i2=8;\nint& nums[3]={i2,i0,i1};\nstd::cout<<nums[0]<<nums[1]<<nums[2];\n```",
            "answer": "No hay salida. El código causa un error del compilador porque `nums` es un arreglo de referencias, lo cual es ilegal.",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/language/array)",
            "hint": null,
            "correctAnswer": [
              "No hay salida. El código causa un error del compilador porque `nums` es un arreglo de referencias, lo cual es ilegal."
            ],
            "options": [
              "No hay salida. El código causa un error del compilador porque `nums` es un arreglo de referencias, lo cual es ilegal.",
              "846",
              "La salida son las direcciones de `i2`, `i0`, e `i1`, en ese orden, sin espacios.",
              "468"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ba4360e84bf397b891fff0a9",
            "question": "¿Este código causa un error del compilador? Si es así, ¿por qué, y si no, ¿qué es `child_t`?\n```cpp\ntypedef struct{\n    unsigned int  age    : 4;\n    unsigned char gender : 1;\n    char                 : 0;\n    unsigned int  size   : 2;\n}child_t;\n```",
            "answer": "No, y `child_t` es un tipo definido como una estructura con campos de bits. Tiene 4 bits para age y 1 bit para gender en el primer byte, y 2 bits para size en el segundo byte.",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": [
              "No, y `child_t` es un tipo definido como una estructura con campos de bits. Tiene 4 bits para age y 1 bit para gender en el primer byte, y 2 bits para size en el segundo byte."
            ],
            "options": [
              "Sí, causa un error del compilador porque el carácter de dos puntos no está permitido en definiciones de estructura.",
              "No, y `child_t` es un tipo definido como una estructura con campos de bits. Tiene 4 bits para age y 1 bit para gender en el primer byte, y 2 bits para size en el segundo byte.",
              "Sí, causa un error del compilador porque hay un campo sin nombre.",
              "Sí, causa un error del compilador porque un campo está definido como teniendo un tamaño de 0."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fa417f18b825a4661ce8476d",
            "question": "¿A qué es equivalente esta expresión?\n```cpp\nA->B\n```",
            "answer": "`(*A).B`",
            "explanation": "Nota: una variante más simple de la pregunta a continuación.",
            "hint": null,
            "correctAnswer": ["`(*A).B`"],
            "options": ["`*(A.B)`", "`B=A`", "`(*A).B`", "`&A.B`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cd5dfff4420870fb59f4d91b",
            "question": "¿A qué es equivalente esta expresión?\n```cpp\nA->B->C->D\n```",
            "answer": "`*(*((*A).B).C).D`",
            "explanation": "**Nota:** una variante más compleja de la pregunta anterior.",
            "hint": null,
            "correctAnswer": ["`*(*((*A).B).C).D`"],
            "options": ["`A.B.C.D`", "`*A.*B.*C.*D`", "`&A.&B.&C.&D`", "`*(*((*A).B).C).D`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b032d7cb4b27fbb8cf93c704",
            "question": "¿Qué hace esta función?\n```cpp\nauto buff = new char[50];\nstd::memset(buff,20,50);\n```",
            "answer": "Escribe el valor 20 en cada dirección de memoria desde buff hasta buff+49.",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/string/byte/memset)",
            "hint": null,
            "correctAnswer": [
              "Escribe el valor 20 en cada dirección de memoria desde buff hasta buff+49."
            ],
            "options": [
              "Declara un buffer de memoria llamado buff que comienza en la dirección 20 y termina en la dirección 70.",
              "Establece todos los bits en el arreglo llamado buffer desde su elemento en el índice 20 hasta su elemento en el índice 50.",
              "Escribe el valor 20 en cada dirección de memoria desde buff hasta buff+49.",
              "Declara un buffer de memoria llamado buff que comienza en la dirección 20 y termina en la dirección 50."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "643e25d2f1eb172e053ef557",
            "question": "Considere una clase llamada `CustomData`. ¿Cuál opción es una sintaxis de declaración correcta para sobrecargar el operador posfijo `++` como un miembro de clase?",
            "answer": "`CustomData operator++(int);`",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/language/operators)",
            "hint": null,
            "correctAnswer": ["`CustomData operator++(int);`"],
            "options": [
              "`CustomData& operator++();`",
              "`void operator++(CustomData);`",
              "`CustomData operator++(CustomData);`",
              "`CustomData operator++(int);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5a5210fe2269b69c5bb2947d",
            "question": "Desea ordenar my_array, declarado a continuación. ¿Cuál opción es la llamada correcta a std::sort, usando una expresión lambda como función de comparación?\n```cpp\nstd::array<uint32_t, 50> my_array;\n```",
            "answer": "A",
            "explanation": "```cpp\nstd::sort(my_array.begin(), my_array.end(),\n[](uint32_t a, uint32_t b) {\nreturn a < b;\n})\n```\n```cpp\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n}\nstd::sort(my_array.begin(), my_array.end(), lambda);\n```\n```cpp\nstd::sort(my_array.begin(), my_array.end(),\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n})\n```\n```cpp\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n}\nstd::sort(my_array.begin(), my_array.end(), &lambda);\n```\n[Referencia](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160)",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "71d3801c8ec8258e9fed0bc8",
            "question": "¿Cuál opción es la implementación más razonable de la función std::mutex::lock() usando std::mutex::try_lock()?",
            "answer": "A",
            "explanation": "```cpp\nvoid std::mutex::lock(){\nwhile(!this->try_lock());\n}\n```\n```cpp\nvoid std::mutex::lock(){\nreturn (this->try_lock());\n}\n```\n```cpp\nvoid std::mutex::lock(){\nwhile(1)\nthis->try_lock();\n}\n```\n```cpp\nvoid std::mutex::lock(){\nwhile(this->try_lock());\n}\n```\nNota: variante de la pregunta a continuación.",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fba0ebbe3dbae23fcdf27684",
            "question": "¿Cuál es la diferencia principal entre estas dos Funciones?\n```cpp\nstd::mutex::lock()\nstd::mutex::try_lock()\n```",
            "answer": "Ambos intentan adquirir un bloqueo, pero `lock()` bloquea si el mutex no está disponible, mientras que `try_lock()` devuelve si el mutex está disponible o no.",
            "explanation": "Nota: variante de la pregunta anterior.\n[Referencia](https://en.cppreference.com/w/cpp/thread/mutex/try_lock)",
            "hint": null,
            "correctAnswer": [
              "Ambos intentan adquirir un bloqueo, pero `lock()` bloquea si el mutex no está disponible, mientras que `try_lock()` devuelve si el mutex está disponible o no."
            ],
            "options": [
              "`lock()` tiene un privilegio mayor sobre `try_lock()`. Esto significa que tiene una mejor oportunidad de adquirir un mutex `con lock()`.",
              "Ambos intentan adquirir un bloqueo, pero `lock()` bloquea si el mutex no está disponible, mientras que `try_lock()` devuelve si el mutex está disponible o no.",
              "`lock()` fuerza la preferencia, mientras que `try_lock()` sugiere la preferencia.",
              "Si el mutex no está disponible, `try_lock()` devuelve con un código correspondiente, mientras que `lock()` arrebata el mutex del hilo que actualmente lo tiene."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a6ef42bdd322070db2668b02",
            "question": "¿Cuál es el propósito de un destructor?",
            "answer": "Permite al programador escribir el código necesario para liberar los recursos adquiridos por el objeto antes de eliminar el objeto mismo.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Permite al programador escribir el código necesario para liberar los recursos adquiridos por el objeto antes de eliminar el objeto mismo."
            ],
            "options": [
              "Permite al programador escribir el código necesario para liberar los recursos adquiridos por el objeto antes de eliminar el objeto mismo.",
              "Elimina un objeto. Un ejemplo de un destructor es la función `delete()`.",
              "Termina un programa. Esto puede lograrse como una llamada de función regular o como una excepción.",
              "No hay destructores en C++."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "268cd252387211ce1cf72793",
            "question": "¿Cuál es un beneficio de declarar el parámetro como una referencia `const` en lugar de declararlo como un objeto regular?\n```cpp\nint calculateMedian(const my_array& a)\n```",
            "answer": "El calificador `const` prohíbe que el código modifique el argumento, por lo que el programador puede estar seguro de que el objeto fuente permanecerá sin cambios. / Alt.: El argumento se pasa como una referencia, por lo que si el objeto my_array pasado es grande, el programa requerirá menos tiempo y memoria.",
            "explanation": "[Referencia](https://stackoverflow.com/a/2627179/10773894)",
            "hint": null,
            "correctAnswer": [
              "El calificador `const` prohíbe que el código modifique el argumento, por lo que el programador puede estar seguro de que el objeto fuente permanecerá sin cambios. / Alt.: El argumento se pasa como una referencia, por lo que si el objeto my_array pasado es grande, el programa requerirá menos tiempo y memoria."
            ],
            "options": [
              "En realidad, los objetos no se pueden pasar como variables regulares, porque requieren una llamada al constructor. Por lo tanto, una referencia `const` es la única forma de pasar instancias de clase a funciones.",
              "No hay beneficios porque una referencia y un objeto se tratan como la misma cosa.",
              "El calificador `const` prohíbe que el código modifique el argumento, por lo que el programador puede estar seguro de que el objeto fuente permanecerá sin cambios. / Alt.: El argumento se pasa como una referencia, por lo que si el objeto my_array pasado es grande, el programa requerirá menos tiempo y memoria.",
              "El argumento se pasa como una referencia, por lo que la función recibe una copia que puede ser modificada sin afectar la variable original."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "547d183c492309375f34974c",
            "question": "¿Qué es un guardia de inclusión?",
            "answer": "una declaración de preprocesador que previene que un archivo fuente sea incluido más de una vez en un proyecto",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "una declaración de preprocesador que previene que un archivo fuente sea incluido más de una vez en un proyecto"
            ],
            "options": [
              "una directiva de preprocesador que previene comportamientos inconsistentes en líneas que contienen las directivas #ifdef, #ifndef, o #elif",
              "una opción del compilador que previene que el código del usuario incluya bibliotecas adicionales",
              "una declaración de preprocesador que previene que un archivo fuente sea incluido más de una vez en un proyecto",
              "una biblioteca que agrega características de seguridad como mutexes, temporizadores de vigilancia y aserciones al proyecto"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "649f0c86528b5039b6b6954f",
            "question": "¿Cuál sería la declaración correcta de un constructor predeterminado para una clase llamada Sprite?",
            "answer": "A",
            "explanation": "```cpp\npublic: Sprite();\n```\n```cpp\nprivate: void Sprite();\n```\n```cpp\npublic: void Sprite();\n```\n```cpp\nprivate: Sprite();\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0d3784c63662f6c208ea2e5b",
            "question": "¿Cuál es el propósito de esta línea en un archivo de encabezado?\n```cpp\n#pragma once\n```",
            "answer": "hacer que el compilador analice ese archivo de encabezado solo una vez, incluso si está incluido varias veces en el fuente",
            "explanation": "[referencia aquí](https://en.cppreference.com/w/cpp/preprocessor/impl)",
            "hint": null,
            "correctAnswer": [
              "hacer que el compilador analice ese archivo de encabezado solo una vez, incluso si está incluido varias veces en el fuente"
            ],
            "options": [
              "restringir el uso de su contenido a solo un archivo fuente",
              "decirle al compilador que solo una variable puede ser instanciada de las clases o tipos contenidos en este archivo de encabezado",
              "ayudar al compilador a terminar más rápido asegurando que solo una pasada del compilador es necesaria para el código incluido en este archivo de encabezado",
              "hacer que el compilador analice ese archivo de encabezado solo una vez, incluso si está incluido varias veces en el fuente"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0716e6838a330427967b60fe",
            "question": "¿Qué es una variable de tipo double?",
            "answer": "un número de punto flotante",
            "explanation": "[Referencia](https://www.educba.com/c-plus-plus-double/)",
            "hint": null,
            "correctAnswer": ["un número de punto flotante"],
            "options": [
              "una tupla de 2 elementos",
              "un número entero",
              "un número de punto flotante",
              "una cadena con más de 255 caracteres"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4172d48e1c4983885ac4e2a1",
            "question": "Además de desplazar bits a la izquierda, ¿para qué se usa el operador << ?",
            "answer": "insertar caracteres en un flujo de salida como std::cout.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["insertar caracteres en un flujo de salida como std::cout."],
            "options": [
              "desplazar caracteres a la izquierda en una cadena.",
              "insertar caracteres en un flujo de salida como std::cout.",
              "comparar números de punto flotante como menor que.",
              "asignar una variable a una referencia."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e99d1152509d86cc7c4a046a",
            "question": "¿Cuál opción es una razón para especificar el tipo de un puntero en lugar de usar `void *`, que funciona como un puntero a cualquier tipo?",
            "answer": "El compilador necesita el tipo de datos para saber cuánta memoria asignar para el puntero porque diferentes tipos de datos requieren diferentes longitudes de puntero.",
            "explanation": "[Referencia](https://stackoverflow.com/questions/9802585/why-is-the-data-type-needed-in-pointer-declarations)",
            "hint": null,
            "correctAnswer": [
              "El compilador necesita el tipo de datos para saber cuánta memoria asignar para el puntero porque diferentes tipos de datos requieren diferentes longitudes de puntero."
            ],
            "options": [
              "El compilador necesita el tipo de datos para asegurarse de que el puntero no se va a usar en tipos ilegales no apuntables como funciones, etiquetas, punteros y referencias.",
              "`void *` no funciona para ningún tipo. El lenguaje no permite asignar nada más que `void` a un puntero a `void *`.",
              "El compilador necesita el tipo de datos para saber cuánta memoria asignar para el puntero porque diferentes tipos de datos requieren diferentes longitudes de puntero.",
              "Sí, causa un error del compilador porque un campo está definido como teniendo un tamaño de 0."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5100ddc19f09471978031f1b",
            "question": "¿Qué está mal con este fragmento de código?\n```cpp\n#include <iostream>\nchar str[20];\nint main(){\n    std::cout << \"What's your name? \";\n    str << std::cin\n    std::cout << \"Hello, \" << str;\n    return 0;\n}\n```",
            "answer": "El flujo del operador de entrada está invertido. debería comenzar desde `std::cin` y luego fluir (>>) hacia `str`.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "El flujo del operador de entrada está invertido. debería comenzar desde `std::cin` y luego fluir (>>) hacia `str`."
            ],
            "options": [
              "Se supone que la función main debe tener un tipo de retorno void.",
              "`std::cin` y `std::cout` no son válidos. Los nombres correctos para los flujos de entrada y salida de caracteres son `cin` y `cout`.",
              "Se supone que se debe usar la dirección de `str`. Es decir `&str` en lugar de `str`.",
              "El flujo del operador de entrada está invertido. debería comenzar desde `std::cin` y luego fluir (>>) hacia `str`."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1e1b6b8de04957ce8a67f300",
            "question": "Cuando se coloca en un contexto de ejecución válido, ¿cuál declaración asignará dinámicamente memoria del heap para un entero de valor 11?",
            "answer": "`int* anInt = new int(11);`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`int* anInt = new int(11);`"],
            "options": [
              "`int anInt = new int(11);`",
              "`int* anInt = new int[11];`",
              "`int anInt = new int[11];`",
              "`int* anInt = new int(11);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b1954c26d50b79f3d705f2eb",
            "question": "¿Cuál opción describe mejor el tipo `long`?",
            "answer": "un número entero de al menos 32 bits",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["un número entero de al menos 32 bits"],
            "options": [
              "un número entero de al menos 32 bits",
              "una cadena con más de 255 caracteres",
              "un puntero",
              "un número de punto flotante de 64 bits"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fddfbf514c0d7f2f9c01c7b8",
            "question": "¿Cuál de los siguientes tipos tiene la funcionalidad más cercana a una clase?",
            "answer": "`struct`",
            "explanation": "[Referencia](https://en.cppreference.com/w/c/language/struct)",
            "hint": null,
            "correctAnswer": ["`struct`"],
            "options": ["`struct`", "`union`", "`enum`", "`namespace`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b565afe9364ad5c1ca0c537f",
            "question": "Dados estos registros en un mapa, ¿cómo actualizará el valor de la clave \"Sinead\" a 22?\n![image](images/Q79.png)",
            "answer": "`marks[\"Sinead\"] = 22`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`marks[\"Sinead\"] = 22`"],
            "options": [
              "`marks[\"Sinead\"] = 22`",
              "`marks[\"Sinead\"].22`",
              "`marks[\"Sinead\"] -> 22`",
              "`marks[\"Sinead\"].value = 22`"
            ],
            "nature": "ChooseOne",
            "attachments": [
              {
                "id": "5ac8efd17af07a161794f757",
                "url": "/Users/arslankaleem/Workspace/Junk/linkedin-skill-assessments-quizzes/c++/images/Q79.png",
                "type": "question"
              }
            ],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c0063432245f4e2faed0e2ff",
            "question": "¿Por qué puede std::sort recibir un objeto función como uno de sus parámetros?",
            "answer": "`La función std::sort es una plantilla. El programador es libre de ingresar el algoritmo de ordenamiento en un objeto función como argumento.`",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "`La función std::sort es una plantilla. El programador es libre de ingresar el algoritmo de ordenamiento en un objeto función como argumento.`"
            ],
            "options": [
              "`La función std::sort es una plantilla. El programador es libre de ingresar el algoritmo de ordenamiento en un objeto función como argumento.`",
              "`En realidad, std::sort toma solo un argumento, que es el contenedor a ordenar.`",
              "`std::sort opera en un contenedor de plantilla. El compilador no sabe cómo comparar relacionalmente los valores que contiene, por lo que se debe proporcionar una función para hacer la comparación.`",
              "`std::sort usará la función de parámetro como un manejador de errores. La función será llamada si ocurre un error.`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4bd067c9ec1f5574f254fc28",
            "question": "¿Qué sucederá cuando ejecute este fragmento de código?\n```\n#include <iostream>\nint main() {\nfloat a = 5.51;\nint b = static_cast<int>(a);\nstd::cout << b;\n}\n```",
            "answer": "`5 se imprimirá en la salida estándar, sin advertencias de compilación generadas.`",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "`5 se imprimirá en la salida estándar, sin advertencias de compilación generadas.`"
            ],
            "options": [
              "`6 se imprimirá en la salida estándar, sin advertencias de compilación generadas.`",
              "`5 se imprimirá en la salida estándar, sin advertencias de compilación generadas.`",
              "`6 se imprimirá en la salida estándar, con advertencias de compilación generadas.`",
              "`5 se imprimirá en la salida estándar, con advertencias de compilación generadas.`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e665cd1075ecab97e270018a",
            "question": "¿Qué especificador de acceso no permite que los miembros de la clase sean accedidos desde fuera de la clase, pero permite que sean accedidos por clases derivadas?",
            "answer": "protected",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["protected"],
            "options": ["guarded", "protected", "public", "private"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b40a689f5a0fae389f89472a",
            "question": "La generación de ejecutables predeterminada en UNIX para un programa C++ es \\_",
            "answer": "a.out",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["a.out"],
            "options": ["a.exe", "a", "a.out", "out.a"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "13cb284441c70d1a589d4d02",
            "question": "¿Cuál será la salida del siguiente programa?\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\n  int a=1;\n  cout<<(a++)*(++a)<<endl;\n  return 0;\n}\n```",
            "answer": "3",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["3"],
            "options": ["1", "2", "3", "6"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "19f291b0035ed7c93a0291c9",
            "question": "¿Qué significa \"c\" en cout y cin?",
            "answer": "character (carácter)",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["character (carácter)"],
            "options": [
              "compiler (compilador)",
              "console (consola)",
              "character (carácter)",
              "standard namespace (espacio de nombres estándar)"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "83594123c700e21c238d3432",
            "question": "¿Cuál es el uso de tellp()?",
            "answer": "Posición del puntero de salida actual",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Posición del puntero de salida actual"],
            "options": [
              "Posición del puntero de entrada actual",
              "Posición del puntero de salida actual",
              "Última posición del puntero de entrada",
              "Última posición del puntero de salida"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "32e82258a7de9d21f49744c1",
            "question": "¿Qué es una función callback?",
            "answer": "Puntero a una función",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Puntero a una función"],
            "options": [
              "Puntero a un puntero",
              "Puntero a una función",
              "función para un puntero",
              "función para una clase"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e837312aa47cf5431ecb5366",
            "question": "¿Cuál es la sintaxis correcta para imprimir \"Hello World\" en C++?",
            "answer": "`cout << \"Hello World\";`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`cout << \"Hello World\";`"],
            "options": [
              "`cout << \"Hello World\";`",
              "`System.out.println(\"Hello World\");`",
              "`print(\"Hello World\");`",
              "`Console.WriteLine(\"Hello World\");`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4d6806701a72c972628cab88",
            "question": "¿Cuántas categorías de iteradores hay en C++?",
            "answer": "5",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["4", "3", "7", "5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e29fc5c03d5e6b67fdaf9aed",
            "question": "¿Cuál es el significado de clase base en C++?",
            "answer": "Otra clase heredó de esta clase",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Otra clase heredó de esta clase"],
            "options": [
              "Hereda otra clase",
              "Tiene una variable puntero",
              "Es la primera clase declarada",
              "Otra clase heredó de esta clase"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d96251780ff7689c73eb445a",
            "question": "El tamaño de los objetos C++ se expresa en términos de múltiplos del tamaño de un ** y el tamaño de un char es **.",
            "answer": "char, 1",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["char, 1"],
            "options": ["char, 4", "float, 8", "int, 1", "char, 1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3c2358e1d1052ecf78fa2ec0",
            "question": "Los aspectos dependientes de la implementación sobre una implementación se pueden encontrar en",
            "answer": "`<limits>`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`<limits>`"],
            "options": ["`<numeric>`", "`<limit>`", "`<limits>`", "`<implementation>`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b0e0b6e0dd37eb809ab0c4d7",
            "question": "¿Qué es un constructor predeterminado?",
            "answer": "un constructor que se puede usar sin argumentos",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["un constructor que se puede usar sin argumentos"],
            "options": [
              "un constructor que se puede usar sin argumentos",
              "un constructor que no tiene un valor de retorno",
              "un constructor que es usado por múltiples clases",
              "un constructor que inicializa todos los miembros de una clase"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "17494876ebcc97ce193ceeff",
            "question": "Al proteger un archivo de encabezado, ¿por qué usaría '#pragma once' en lugar de 'include' guard?",
            "answer": "Un include guard usa una macro para lograr una sola inclusión, pero el compilador no puede evitar que el programador defina esa macro en otro lugar, lo que resultaría en ninguna inclusión en absoluto",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Un include guard usa una macro para lograr una sola inclusión, pero el compilador no puede evitar que el programador defina esa macro en otro lugar, lo que resultaría en ninguna inclusión en absoluto"
            ],
            "options": [
              "No hay razón para elegir porque sirven propósitos diferentes",
              "Un include guard usa una macro para lograr una sola inclusión, pero el compilador no puede evitar que el programador defina esa macro en otro lugar, lo que resultaría en ninguna inclusión en absoluto",
              "'#pragma once' garantiza que el código del encabezado nunca se cambiará porque está aplicado por el compilador",
              "Los include guards se refieren al archivo de encabezado en el sistema de archivos, no al código, por lo que no son útiles si el archivo de encabezado existe más de una vez en un proyecto. Esto no es un problema con '#pragma once'"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ab41384abba5c646a2809071",
            "question": "¿Cuál de las siguientes declaraciones es válida?",
            "answer": "No podemos cambiar las plantillas de operadores.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["No podemos cambiar las plantillas de operadores."],
            "options": [
              "Podemos crear un nuevo operador de C++.",
              "Podemos cambiar la precedencia del operador de C++.",
              "No podemos cambiar las plantillas de operadores.",
              "Podemos cambiar la asociatividad de los operadores de C++."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f22d89c9d67c440555546fcd",
            "question": "¿Cuál de las siguientes se agrega/n automáticamente a cada clase, si no escribimos la nuestra?",
            "answer": "Todas las anteriores",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Todas las anteriores"],
            "options": [
              "Constructor de copia",
              "Operador de asignación",
              "Un constructor sin ningún parámetro",
              "Todas las anteriores"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d461fcb220f171a8f7995aff",
            "question": "La declaración if-else puede ser reemplazada por ¿qué operador?",
            "answer": "estructura selectiva",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["estructura selectiva"],
            "options": [
              "estructura cierta",
              "estructura de elección",
              "estructura selectiva",
              "Ninguna de las anteriores"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "45453126f2b79f7288020521",
            "question": "¿Cuál opción sería una solución recursiva al problema del factorial n!?",
            "answer": "&shy;",
            "explanation": "```cpp\nvoid fact(int n) {\nif (n <= 0)\nreturn 0;\nelse\nreturn 1;\n}\n```\n```cpp\nint fact(int n) {\nif (n <= 0)\nreturn 1;\nelse\nreturn (fact(n) * (n-1));\n}\n```\n```cpp\nint fact(int n) {\nif (n >= 0)\nreturn 1;\nelse\nreturn (fact(n-1) * n);\n}\n```\n```cpp\nint fact(int n) {\nif (n <= 0)\nreturn 1;\nelse\nreturn (fact(n-1) * n);\n}\n```",
            "hint": null,
            "correctAnswer": ["&shy;"],
            "options": ["&shy;", "&shy;", "&shy;", "&shy;"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "54ff80e714776632d0123be6",
            "question": "Se puede llamar al destructor de una clase cuando ocurren diversas situaciones. ¿Cuál opción NO es una de esas situaciones?",
            "answer": "El recolector de basura detecta que un objeto ya no se va a usar.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["El recolector de basura detecta que un objeto ya no se va a usar."],
            "options": [
              "El programa se termina. Esto llama al destructor de objetos de duración estática.",
              "Se llama a la función delete() para un puntero de objeto asignado con el operador new.",
              "El recolector de basura detecta que un objeto ya no se va a usar.",
              "Un objeto de duración de almacenamiento automático sale del alcance."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0e80c9f9eb2e1f6f54cd97bf",
            "question": "Está diseñando un sistema de pagos de cambio de divisas en C++. Necesita modelar una transacción de una moneda que tiene un entero como su cantidad y un float como su precio. Luego desea declarar un objeto real de este tipo. ¿Cómo logrará esto?",
            "answer": "A",
            "explanation": "```cpp\nstruct currencyDeal {\nfloat price;\nint quantity;\n};\ncurrencyDeal firstDeal;\n```\n```cpp\nunion currencyDeal {\nfloat price;\nint quantity;\n};\ncurrencyDeal firstDeal;\n```\n```cpp\nstruct currencyDeal {\nfloat price;\nint quantity;\n};\n```\n```cpp\nunion currencyDeal {\nfloat price;\nint quantity;\n};\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3bf7b94adee4b1102755fb1a",
            "question": "¿Qué sucederá si intenta llamar a esta función con checkConcatThreshold(\"a\");?\n```cpp\nint checkConcatThreshold(string a, string b) {\n    return (a + b).length () > 120;\n}\n```",
            "answer": "Ocurrirá un error de compilación.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Ocurrirá un error de compilación."],
            "options": [
              "Ocurrirá una advertencia de compilación y al segundo argumento se le dará un valor predeterminado de b.",
              "Ocurrirá una advertencia de compilación y al segundo argumento se le dará un valor predeterminado de la cadena vacía.",
              "Ocurrirá un error de compilación.",
              "No ocurrirán errores de compilación y no ocurrirán advertencias de compilación."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bf2f6648cd87f35378620fa5",
            "question": "Necesita definir una función lambda de C++. Desea que la función tenga acceso solo a las variables que son locales a ella. La función debe recibir un solo parámetro, y un nombre, y construir un saludo simple. ¿Cómo logrará esto?",
            "answer": "C",
            "explanation": "```cpp\nauto myVeryFirstLambda = [=] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nmyVeryFirstLambda = [&] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nauto myVeryFirstLambda = [] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nmyVeryFirstLambda = [] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n[Referencia](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160)",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a453580eec8b30be574e86ef",
            "question": "¿Cuál es el valor de X después de ejecutar este código?\n```cpp\nint x=10, a=-3;\nX+=a;\n```",
            "answer": "7",
            "explanation": "**Explicación:** `+=` significa aumentar el valor. Por lo tanto `x += a` es equivalente a `x = x + a`",
            "hint": null,
            "correctAnswer": ["7"],
            "options": ["-3", "7", "13", "3"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "60401d967b71dc561b5574b3",
            "question": "Una vez que haya terminado de escribir en un archivo, ¿qué método llamará en el `ofstream` para notificar al sistema operativo?",
            "answer": "close()",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["close()"],
            "options": ["printout()", "close()", "destroy()", "flush()"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6d19f4fbdbc4e098e66ba663",
            "question": "¿Cuál opción NO es una palabra clave de C++?",
            "answer": "comPl",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["comPl"],
            "options": ["static_assert", "reinterpret_cast", "comPl", "alignas"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "05caed6944972b827d57a006",
            "question": "La función size_in_bits parece tomar cualquier tipo de parámetro. Esto se puede hacer sobrecargando la función, o dejando que el compilador se encargue de ello escribiendo una plantilla. ¿Cuál opción es una implementación de esa plantilla?\n```cpp\nint main()\n{\ncout « size_in_bits(21) « endl;\ncout « size_in_bits('f') « endl;\ncout « size_in_bits(32.1f) « endl;\ncout « size_in_bits(32.1) « endl;\nreturn 0;\n}\n```",
            "answer": "A; C",
            "explanation": "```cpp\ntemplate <typename T>\nsize_t size_in_bits(const T& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\ntemplate size_t size_in_bits(const {int,float,double,char,long}& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\ntemplate <typename T {int,float,double,char,long>\nsize_t size_in_bits(const T& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\nsize_t size_in_bits(void * a){\nreturn sizeof(a)*8;\n}\n```",
            "hint": null,
            "correctAnswer": ["A", "C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "60f8a5cdef6ffa430113ad78",
            "question": "Para usar el teclado como entrada se incluye la biblioteca iostream. Para leer entrada de archivos como entrada, ¿qué biblioteca se necesita?",
            "answer": "fstream",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["fstream"],
            "options": ["fstream", "cstdlib", "filestream", "iostream"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a96c57fcb51be28ccd63a450",
            "question": "¿Qué imprimirá este programa orientado a objetos?\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Vehicle {\npublic:\n\tstring fuel = \"none\";\n};\nclass MotorizedVehicle : public Vehicle {\npublic:\n\tstring fuel = \"fossil\";\n};\nclass NextgenMotorizedVehicle : public MotorizedVehicle {\npublic:\n\tstring fuel = \"hydrogen\";\n};\nint main() {\n\tMotorizedVehicle aCar;\n\tcout << aCar.fuel;\n\treturn 0;\n}\n```",
            "answer": "fossil",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["fossil"],
            "options": ["fossil", "fossil none", "hydrogen", "none"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7b1ba219681895a8dc5bfcad",
            "question": "El programa a continuación está manejando un contenedor de pila. ¿Cuál es la salida de ejecutar el programa?\n```cpp\n#include <iostream>\n#include <stack>\nint main()\n{\n\tstd::stack<int> stack;\n\tstack.push(1);\n\tstack.push(2);\n\tstack.push(3);\n\tstack.pop();\n\tstack.push(4);\n\tstack.top();\n\tstack.pop();\n\tstd::cout << stack.top();\n}\n```",
            "answer": "2",
            "explanation": "#Explicación detallada:\nAquí se supone que implementamos una estructura de datos de pila que sigue el principio **FILO** o (First IN Last Out - Primero en Entrar Último en Salir),\n_stack.push()_ -> empuja un elemento al final del arreglo.\n_stack.pop()_ -> elimina un elemento del final del arreglo.\n_stack.top()_ -> Solo nos da el elemento superior del arreglo.\nAhora siguiendo las secuencias de push y pop: **[1,2,3]** luego se usa la función pop,\nEl arreglo recién formado es: **[1,2,4]** luego se usa top para recuperar el elemento superior '4' y luego se usa nuevamente la función pop que elimina 4.\nasí, el arreglo resultante es: 1,2.\nLuego imprime el elemento superior (ie: 2).",
            "hint": null,
            "correctAnswer": ["2"],
            "options": ["1", "2", "3", "4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e5389387fc5b593377594861",
            "question": "¿Cuál opción es una forma válida de sobrecargar el operador condicional ternario?",
            "answer": "`El operador ternario no es sobrecargable.`",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/language/operators)",
            "hint": null,
            "correctAnswer": ["`El operador ternario no es sobrecargable.`"],
            "options": [
              "`void& operator ?:(const bool cond, const void& iftrue, const void& iffalse);`",
              "`El operador ternario no es sobrecargable.`",
              "`void& operator conditional(const bool cond, const void& iftrue, const void& iffalse);`",
              "`void* operator ?:(const bool cond, const void* iftrue, const void* iffalse);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "40cea006cc3c01c35f912975",
            "question": "¿Qué jerarquía de clases representa un ejemplo de herencia multinivel?",
            "answer": "En el mismo programa, en diferentes puntos, una clase dada deriva individualmente de más de dos clases diferentes.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "En el mismo programa, en diferentes puntos, una clase dada deriva individualmente de más de dos clases diferentes."
            ],
            "options": [
              "En el mismo programa, en diferentes puntos, una clase dada deriva individualmente de más de una clase diferente.",
              "Una primera clase deriva directamente, al mismo tiempo, de una segunda y tercera clase.",
              "En el mismo programa, en diferentes puntos, una clase dada deriva individualmente de más de dos clases diferentes.",
              "Una primera clase deriva de una segunda clase, y esa segunda clase ya está derivada de una tercera clase"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f50504224f85c8050d17674a",
            "question": "¿Cuál de las siguientes es la sintaxis correcta para imprimir el mensaje en lenguaje C++?",
            "answer": "cout <<\"Hello world!\";",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/io/cout)",
            "hint": null,
            "correctAnswer": ["cout <<\"Hello world!\";"],
            "options": [
              "Out <<\"Hello world!",
              "Cout << Hello world! ;",
              "cout <<\"Hello world!\";",
              "Ninguna de las anteriores"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "feecd2d683f09a6bdae68d6a",
            "question": "Considere el siguiente programa. ¿Cuál será la salida/error?\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nbool compare(char c1, char c2){\nreturn tolower(c1) > tolower(c2);    //LÍNEA-1\n}\nint main(){\nchar arr1[20] = \"C++ Program\", arr2[20] = \"C Program\";\ncout << lexicographical_compare(arr1, arr1+strlen(arr1), arr2, arr2+strlen(arr2),\ncompare);\nreturn 0;\n}\n```",
            "answer": "1",
            "explanation": "[Referencia](https://www.geeksforgeeks.org/tolower-function-in-cpp/)",
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["1", "0", "-1", "Error de compilación: la función no está definida"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "85e02b0297ffc83f8170a054",
            "question": "Considere el siguiente segmento de código. Complete el espacio en blanco en LÍNEA-1 para que el programa imprima \"not found\"?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint data[] = {1,2,3,4,5};\nint key = 5;\nif(binary_search(__________))    //LÍNEA-1\ncout << \"found\";\nelse\ncout << \"not found\";\nreturn 0;\n}\n```",
            "answer": "&data[0], &data[4], key; data+1, data+4, key",
            "explanation": "[Referencia](https://www.geeksforgeeks.org/binary-search-algorithms-the-c-standard-template-library-stl/)",
            "hint": null,
            "correctAnswer": ["&data[0], &data[4], key", "data+1, data+4, key"],
            "options": [
              "&data[0], &data[5], key",
              "data, data+5, key",
              "&data[0], &data[4], key",
              "data+1, data+4, key"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "55aabc16b181d1d32fa2ccce",
            "question": "Considere el siguiente segmento de código. ¿Cuál será la salida?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main () {\nint data[] = {50, 30, 40, 10, 20};\nsort (&data[1], &data[4]);\nfor (int i = 0; i < 5; i++)\ncout << data[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "50 10 30 40 20",
            "explanation": "[Referencia](https://cplusplus.com/reference/algorithm/sort/)",
            "hint": null,
            "correctAnswer": ["50 10 30 40 20"],
            "options": ["10 20 30 40 50", "10 30 40 50 20", "50 10 30 40 20", "50 10 20 30 40"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f1ec318d242a3c4bb4eb78a2",
            "question": "Considere el siguiente segmento de código. ¿Cuál será la salida?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint element[5];\nfor(int i = 1; i <= 5; i++)\n*(element + i - 1) = i * 5;\nrotate(element, element + 4, element + 5);\nrotate(element, element + 1, element + 4);\nfor (int i = 0; i < 5; ++i)\ncout << element[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "5 10 15 25 20",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/algorithm/rotate)",
            "hint": null,
            "correctAnswer": ["5 10 15 25 20"],
            "options": ["5 10 15 20 25", "5 10 15 25 20", "20 10 15 25 5", "25 5 10 15 20"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "58549a6d39503e938ff2aece",
            "question": "Considere el siguiente segmento de código. ¿Cuál será la salida?\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nconst int size = 3, c = 65;\nvector<char> vc(size, 'A');\nfor (int i = 1; i <= 2; i++)\nvc.push_back(65 + i);\nvc.resize(10, 90);\nvc.resize(8);\nfor (int i = 0; i < vc.size(); i++)\ncout << vc[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "A A A B C Z Z Z",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/container/vector)",
            "hint": null,
            "correctAnswer": ["A A A B C Z Z Z"],
            "options": ["A A A B C Z Z Z", "A A B B C Z Z Z", "A A A B C Z Z", "A A A B C Z Z Z Z"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "44c6e5ea2adbdb03450f0b5c",
            "question": "Considere el siguiente segmento de código. Elija la opción apropiada para completar el espacio en blanco en LÍNEA-1, de modo que la salida del código sea: a C++ Program.\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nint main(void) {\nstring s1 = \"C++ \";\nstring s2 = \"Program\";\n__________________;    //LÍNEA-1\ncout << s1;\nreturn 0;\n}\n```",
            "answer": "s1 += s2; s1.append(s2)",
            "explanation": "[Referencia](https://www.geeksforgeeks.org/stdstringappend-in-c/)",
            "hint": null,
            "correctAnswer": ["s1 += s2", "s1.append(s2)"],
            "options": ["s1 += s2", "strcat(s1, s2)", "s1.append(s2)", "s1.insert(s2)"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "73c96180846e1fed26b02b15",
            "question": "Considere el siguiente segmento de código. Complete el espacio en blanco en LÍNEA-1 de modo que la salida sea 5 2 3 4 5\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint data[] = { 1, 2, 3, 4, 5 };\nfor (int i = 0; i < 1; i++) {\nint j = data[i];\nreplace(data, data + 5, j, *(_________________));    //LÍNEA-1\n}\nfor (int i = 0; i < 5; ++i)\ncout << data[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "data + 4 - i",
            "explanation": "[Referencia](https://www.geeksforgeeks.org/stdstringreplace-stdstringreplace_if-c/)",
            "hint": null,
            "correctAnswer": ["data + 4 - i"],
            "options": ["data + 4 - i", "data + 5 - i", "data + i - 4", "data + i - 5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5492cf884a32a304bd7bc883",
            "question": "Considere el siguiente segmento de código. ¿Cuál será la salida?\n```cpp\n#include <iostream>\n#include <cstring>\n#include <stack>\nusing namespace std;\nint main(){\nchar str[10] = \"123456789\";\nstack<char> s1, s2;\nint i;\nfor(i = 0; i < strlen(str)/2; i++)\ns1.push(str[i]);\nfor(i=i-1; i < strlen(str); i++)\ns2.push(str[i]);\nwhile (!s1.empty()) {\ns2.push(s1.top()); s1.pop();\n}\nwhile (!s2.empty()) {\ncout << s2.top(); s2.pop();\n}\nreturn 0;\n}\n```",
            "answer": "1234987654",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/container/stack)",
            "hint": null,
            "correctAnswer": ["1234987654"],
            "options": ["1234987654", "123498765", "1234897654", "123459876"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3fb09717ecb3ee52323997ec",
            "question": "Considere el siguiente segmento de código. ¿Qué declaración/declaraciones es/son correcta(s)?\n```cpp\nint i = 5;\nconst int *p = &i;\nint * const q = &i;\nint const *r = &i;\nint const * const s = &i;\n*p = 10; //STMT-1\n*q = 10; //STMT-2\n*r = 10; //STMT-3\n*s = 10; //STMT-4\n```",
            "answer": "STMT-2",
            "explanation": "[Referencia](https://www.geeksforgeeks.org/const-keyword-in-cpp/)",
            "hint": null,
            "correctAnswer": ["STMT-2"],
            "options": ["STMT-1", "STMT-2", "STMT-3", "STMT-4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f879cfc9252a5ff1f31293aa",
            "question": "Considere el siguiente programa. ¿Cuál será la salida/error(es)?\n```cpp\n#include <iostream>\nusing namespace std;\nchar add(char c1 = 'a') { return c1; }\nchar add(char c1 = 'a', char c2 = 'b') { return c1 + c2 - 'a';}\nchar add(char c1 = 'a', int d1 = 100){ return c1 + d1 - 'a'; }\nchar add(char c1 = 'a', char c2 = 'b', char c3) { return c1 + c2 + c3 - 'a'; }\nint main() {\nchar c = add('o', 'k');\ncout << c << endl;\nreturn 0;\n}\n```",
            "answer": "Error de compilación: falta argumento predeterminado para \"char add(char, char, char)\"; Error de compilación: llamada de sobrecarga \"add(char, char)\" es ambigua",
            "explanation": "[Referencia](https://learn.microsoft.com/en-us/cpp/cpp/function-overloading?view=msvc-170)",
            "hint": null,
            "correctAnswer": [
              "Error de compilación: falta argumento predeterminado para \"char add(char, char, char)\"",
              "Error de compilación: llamada de sobrecarga \"add(char, char)\" es ambigua"
            ],
            "options": [
              "y",
              "z",
              "Error de compilación: falta argumento predeterminado para \"char add(char, char, char)\"",
              "Error de compilación: llamada de sobrecarga \"add(char, char)\" es ambigua"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5edcd2ff89d554f5636ac03c",
            "question": "Considere el siguiente segmento de código. ¿Cuál será la salida?\n```cpp\n#include <iostream>\nusing namespace std;\n#define SQR(x) (x)*(x)\nint main() {\nint a=3;\ncout << SQR(a++) << endl;\nreturn 0;\n}\n```",
            "answer": "12",
            "explanation": "[Referencia](https://www.geeksforgeeks.org/output-of-the-program-use-macros-carefully/)",
            "hint": null,
            "correctAnswer": ["12"],
            "options": ["12", "25", "9", "16"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2e6b215154d9120865ea07ab",
            "question": "Considere el siguiente segmento de código. ¿Qué línea/s le darán un error?\n```cpp\n#include<iostream>\n#define X 1\nusing namespace std;\nint main(){\nint i;\nconst int i1 = 2;\nconst int i2 = i1; //LÍNEA-1\ni2 = X;\ni = i1;\ni1 = i;\nreturn 0;\n//LÍNEA-2\n//LÍNEA-3\n//LÍNEA-4\n}\n```",
            "answer": "LÍNEA-2; LÍNEA-4",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["LÍNEA-2", "LÍNEA-4"],
            "options": ["LÍNEA-1", "LÍNEA-2", "LÍNEA-3", "LÍNEA-4"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "053814a7695ea6cc2ad9ec1f",
            "question": "Considere el siguiente segmento de código. ¿Cuál será la salida/error?\n```cpp\n#include<iostream>\nusing namespace std;\nint main(){\nint a = 5;\nint &b = a+1;\na = a*b;\ncout << a << \" \" << b;\nreturn 0;\n}\n```",
            "answer": "Error de compilación: inicialización no válida de referencia no constante",
            "explanation": "#Explicación detallada:\nEl error está ocurriendo porque está tratando de crear una referencia a un valor temporal. En la línea int &b = a+1; estamos intentando crear una referencia b al resultado de la expresión a + 1, que es un valor temporal. Las referencias deben estar vinculadas a un objeto real, no a un valor temporal o una expresión que no tenga una ubicación de memoria.",
            "hint": null,
            "correctAnswer": [
              "Error de compilación: inicialización no válida de referencia no constante"
            ],
            "options": [
              "36",
              "30",
              "25",
              "Error de compilación: inicialización no válida de referencia no constante"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b56abf1c015306d42490a81d",
            "question": "Considere el siguiente segmento de código. ¿Cuál será la salida?\n```cpp\n#include <iostream>\nusing namespace std;\nint& func(int& i) {     //LÍNEA-1\nreturn i = i+5;\n}\nint main() {\nint x = 1, y = 2;\nint& z = func(x);\ncout << x << \" \" << z << \" \";\nfunc(x) = y;\ncout << x << \" \" << z;\nreturn 0;\n}\n```",
            "answer": "6 6 2 2",
            "explanation": "[Referencia](https://www.ibm.com/docs/en/zos/2.4.0?topic=calls-pass-by-reference-c-only)",
            "hint": null,
            "correctAnswer": ["6 6 2 2"],
            "options": ["6 6 2 2", "6 6 7 7", "1 1 2 2", "1 1 7 7"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "63a411e18573214b915d2555",
            "question": "Considere el siguiente segmento de código. Elija la opción apropiada para completar los espacios en blanco en LÍNEA-1, de modo que la salida del código sea: 300 20000.\n```cpp\n#include <iostream>\nusing namespace std;\nvoid compute(int n1, int n2, ________, ________){ //LÍNEA-1\nn3 = n1 + n2;\n*n4 = n1 * n2;\n}\nint main(){\nint a = 100, b = 200, c = 0, d = 0;\ncompute(a, b, c, &d); //LÍNEA-2\ncout << c << \", \";\ncout << d;\nreturn 0;\n}\n```",
            "answer": "int& n3, int \\*n4",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["int& n3, int \\*n4"],
            "options": [
              "int n3, int\\* n4",
              "int& n3, int \\*n4",
              "int* n3, int* n4",
              "int& n3, int& n4"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1d5fdc53b65f922bc2180e4b",
            "question": "Considere el siguiente segmento de código. ¿Cuál será la salida/error?\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\nint a = 2, *b;\n*b = 5;\nint * const ptr;    // LÍNEA-1\n// LÍNEA-2\nptr = b;\ncout << *ptr;\nreturn 0;\n}\n```",
            "answer": "Error de compilación en LÍNEA-1: 'ptr' const no inicializado; Error de compilación en LÍNEA-2: asignación de variable de solo lectura 'ptr'",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Error de compilación en LÍNEA-1: 'ptr' const no inicializado",
              "Error de compilación en LÍNEA-2: asignación de variable de solo lectura 'ptr'"
            ],
            "options": [
              "`<valor basura>`",
              "5",
              "Error de compilación en LÍNEA-1: 'ptr' const no inicializado",
              "Error de compilación en LÍNEA-2: asignación de variable de solo lectura 'ptr'"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9b1bba994e834040b1d5583a",
            "question": "Considere el siguiente segmento de código. ¿Cuál será la salida/error?\n```cpp\n#include <iostream>\nusing namespace std;\nvoid fun(int a = 5) { cout << a << endl; }\n//LÍNEA-1\nint fun(int x = 10) { cout << x << endl; return 0; }    //LÍNEA-2\nint main() {\nfun();\nreturn 0;\n}\n```",
            "answer": "Error de compilación en LÍNEA-2: nueva declaración ambigua de 'int fun(int)'",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Error de compilación en LÍNEA-2: nueva declaración ambigua de 'int fun(int)'"
            ],
            "options": [
              "5",
              "10",
              "5",
              "Error de compilación en LÍNEA-2: nueva declaración ambigua de 'int fun(int)'"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "162c2aa2d3e89522394b725b",
            "question": "Considere el siguiente segmento de código. Complete el espacio en blanco en LÍNEA-1 de modo que el programa imprima 5 + i3\n```cpp\n#include<iostream>\nusing namespace std;\nstruct complex{\nint re, im;\nvoid show(){ cout << re << \" + i\" << im; }\n};\n______________________________________{ //Línea-1\nc2.re = c1.re+c2.re;\nc2.im = c1.im+c2.im;\nreturn c2;\n}\nint main(){\nstruct complex c1={2,5},c2{3,-2};\nstruct complex t = c1 + c2;\nt.show();\nreturn 0;\n}\n```",
            "answer": "complex operator+(complex &c1, complex &c2)",
            "explanation": "[Referencia](https://www.w3schools.com/cpp/cpp_structs.asp)",
            "hint": null,
            "correctAnswer": ["complex operator+(complex &c1, complex &c2)"],
            "options": [
              "complex operator+(complex &c1, complex &c2)",
              "complex operator+(const complex &c1, const complex &c2)",
              "operator+(complex &c1, complex &c2)",
              "complex +(complex &c1, complex &c2)"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e471c234fd3df8893127c73b",
            "question": "Considere el siguiente programa. ¿Qué línea/s generará(n) un error?\n```cpp\n#include<iostream>\nusing namespace std;\nclass myClass{\nint pra = 5;\npublic:\nint pub = 10;\nvoid set_pr(int x){ pra = x; }\nvoid set_pu(int x){ pub = x; }\n};\nint main(){\nmyClass m;\nint a, b;\na = m.pra; //LÍNEA-1\nb = m.pub; //LÍNEA-2\nm.set_pr(100); //LÍNEA-3\nm.set_pu(200); //LÍNEA-4\nreturn 0;\n}\n```",
            "answer": "LÍNEA-1",
            "explanation": "[Referencia](https://stackoverflow.com/questions/4855422/c-classes-public-private-and-protected)",
            "hint": null,
            "correctAnswer": ["LÍNEA-1"],
            "options": ["LÍNEA-1", "LÍNEA-2", "LÍNEA-3", "LÍNEA-4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "701af0f8a64df1f753c6204f",
            "question": "Considere la siguiente clase. Complete los espacios en blanco con especificadores de acceso apropiados para que el miembro y pueda ser accedido desde fuera de la clase pero el miembro x no pueda ser accedido.\n```cpp\nclass Test{\n________:\nint x;\n________:\nint y;\n/* Más código */\n};\n```",
            "answer": "private, private",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["private, private"],
            "options": ["public, public", "public, private", "private, public", "private, private"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "02b3ed2c12de35e115600923",
            "question": "¿Qué estándar de C++ agregó inicializadores de miembros predeterminados en clase?",
            "answer": "C++11",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C++11"],
            "options": ["C++98", "C++11", "C++14", "C++17."],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "23b91c687ce8997d983e7da5",
            "question": "¿Puede usar la deducción de tipo auto para miembros de datos no estáticos?",
            "answer": "No",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["No"],
            "options": ["Sí, desde C++11", "No", "Sí, desde C++20"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "496a7906ab5cd70eb0c72765",
            "question": "¿Necesita definir un miembro de datos inline static en un archivo cpp?",
            "answer": "No, la definición ocurre en el mismo lugar donde se declara un miembro inline static.",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": [
              "No, la definición ocurre en el mismo lugar donde se declara un miembro inline static."
            ],
            "options": [
              "No, la definición ocurre en el mismo lugar donde se declara un miembro inline static.",
              "Sí, el compilador necesita la definición en un archivo cpp.",
              "Sí, el compilador necesita una definición en todas las unidades de traducción que usen esta variable."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9ddb992adbf9369a7d2f14a4",
            "question": "¿Cuál es la salida del siguiente código:\n```cpp\nstruct S {\n    int a { 10 };\n    int b { 42 };\n};\nS s { 1 };\nstd::cout << s.a << \", \" << s.b;\n```",
            "answer": "La salida es: 1, 42",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["La salida es: 1, 42"],
            "options": ["La salida es: 1, 0", "La salida es: 10, 42", "La salida es: 1, 42"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5ef962524f1524eccd5b005b",
            "question": "¿Puede una variable inline static ser no constante?",
            "answer": "Sí, es solo una variable regular.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Sí, es solo una variable regular."],
            "options": [
              "Sí, es solo una variable regular.",
              "No, las variables inline deben ser constantes."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "47d80b63d6d8f39a7704420a",
            "question": "Considere el siguiente código:\n```cpp\nstruct C {\n    C(int x) : a(x) { }\n    int a { 10 };\n    int b { 42 };\n};\nC c(0);\n```",
            "answer": "C::a se inicializa solo una vez con 0 en el constructor.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C::a se inicializa solo una vez con 0 en el constructor."],
            "options": [
              "C::a se inicializa dos veces. La primera vez, se inicializa con 10, y luego la segunda vez con 0 en el constructor.",
              "C::a se inicializa solo una vez con 0 en el constructor.",
              "El código no compila porque el compilador no puede decidir cómo inicializar el miembro C::a.",
              "2 bytes"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2686d785b7c89b4c4dfcc000",
            "question": "¿Qué sucede cuando lanzas una excepción desde un constructor?",
            "answer": "El objeto se considera \"parcialmente creado\", y por lo tanto, el compilador no llamará a su destructor.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "El objeto se considera \"parcialmente creado\", y por lo tanto, el compilador no llamará a su destructor."
            ],
            "options": [
              "El objeto se considera \"creado\", por lo que seguirá el ciclo de vida regular de un objeto.",
              "El objeto se considera \"parcialmente creado\", y por lo tanto, el compilador no llamará a su destructor.",
              "El compilador llama a std::terminate ya que no se pueden lanzar excepciones desde constructores."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d23210d53361e246363b8a08",
            "question": "¿Qué sucede cuando compilas este código?\n```cpp\nstruct Point { int x; int y; };\nPoint pt {.y = 10, .x = 11 };\nstd::cout << pt.x << \", \" << pt.y;\n```",
            "answer": "El código no compila. Los designadores deben estar en el mismo orden que los miembros de datos en la clase Point.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "El código no compila. Los designadores deben estar en el mismo orden que los miembros de datos en la clase Point."
            ],
            "options": [
              "El código no compila. Los designadores deben estar en el mismo orden que los miembros de datos en la clase Point.",
              "El código compila e imprime 11, 10.",
              "El código compila e imprime 10, 11."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ead68ccb092898b4dba4f0d6",
            "question": "¿Funcionará este código en C++11?\n```cpp\nstruct User { std::string name = \"unknown\"; unsigned age { 0 }; };\nUser u { \"John\", 101 };\n```",
            "answer": "El código compila a partir del modo C++14.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["El código compila a partir del modo C++14."],
            "options": [
              "Sí, el código compila en modo C++11.",
              "El código compila a partir del modo C++14.",
              "El código no compila incluso en C++20."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2789507396f433d647c4c37f",
            "question": "Suponga que tiene un std::map<string, int> m;. Seleccione la única afirmación verdadera sobre el siguiente bucle:\n```cpp\nfor (const pair<string, int>& elem : m)\n```",
            "answer": "A El bucle itera correctamente sobre el mapa, sin crear copias adicionales.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "A El bucle itera correctamente sobre el mapa, sin crear copias adicionales."
            ],
            "options": [
              "A El bucle itera correctamente sobre el mapa, sin crear copias adicionales.",
              "B El bucle creará una copia de cada elemento en el mapa ya que el tipo de elem no coincide.",
              "C El código no compilará porque un par const no puede vincularse a un mapa."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5a5c1b3b641685d0bab33245",
            "question": "Identifique la extensión correcta del archivo de encabezado definido por el usuario en C++.",
            "answer": ".h",
            "explanation": null,
            "hint": null,
            "correctAnswer": [".h"],
            "options": [".cpp", ".hg", ".h", ".hf"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "594e76c998486380907a8c22",
            "question": "Identifique el tipo de constructor incorrecto.\n```cpp\nauto x = 4000.22;\n```",
            "answer": "Constructor Amigo",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Constructor Amigo"],
            "options": [
              "Constructor Amigo",
              "Constructor Predeterminado",
              "Constructor Parametrizado",
              "Constructor de Copia"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "84cfc3ca98ac6ac7f659a1a0",
            "question": "¿Cuál de los siguientes tipos de datos es compatible con C++ pero no con C?",
            "answer": "bool",
            "explanation": "[Referencia]: https://stackoverflow.com/questions/1608318/is-bool-a-native-c-type",
            "hint": null,
            "correctAnswer": ["bool"],
            "options": ["bool", "int", "double", "float"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "abd47fdd1be14791ebbede04",
            "question": "Identifique la sintaxis correcta para declarar arreglos en C++.",
            "answer": "int arr[10]",
            "explanation": "[Referencia]: (https://en.cppreference.com/w/cpp/language/array)",
            "hint": null,
            "correctAnswer": ["int arr[10]"],
            "options": ["int arr[10]", "array arr[10]", "array{10}", "int arr"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9a25b931e89d26c6f9eb5d73",
            "question": "El tamaño de wchat_t es.",
            "answer": "Depende del número de bits en el sistema",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Depende del número de bits en el sistema"],
            "options": ["2", "4", "2 o 4", "Depende del número de bits en el sistema"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3fc30e3d4dceb086e77ecf54",
            "question": "¿Cuál de los siguientes bucles es mejor cuando conocemos el número de iteraciones?",
            "answer": "for",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["for"],
            "options": ["while", "for", "do", "Todos los anteriores"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3813a3f84e17ab987ca4755f",
            "question": "¿Qué palabra clave se usa para definir las macros en C++?",
            "answer": "#define",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["#define"],
            "options": ["#macro", "#define", "macro", "keyword"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8827dbcfb746a32dfc7ecca3",
            "question": "¿Cuál de los siguientes operadores debería preferirse para sobrecargarse como una función global en lugar de un método miembro?",
            "answer": "Operador de Comparación",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Operador de Comparación"],
            "options": [
              "Postfijo ++",
              "Operador de Comparación",
              "Operador de Inserción <<",
              "Prefijo++"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e4e9d85958bdf786bdaf1b58",
            "question": "¿Cómo podemos restringir la asignación dinámica de objetos de una clase usando new?",
            "answer": "Haciendo operadores new y new[] privados vacíos",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Haciendo operadores new y new[] privados vacíos"],
            "options": [
              "Sobrecargando el operador new",
              "Haciendo un operador new privado vacío.",
              "Haciendo operadores new y new[] privados vacíos",
              "Sobrecargando operadores new y operadores new[]"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d13e4ff88b48ea31398b9d90",
            "question": "¿Cuál es la complejidad temporal del código a continuación?\n```cpp\nfor(int i=0;i<n;i++){\n   for(int j=0;j<n;j++){\n       cout<<\"hello\";\n    }\n}\n```",
            "answer": "O(n^2)",
            "explanation": "[Referencia](<https://medium.com/enjoy-algorithm/analysis-of-loop-in-programming-cc9a644ef8cd#:~:text=At%20each%20step%20of%20the%20iteration%2C%20the%20nested%20loop%20is,%20%3D%20O(n%C2%B2)>)",
            "hint": null,
            "correctAnswer": ["O(n^2)"],
            "options": ["O(n^3)", "O(n^2)", "O(n)", "O(1)"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ba1c5d50ca9deb580496f8eb",
            "question": "¿Cuál es la salida del código dado a continuación?\n```cpp\nint a=10;\nint k=++a;\nint m=a++;\ncout<<k+m;\n```",
            "answer": "22",
            "explanation": "Tanto **++a** como **a++** aumentan el valor de a en 1 (es decir: 11) y por lo tanto k+m se convierte en 22.",
            "hint": null,
            "correctAnswer": ["22"],
            "options": ["20", "21", "22", "23"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "de5667332ce25f90cc42157f",
            "question": "¿Qué construcción de C++ se usa para el manejo de excepciones?",
            "answer": "try-catch",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["try-catch"],
            "options": ["try-catch", "if-else", "for loop", "switch-case"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d929421a16aae80ecf6c22e5",
            "question": "¿Cuál es el propósito de la declaración `break` en un bucle en C++?",
            "answer": "Terminar el bucle",
            "explanation": "[Referencia]: (https://www.tutorialspoint.com/cprogramming/c_break_statement.htm)",
            "hint": null,
            "correctAnswer": ["Terminar el bucle"],
            "options": [
              "Salir del programa",
              "Saltar la iteración actual y continuar con la siguiente",
              "Terminar el bucle",
              "Devolver un valor"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e1b8a27df6198e55588f43b7",
            "question": "En C++, ¿cuál es el propósito de la palabra clave `const` cuando se usa con una variable?",
            "answer": "Hace que la variable sea inmutable",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Hace que la variable sea inmutable"],
            "options": [
              "Hace que la variable sea inmutable",
              "Cambia el tipo de datos",
              "Define una función constante",
              "Hace que la variable sea un puntero"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "107d9cff7a5e37ed120faa5e",
            "question": "¿Cuál es más efectivo al llamar a las funciones de C++?",
            "answer": "Llamada por referencia",
            "explanation": "[Referencia]: (https://www.algbly.com/More/MCQs/Cpp-mcq/Cpp-functions.html)",
            "hint": null,
            "correctAnswer": ["Llamada por referencia"],
            "options": [
              "Llamada por referencia",
              "Llamada por valor",
              "Llamada por puntero",
              "Llamada por objeto"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0023ee9f2323275dfd2ac291",
            "question": "¿Cuál será la salida del siguiente programa de C++?\n```cpp\n#include <iostream>\nusing namespace std;\nclass A{\npublic:\n\tA(){\n\t\tcout<<\"Constructor called\\n\";\n\t   }\n\t~A(){\n\t\tcout<<\"Destructor called\\n\";\n\t    }\n};\nint main(int argc, char const *argv[])\n{\n\tA *a = new A[5];\n\tdelete[] a;\n\treturn 0;\n}\n```",
            "answer": "\"Constructor called\" cinco veces y luego \"Destructor called\" cinco veces",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "\"Constructor called\" cinco veces y luego \"Destructor called\" cinco veces"
            ],
            "options": [
              "Fallo de segmentación",
              "\"Constructor called\" cinco veces y luego \"Destructor called\" cinco veces",
              "\"Constructor called\" cinco veces y luego \"Destructor called\" una vez",
              "Error"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8d01084d3f83b86cb4d61bca",
            "question": "¿Cuál opción NO está relacionada con declarar la variable miembro count como static en my_class?\n```cpp\nclass my_class{\n    public: static int count;\n}\n```",
            "answer": "La variable no puede ser modificada por ninguna parte del código en la misma aplicación o hilo. Sin embargo, otros hilos pueden modificarla.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "La variable no puede ser modificada por ninguna parte del código en la misma aplicación o hilo. Sin embargo, otros hilos pueden modificarla."
            ],
            "options": [
              "Todos los objetos que intentan acceder a su variable miembro count realmente se refieren a la única variable count vinculada a la clase static.",
              "La variable existe incluso cuando no se han definido objetos de la clase, por lo que puede ser modificada en cualquier punto del código fuente.",
              "La variable no puede ser modificada por ninguna parte del código en la misma aplicación o hilo. Sin embargo, otros hilos pueden modificarla.",
              "La variable se asigna solo una vez, independientemente de cuántos objetos se instancien, porque está vinculada a la clase misma, no a sus instancias."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a850a76e0e9b59ac0002c03e",
            "question": "¿Cuál es el propósito de la palabra clave `constexpr` en C++?",
            "answer": "`constexpr` se usa para indicar que una expresión puede ser evaluada en tiempo de compilación, haciéndola adecuada para su uso en expresiones constantes.",
            "explanation": "[Ref](https://learn.microsoft.com/en-us/cpp/cpp/constexpr-cpp?view=msvc-170#:~:text=constexpr%20indica%20que%20el%20valor,argumentos%20de%20plantilla%20y%20declaraciones%20de%20arreglos.)",
            "hint": null,
            "correctAnswer": [
              "`constexpr` se usa para indicar que una expresión puede ser evaluada en tiempo de compilación, haciéndola adecuada para su uso en expresiones constantes."
            ],
            "options": [
              "Se usa para definir constantes en C++.",
              "`constexpr` se usa para especificar que una variable es un puntero constante.",
              "`constexpr` se usa para indicar que una expresión puede ser evaluada en tiempo de compilación, haciéndola adecuada para su uso en expresiones constantes.",
              "Es una palabra clave usada para crear funciones asíncronas."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "210f4d78e6a70a4bf52296ff",
            "question": "¿Qué es un metaprograma de plantilla en C++?\n- Ref(https://www.geeksforgeeks.org/template-metaprogramming-in-c/)",
            "answer": "Un metaprograma de plantilla es una computación en tiempo de compilación, donde las plantillas y la especialización de plantillas se usan para realizar cálculos en tiempo de compilación.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Un metaprograma de plantilla es una computación en tiempo de compilación, donde las plantillas y la especialización de plantillas se usan para realizar cálculos en tiempo de compilación."
            ],
            "options": [
              "Un metaprograma de plantilla es un lenguaje de programación de alto nivel.",
              "Se refiere a la metaprogramación que usa plantillas en C++.",
              "Es un tipo de patrón de diseño de interfaz de usuario.",
              "Un metaprograma de plantilla es una computación en tiempo de compilación, donde las plantillas y la especialización de plantillas se usan para realizar cálculos en tiempo de compilación."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b40771b2054a681849010946",
            "question": "Identifique el ejemplo correcto para un operador de pre-incremento.",
            "answer": "++i",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["++i"],
            "options": ["++i", "i++", "--i", "+i"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "573a68659efdd0ab2bba9ae7",
            "question": "¿Cuál será la salida del siguiente código?\n```cpp\n{% raw %}\nint matrix[3][3] = {{1, 2, 3},{4, 5, 6},{7, 8, 9}};\nfor(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n        int a = matrix[i][j];\n        matrix[i][j] = matrix[j][i];\n        matrix[j][i] = a;\n    }\n}\n{% endraw %}\n```",
            "answer": "Misma matriz",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Misma matriz"],
            "options": [
              "Transpuesta de matriz",
              "Misma matriz",
              "Imagen especular de la matriz",
              "Matriz invertida"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f13af9b8caa86d54c52deab7",
            "question": "¿Qué es una condición de carrera en C++?",
            "answer": "Una condición donde múltiples hilos acceden a datos compartidos concurrentemente, y el resultado depende del momento de su ejecución",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/language/memory_model)",
            "hint": null,
            "correctAnswer": [
              "Una condición donde múltiples hilos acceden a datos compartidos concurrentemente, y el resultado depende del momento de su ejecución"
            ],
            "options": [
              "Una condición donde el programa se ejecuta más rápido de lo esperado",
              "Una condición donde múltiples hilos acceden a datos compartidos concurrentemente, y el resultado depende del momento de su ejecución",
              "Una condición donde dos hilos compiten por tiempo de CPU",
              "Una condición donde un bucle se ejecuta demasiado rápido y necesita ser ralentizado"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "25f711842dbc828174937558",
            "question": "Considere el siguiente código que tiene una condición de carrera. ¿Cuál es la forma correcta de arreglarlo?\n```cpp\n#include <thread>\n#include <vector>\nint counter = 0;\nvoid incrementCounter() {\n    for(int i = 0; i < 1000; i++) {\n        counter++;\n    }\n}\nint main() {\n    std::vector<std::thread> threads;\n    for(int i = 0; i < 10; i++) {\n        threads.push_back(std::thread(incrementCounter));\n    }\n    for(auto& t : threads) {\n        t.join();\n    }\n    return 0;\n}\n```",
            "answer": "Usar `std::mutex` para bloquear/desbloquear alrededor de `counter++` en la sección crítica",
            "explanation": "[Referencia](https://en.cppreference.com/w/cpp/thread/mutex)",
            "hint": null,
            "correctAnswer": [
              "Usar `std::mutex` para bloquear/desbloquear alrededor de `counter++` en la sección crítica"
            ],
            "options": [
              "Agregar la palabra clave `volatile`: `volatile int counter = 0;`",
              "Usar `std::mutex` para bloquear/desbloquear alrededor de `counter++` en la sección crítica",
              "Usar `std::this_thread::sleep_for()` para retrasar cada incremento",
              "Cambiar `counter++` a `++counter` para operación atómica"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "457c42f9afa867e8c3ca0aaf",
            "question": "¿Cuál es el propósito de `std::move` en C++11?",
            "answer": "Convertir un objeto a una referencia rvalue, habilitando la semántica de movimiento",
            "explanation": "**Explicación:**\n`std::move` es una conversión que produce una referencia rvalue a su argumento, permitiendo que los recursos se muevan en lugar de copiarse. No mueve nada por sí mismo, pero permite que se llamen constructores de movimiento y operadores de asignación de movimiento.\n[Referencia](https://en.cppreference.com/w/cpp/utility/move)",
            "hint": null,
            "correctAnswer": [
              "Convertir un objeto a una referencia rvalue, habilitando la semántica de movimiento"
            ],
            "options": [
              "Copiar un objeto a una nueva ubicación",
              "Convertir un objeto a una referencia rvalue, habilitando la semántica de movimiento",
              "Mover físicamente la memoria de una dirección a otra",
              "Eliminar un objeto y crear uno nuevo"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0c4aa429031adad4d67d412d",
            "question": "¿Cuál es la salida de este código?\n```cpp\n#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v1 = {1, 2, 3};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v1.size() << \" \" << v2.size();\n    return 0;\n}\n```",
            "answer": "0 3",
            "explanation": "**Explicación:**\nDespués de `std::move(v1)`, v1 está en un estado válido pero no especificado. Típicamente, queda vacío (tamaño 0) y v2 toma posesión de los elementos.\n[Referencia](https://en.cppreference.com/w/cpp/utility/move)",
            "hint": null,
            "correctAnswer": ["0 3"],
            "options": ["3 3", "0 3", "3 0", "Error de compilación"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9ad2404cb62a04f8779d1bdd",
            "question": "¿Qué es una expresión lambda en C++?",
            "answer": "Un objeto función anónimo que puede capturar variables de su ámbito envolvente",
            "explanation": "**Explicación:**\nLas expresiones lambda, introducidas en C++11, permiten escribir funciones anónimas en línea. Pueden capturar variables del ámbito circundante y se usan a menudo con algoritmos de la STL.\n[Referencia](https://en.cppreference.com/w/cpp/language/lambda)",
            "hint": null,
            "correctAnswer": [
              "Un objeto función anónimo que puede capturar variables de su ámbito envolvente"
            ],
            "options": [
              "Una función matemática",
              "Un objeto función anónimo que puede capturar variables de su ámbito envolvente",
              "Una función plantilla",
              "Una definición de macro"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "97734f2b9a0baca4d09e6d56",
            "question": "¿Qué hace la palabra clave `auto` en C++11?",
            "answer": "Deduce automáticamente el tipo de una variable desde su inicializador",
            "explanation": "**Explicación:**\nLa palabra clave `auto` en C++11 permite la deducción automática de tipo desde el inicializador, haciendo el código más conciso y fácil de mantener.\n[Referencia](https://en.cppreference.com/w/cpp/language/auto)",
            "hint": null,
            "correctAnswer": [
              "Deduce automáticamente el tipo de una variable desde su inicializador"
            ],
            "options": [
              "Hace que una variable tenga duración de almacenamiento automático",
              "Deduce automáticamente el tipo de una variable desde su inicializador",
              "Hace que una función sea inline",
              "Declara una variable global"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "91efdb67457cfba46254d99a",
            "question": "¿Cuál es la diferencia entre `std::unique_ptr` y `std::shared_ptr`?",
            "answer": "unique_ptr tiene propiedad exclusiva, shared_ptr permite múltiples propietarios",
            "explanation": "**Explicación:**\n`std::unique_ptr` proporciona propiedad exclusiva - solo un unique_ptr puede poseer un recurso. `std::shared_ptr` usa conteo de referencias para permitir que múltiples shared_ptrs posean el mismo recurso.\n[Referencia](https://en.cppreference.com/w/cpp/memory/unique_ptr)",
            "hint": null,
            "correctAnswer": [
              "unique_ptr tiene propiedad exclusiva, shared_ptr permite múltiples propietarios"
            ],
            "options": [
              "unique_ptr tiene propiedad exclusiva, shared_ptr permite múltiples propietarios",
              "unique_ptr es más rápido pero menos seguro",
              "shared_ptr solo puede usarse con clases",
              "No hay diferencia"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a0168c8c04d7e2c685985b84",
            "question": "¿Qué es RAII en C++?",
            "answer": "Resource Acquisition Is Initialization (La Adquisición de Recursos es Inicialización)",
            "explanation": "**Explicación:**\nRAII es un modismo de programación de C++ donde la adquisición de recursos está vinculada al tiempo de vida del objeto. Los recursos se adquieren en constructores y se liberan en destructores, asegurando una limpieza adecuada.\n[Referencia](https://en.cppreference.com/w/cpp/language/raii)",
            "hint": null,
            "correctAnswer": [
              "Resource Acquisition Is Initialization (La Adquisición de Recursos es Inicialización)"
            ],
            "options": [
              "Interfaz de Iterador de Acceso Aleatorio",
              "Resource Acquisition Is Initialization (La Adquisición de Recursos es Inicialización)",
              "Interfaz de Implementación de Algoritmo Recursivo",
              "Asignación e Inicialización en Tiempo de Ejecución"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ea4824aeffc092f0ec2736cb",
            "question": "¿Cuál es la salida de este código?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    auto lambda = [x]() mutable { x += 10; return x; };\n    std::cout << lambda() << \" \" << x;\n    return 0;\n}\n```",
            "answer": "15 5",
            "explanation": "**Explicación:**\nLa lambda captura x por valor. La palabra clave `mutable` permite la modificación de la copia capturada. La x original permanece sin cambios.\n[Referencia](https://en.cppreference.com/w/cpp/language/lambda)",
            "hint": null,
            "correctAnswer": ["15 5"],
            "options": ["5 5", "15 5", "15 15", "5 15"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f46d8a4ede76b4315ed8c9d8",
            "question": "¿Qué es `constexpr` en C++11?",
            "answer": "Especifica que una función o variable puede evaluarse en tiempo de compilación",
            "explanation": "**Explicación:**\n`constexpr` indica que un valor o función puede evaluarse en tiempo de compilación, habilitando cómputo y optimización en tiempo de compilación.\n[Referencia](https://en.cppreference.com/w/cpp/language/constexpr)",
            "hint": null,
            "correctAnswer": [
              "Especifica que una función o variable puede evaluarse en tiempo de compilación"
            ],
            "options": [
              "Una expresión constante que solo puede usarse con enteros",
              "Especifica que una función o variable puede evaluarse en tiempo de compilación",
              "Una macro para definir constantes",
              "Una palabra clave para declarar punteros const"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d8d920891c2d7d2383b60578",
            "question": "¿Cuál es el propósito de `std::forward`?",
            "answer": "Preservar la categoría de valor (lvalue/rvalue) de un argumento reenviado",
            "explanation": "**Explicación:**\n`std::forward` se usa en funciones plantilla para reenviar perfectamente argumentos mientras preserva su categoría de valor, esencial para implementar el reenvío perfecto.\n[Referencia](https://en.cppreference.com/w/cpp/utility/forward)",
            "hint": null,
            "correctAnswer": [
              "Preservar la categoría de valor (lvalue/rvalue) de un argumento reenviado"
            ],
            "options": [
              "Mover un objeto hacia adelante en la memoria",
              "Preservar la categoría de valor (lvalue/rvalue) de un argumento reenviado",
              "Iterar hacia adelante a través de un contenedor",
              "Declarar una declaración anticipada"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ff6e67f10410db901e02ff0a",
            "question": "¿Qué es una plantilla variádica?",
            "answer": "Una plantilla que acepta un número variable de parámetros de plantilla",
            "explanation": "**Explicación:**\nLas plantillas variádicas, introducidas en C++11, permiten que las plantillas acepten cualquier número de argumentos de plantilla, habilitando programación genérica flexible.\n[Referencia](https://en.cppreference.com/w/cpp/language/parameter_pack)",
            "hint": null,
            "correctAnswer": [
              "Una plantilla que acepta un número variable de parámetros de plantilla"
            ],
            "options": [
              "Una plantilla con tipos de retorno variables",
              "Una plantilla que acepta un número variable de parámetros de plantilla",
              "Una plantilla que puede instanciarse múltiples veces",
              "Una plantilla con parámetros opcionales"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a147ec81afd27e99b91451ef",
            "question": "¿Qué representa `nullptr`?",
            "answer": "Una constante de puntero nulo con tipo std::nullptr_t",
            "explanation": "**Explicación:**\n`nullptr` es una palabra clave introducida en C++11 que representa un puntero nulo. Es seguro en tipos a diferencia de NULL o 0.\n[Referencia](https://en.cppreference.com/w/cpp/language/nullptr)",
            "hint": null,
            "correctAnswer": ["Una constante de puntero nulo con tipo std::nullptr_t"],
            "options": [
              "Un carácter nulo",
              "Una constante de puntero nulo con tipo std::nullptr_t",
              "Una cadena vacía",
              "Valor cero"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "030e7de206cd3aeae5d0f08e",
            "question": "¿Cuál es la salida de este código?\n```cpp\n#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> p1 = std::make_shared<int>(42);\n    std::shared_ptr<int> p2 = p1;\n    std::cout << p1.use_count();\n    return 0;\n}\n```",
            "answer": "2",
            "explanation": "**Explicación:**\nTanto p1 como p2 comparten la propiedad del mismo entero, por lo que el conteo de referencias es 2.\n[Referencia](https://en.cppreference.com/w/cpp/memory/shared_ptr)",
            "hint": null,
            "correctAnswer": ["2"],
            "options": ["1", "2", "42", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "06bb0c86ebc7e200f7f8803e",
            "question": "¿Qué es `std::optional` en C++17?",
            "answer": "Un envoltorio que puede o no contener un valor",
            "explanation": "**Explicación:**\n`std::optional` es una clase plantilla que representa un valor opcional - contiene un valor o está vacío, proporcionando una forma segura en tipos de representar \"sin valor\".\n[Referencia](https://en.cppreference.com/w/cpp/utility/optional)",
            "hint": null,
            "correctAnswer": ["Un envoltorio que puede o no contener un valor"],
            "options": [
              "Un parámetro opcional en una función",
              "Un envoltorio que puede o no contener un valor",
              "Una plantilla para compilación opcional",
              "Una palabra clave para tipos opcionales"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0105d2ef244b59bfee11217a",
            "question": "¿Qué es el enlace estructurado en C++17?\n```cpp\nauto [x, y, z] = std::make_tuple(1, 2, 3);\n```",
            "answer": "Una característica que desempaqueta objetos tipo tupla en variables individuales",
            "explanation": "**Explicación:**\nLos enlaces estructurados permiten descomponer objetos en sus elementos constituyentes, haciendo el código más legible al trabajar con tuplas, pares o estructuras.\n[Referencia](https://en.cppreference.com/w/cpp/language/structured_binding)",
            "hint": null,
            "correctAnswer": [
              "Una característica que desempaqueta objetos tipo tupla en variables individuales"
            ],
            "options": [
              "Una forma de enlazar estructuras juntas",
              "Una característica que desempaqueta objetos tipo tupla en variables individuales",
              "Un método para crear datos estructurados",
              "Un enlace para miembros de estructuras"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b88e3086a8f3287cea84ee3c",
            "question": "¿Qué es `std::string_view` en C++17?",
            "answer": "Una referencia no propietaria a una cadena que evita copias",
            "explanation": "**Explicación:**\n`std::string_view` proporciona una referencia ligera y no propietaria a una cadena, evitando copias innecesarias y mejorando el rendimiento.\n[Referencia](https://en.cppreference.com/w/cpp/string/basic_string_view)",
            "hint": null,
            "correctAnswer": ["Una referencia no propietaria a una cadena que evita copias"],
            "options": [
              "Una vista de una cadena en una GUI",
              "Una referencia no propietaria a una cadena que evita copias",
              "Una cadena que solo puede verse, no modificarse",
              "Una clase de vista para mostrar cadenas"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e03c568c88b583d8c0841ebf",
            "question": "¿Qué son los conceptos en C++20?",
            "answer": "Conjuntos nombrados de requisitos para parámetros de plantilla",
            "explanation": "**Explicación:**\nLos conceptos son una característica de C++20 que permite especificar restricciones en parámetros de plantilla, haciendo el código de plantilla más legible y proporcionando mejores mensajes de error.\n[Referencia](https://en.cppreference.com/w/cpp/language/constraints)",
            "hint": null,
            "correctAnswer": ["Conjuntos nombrados de requisitos para parámetros de plantilla"],
            "options": [
              "Ideas abstractas en programación",
              "Conjuntos nombrados de requisitos para parámetros de plantilla",
              "Patrones de diseño conceptuales",
              "Comentarios de documentación"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7dbe40184d475d0e224030cc",
            "question": "¿Qué es el operador de comparación de tres vías (<=>) en C++20?",
            "answer": "Un operador que devuelve información de ordenamiento (menor, igual, mayor)",
            "explanation": "**Explicación:**\nEl operador nave espacial (<=>) realiza una comparación de tres vías y devuelve una categoría de ordenamiento, simplificando las definiciones de operadores de comparación.\n[Referencia](https://en.cppreference.com/w/cpp/language/operator_comparison)",
            "hint": null,
            "correctAnswer": [
              "Un operador que devuelve información de ordenamiento (menor, igual, mayor)"
            ],
            "options": [
              "Una comparación de tres valores",
              "Un operador que devuelve información de ordenamiento (menor, igual, mayor)",
              "Tres operadores de comparación separados",
              "Una comparación ternaria"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3934f05181bcc331fd76776e",
            "question": "¿Qué es `std::span` en C++20?",
            "answer": "Una vista no propietaria sobre una secuencia contigua de objetos",
            "explanation": "**Explicación:**\n`std::span` proporciona una vista sobre una secuencia contigua de objetos sin poseerlos, útil para pasar datos tipo array sin copiar.\n[Referencia](https://en.cppreference.com/w/cpp/container/span)",
            "hint": null,
            "correctAnswer": ["Una vista no propietaria sobre una secuencia contigua de objetos"],
            "options": [
              "Una medida de intervalo de tiempo",
              "Una vista no propietaria sobre una secuencia contigua de objetos",
              "Una estructura de datos de árbol de expansión",
              "Un elemento span en HTML"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0386de9a3d200ab7206834be",
            "question": "¿Cuál es la salida de este código?\n```cpp\n#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v = {1, 2, 3, 4, 5};\n    for (auto& x : v) {\n        x *= 2;\n    }\n    std::cout << v[2];\n    return 0;\n}\n```",
            "answer": "6",
            "explanation": "**Explicación:**\nEl bucle for basado en rango con `auto&` modifica cada elemento en su lugar. v[2] (originalmente 3) se convierte en 6.\n[Referencia](https://en.cppreference.com/w/cpp/language/range-for)",
            "hint": null,
            "correctAnswer": ["6"],
            "options": ["3", "6", "2", "12"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "61fb5d19a221044fc9dc1b6b",
            "question": "¿Qué es `std::variant` en C++17?",
            "answer": "Una unión segura en tipos que puede contener uno de varios tipos",
            "explanation": "**Explicación:**\n`std::variant` es una unión segura en tipos que puede contener un valor de uno de varios tipos especificados, proporcionando una alternativa más segura a las uniones de C.\n[Referencia](https://en.cppreference.com/w/cpp/utility/variant)",
            "hint": null,
            "correctAnswer": ["Una unión segura en tipos que puede contener uno de varios tipos"],
            "options": [
              "Una variable que puede variar",
              "Una unión segura en tipos que puede contener uno de varios tipos",
              "Una variante de una clase",
              "Una plantilla de variable"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "685ea4bf55ba918a16a295a2",
            "question": "¿Qué es `std::any` en C++17?",
            "answer": "Un contenedor seguro en tipos para valores únicos de cualquier tipo",
            "explanation": "**Explicación:**\n`std::any` puede almacenar un único valor de cualquier tipo copiable por construcción, proporcionando almacenamiento seguro en tipos con verificación de tipo en tiempo de ejecución.\n[Referencia](https://en.cppreference.com/w/cpp/utility/any)",
            "hint": null,
            "correctAnswer": [
              "Un contenedor seguro en tipos para valores únicos de cualquier tipo"
            ],
            "options": [
              "Cualquier tipo de variable",
              "Un contenedor seguro en tipos para valores únicos de cualquier tipo",
              "Un tipo comodín",
              "Un tipo opcional"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "eced0024b117b189fcf2b971",
            "question": "¿Cuál es la diferencia entre `std::array` y los arrays de estilo C?",
            "answer": "std::array conoce su tamaño y proporciona funciones miembro",
            "explanation": "**Explicación:**\n`std::array` es un contenedor que encapsula arrays de tamaño fijo, proporcionando información de tamaño e interfaz de contenedor STL mientras mantiene el rendimiento de los arrays de estilo C.\n[Referencia](https://en.cppreference.com/w/cpp/container/array)",
            "hint": null,
            "correctAnswer": ["std::array conoce su tamaño y proporciona funciones miembro"],
            "options": [
              "std::array conoce su tamaño y proporciona funciones miembro",
              "std::array es más lento",
              "Los arrays de estilo C son más seguros",
              "No hay diferencia"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "86f322fd459af84df79f1187",
            "question": "¿Qué es el reenvío perfecto?",
            "answer": "Preservar la categoría de valor de los argumentos al pasarlos a otra función",
            "explanation": "**Explicación:**\nEl reenvío perfecto usa `std::forward` y referencias universales para pasar argumentos a otra función mientras preserva su categoría de valor (lvalue o rvalue).\n[Referencia](https://en.cppreference.com/w/cpp/utility/forward)",
            "hint": null,
            "correctAnswer": [
              "Preservar la categoría de valor de los argumentos al pasarlos a otra función"
            ],
            "options": [
              "Reenvío sin errores",
              "Preservar la categoría de valor de los argumentos al pasarlos a otra función",
              "Paso rápido de parámetros",
              "Declaración anticipada de funciones"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2a58d3c1386f197f62370831",
            "question": "¿Cuál es la salida de este código?\n```cpp\n#include <iostream>\ntemplate<typename T>\nvoid func(T&& x) {\n    std::cout << std::is_lvalue_reference<T>::value;\n}\nint main() {\n    int a = 5;\n    func(a);\n    return 0;\n}\n```",
            "answer": "1",
            "explanation": "**Explicación:**\nCuando se pasa un lvalue a una referencia universal, T se deduce como una referencia lvalue, por lo que `std::is_lvalue_reference<T>::value` es verdadero (1).\n[Referencia](https://en.cppreference.com/w/cpp/language/reference)",
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["1", "0", "5", "Error de compilación"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "734f269f2579c80e8f0235f0",
            "question": "¿Qué es `std::invoke` en C++17?",
            "answer": "Una utilidad para llamar cualquier objeto invocable con argumentos dados",
            "explanation": "**Explicación:**\n`std::invoke` proporciona una forma uniforme de llamar cualquier invocable (función, puntero a función, función miembro, functor) con argumentos.\n[Referencia](https://en.cppreference.com/w/cpp/utility/functional/invoke)",
            "hint": null,
            "correctAnswer": [
              "Una utilidad para llamar cualquier objeto invocable con argumentos dados"
            ],
            "options": [
              "Una función para invocar programas",
              "Una utilidad para llamar cualquier objeto invocable con argumentos dados",
              "Un operador de invocación de métodos",
              "Un invocador para constructores"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "12a65e97d46d51e03f0a45e1",
            "question": "¿Qué es `if constexpr` en C++17?",
            "answer": "Un condicional en tiempo de compilación que descarta ramas en tiempo de compilación",
            "explanation": "**Explicación:**\n`if constexpr` evalúa la condición en tiempo de compilación y solo instancia la rama tomada, útil en metaprogramación de plantillas.\n[Referencia](https://en.cppreference.com/w/cpp/language/if)",
            "hint": null,
            "correctAnswer": [
              "Un condicional en tiempo de compilación que descarta ramas en tiempo de compilación"
            ],
            "options": [
              "Una declaración if constante",
              "Un condicional en tiempo de compilación que descarta ramas en tiempo de compilación",
              "Una declaración if que debe ser constante",
              "Una función constexpr con if"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0385ddda697f3413c9a46a70",
            "question": "¿Qué es una expresión de pliegue en C++17?",
            "answer": "Una forma de aplicar un operador binario a todos los elementos de un paquete de parámetros",
            "explanation": "**Explicación:**\nLas expresiones de pliegue proporcionan una sintaxis concisa para aplicar operadores binarios a paquetes de parámetros en plantillas variádicas.\n[Referencia](https://en.cppreference.com/w/cpp/language/fold)",
            "hint": null,
            "correctAnswer": [
              "Una forma de aplicar un operador binario a todos los elementos de un paquete de parámetros"
            ],
            "options": [
              "Una expresión que pliega código",
              "Una forma de aplicar un operador binario a todos los elementos de un paquete de parámetros",
              "Un algoritmo de plegado",
              "Una expresión para plegar contenedores"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5b05740c085316dc9d3df2e3",
            "question": "¿Cuál es la salida de este código?\n```cpp\n#include <iostream>\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int* p = arr;\n    std::cout << *(p + 3);\n    return 0;\n}\n```",
            "answer": "4",
            "explanation": "**Explicación:**\nAritmética de punteros: p + 3 apunta al 4º elemento (índice 3), que es 4.\n[Referencia](https://en.cppreference.com/w/cpp/language/operator_arithmetic)",
            "hint": null,
            "correctAnswer": ["4"],
            "options": ["1", "2", "3", "4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "535508bb6e152a2bc51cd156",
            "question": "¿Qué es `std::filesystem` en C++17?",
            "answer": "Una biblioteca para realizar operaciones en sistemas de archivos y rutas",
            "explanation": "**Explicación:**\n`std::filesystem` proporciona facilidades para realizar operaciones en sistemas de archivos y sus componentes, como rutas, archivos regulares y directorios.\n[Referencia](https://en.cppreference.com/w/cpp/filesystem)",
            "hint": null,
            "correctAnswer": [
              "Una biblioteca para realizar operaciones en sistemas de archivos y rutas"
            ],
            "options": [
              "Un controlador de sistema de archivos",
              "Una biblioteca para realizar operaciones en sistemas de archivos y rutas",
              "Un sistema de archivos virtual",
              "Una clase de flujo de archivos"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "104dc6dd952dcd79ee5ee24c",
            "question": "¿Para qué se usa `std::atomic`?",
            "answer": "Operaciones seguras para hilos en variables compartidas sin bloqueos",
            "explanation": "**Explicación:**\n`std::atomic` proporciona operaciones atómicas en variables compartidas, asegurando acceso seguro para hilos sin bloqueo explícito.\n[Referencia](https://en.cppreference.com/w/cpp/atomic/atomic)",
            "hint": null,
            "correctAnswer": [
              "Operaciones seguras para hilos en variables compartidas sin bloqueos"
            ],
            "options": [
              "Cálculos de energía atómica",
              "Operaciones seguras para hilos en variables compartidas sin bloqueos",
              "Tipos de datos atómicos",
              "Operaciones indivisibles en átomos"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ae3086e7ca26d8887a1751a1",
            "question": "¿Cuál es la diferencia entre `std::mutex` y `std::recursive_mutex`?",
            "answer": "recursive_mutex puede bloquearse múltiples veces por el mismo hilo",
            "explanation": "**Explicación:**\n`std::recursive_mutex` permite que el mismo hilo lo bloquee múltiples veces, mientras que `std::mutex` causaría un interbloqueo si el mismo hilo intenta bloquearlo dos veces.\n[Referencia](https://en.cppreference.com/w/cpp/thread/recursive_mutex)",
            "hint": null,
            "correctAnswer": ["recursive_mutex puede bloquearse múltiples veces por el mismo hilo"],
            "options": [
              "recursive_mutex puede bloquearse múltiples veces por el mismo hilo",
              "mutex es más rápido",
              "recursive_mutex está obsoleto",
              "No hay diferencia"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5160df2daf7655151b0e7216",
            "question": "¿Qué es `std::future` en C++11?",
            "answer": "Un objeto que proporciona acceso al resultado de una operación asíncrona",
            "explanation": "**Explicación:**\n`std::future` se usa para recuperar el resultado de una operación asíncrona iniciada con `std::async` o `std::promise`.\n[Referencia](https://en.cppreference.com/w/cpp/thread/future)",
            "hint": null,
            "correctAnswer": [
              "Un objeto que proporciona acceso al resultado de una operación asíncrona"
            ],
            "options": [
              "Una versión futura de C++",
              "Un objeto que proporciona acceso al resultado de una operación asíncrona",
              "Una clase basada en tiempo",
              "Una declaración futura"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c3ba4a903e07916911c3fa2c",
            "question": "¿Cuál es la salida de este código?\n```cpp\n#include <iostream>\nclass Base {\npublic:\n    virtual void show() { std::cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void show() override { std::cout << \"Derived\"; }\n};\nint main() {\n    Base* b = new Derived();\n    b->show();\n    delete b;\n    return 0;\n}\n```",
            "answer": "Derived",
            "explanation": "**Explicación:**\nDebido al polimorfismo de función virtual, se llama al show() de la clase Derived aunque el puntero sea de tipo Base\\*.\n[Referencia](https://en.cppreference.com/w/cpp/language/virtual)",
            "hint": null,
            "correctAnswer": ["Derived"],
            "options": ["Base", "Derived", "Error de compilación", "Comportamiento indefinido"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fcbf17c5676741999ec1d698",
            "question": "¿Para qué se usa `std::enable_if`?",
            "answer": "Para instanciación condicional de plantillas basada en SFINAE",
            "explanation": "**Explicación:**\n`std::enable_if` se usa para SFINAE (Substitution Failure Is Not An Error) para habilitar o deshabilitar condicionalmente especializaciones de plantilla.\n[Referencia](https://en.cppreference.com/w/cpp/types/enable_if)",
            "hint": null,
            "correctAnswer": ["Para instanciación condicional de plantillas basada en SFINAE"],
            "options": [
              "Para habilitar declaraciones if",
              "Para instanciación condicional de plantillas basada en SFINAE",
              "Para habilitar características",
              "Para verificar si algo está habilitado"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5bb0f558d81fc9a595840284",
            "question": "¿Qué es `std::tuple` en C++11?",
            "answer": "Una colección de tamaño fijo de valores heterogéneos",
            "explanation": "**Explicación:**\n`std::tuple` es una colección de tamaño fijo que puede contener elementos de diferentes tipos, generalizando `std::pair` a cualquier número de elementos.\n[Referencia](https://en.cppreference.com/w/cpp/utility/tuple)",
            "hint": null,
            "correctAnswer": ["Una colección de tamaño fijo de valores heterogéneos"],
            "options": [
              "Un par de dos elementos",
              "Una colección de tamaño fijo de valores heterogéneos",
              "Un triple de valores",
              "Una tupla en matemáticas"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "419d88bf4b3d13601ec9021d",
            "question": "¿Cuál es la salida de este código?\n```cpp\n#include <iostream>\nint main() {\n    int x = 10;\n    int& ref = x;\n    ref = 20;\n    std::cout << x;\n    return 0;\n}\n```",
            "answer": "20",
            "explanation": "**Explicación:**\nref es una referencia a x. Modificar ref modifica x directamente, por lo que x se convierte en 20.\n[Referencia](https://en.cppreference.com/w/cpp/language/reference)",
            "hint": null,
            "correctAnswer": ["20"],
            "options": ["10", "20", "Error de compilación", "Indefinido"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ecc2d78e1cf09b69a3038961",
            "question": "¿Para qué se usa `std::chrono`?",
            "answer": "Utilidades de tiempo que incluyen relojes, puntos de tiempo y duraciones",
            "explanation": "**Explicación:**\n`std::chrono` es una biblioteca para operaciones relacionadas con el tiempo, proporcionando relojes, puntos de tiempo y duraciones con seguridad de tipos.\n[Referencia](https://en.cppreference.com/w/cpp/chrono)",
            "hint": null,
            "correctAnswer": [
              "Utilidades de tiempo que incluyen relojes, puntos de tiempo y duraciones"
            ],
            "options": [
              "Ordenamiento cronológico",
              "Utilidades de tiempo que incluyen relojes, puntos de tiempo y duraciones",
              "Funciones de cronómetro",
              "Gestión de enfermedades crónicas"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fdc3de953d95603d3a70996b",
            "question": "¿Qué es `std::regex` en C++11?",
            "answer": "Una biblioteca para coincidencia de patrones de expresiones regulares",
            "explanation": "**Explicación:**\n`std::regex` proporciona soporte de expresiones regulares para coincidencia de patrones y procesamiento de texto en C++.\n[Referencia](https://en.cppreference.com/w/cpp/regex)",
            "hint": null,
            "correctAnswer": [
              "Una biblioteca para coincidencia de patrones de expresiones regulares"
            ],
            "options": [
              "Un motor de expresiones regulares",
              "Una biblioteca para coincidencia de patrones de expresiones regulares",
              "Una herramienta de reemplazo de texto",
              "Un formateador de cadenas"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "228749d77db9db43efde9eb6",
            "question": "¿Qué es `std::initializer_list`?",
            "answer": "Un objeto proxy ligero para acceder a arrays de const T",
            "explanation": "**Explicación:**\n`std::initializer_list` permite que las funciones acepten listas de valores entre llaves, habilitando sintaxis de inicialización uniforme.\n[Referencia](https://en.cppreference.com/w/cpp/utility/initializer_list)",
            "hint": null,
            "correctAnswer": ["Un objeto proxy ligero para acceder a arrays de const T"],
            "options": [
              "Una lista de inicializadores",
              "Un objeto proxy ligero para acceder a arrays de const T",
              "Una función de inicialización",
              "Un constructor de lista"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "43c2dda8ed6c618ddb80adbd",
            "question": "¿Cuál es la salida de este código?\n```cpp\n#include <iostream>\nint main() {\n    const int x = 10;\n    int* p = const_cast<int*>(&x);\n    *p = 20;\n    std::cout << x;\n    return 0;\n}\n```",
            "answer": "10 (comportamiento indefinido)",
            "explanation": "**Explicación:**\nEsto es comportamiento indefinido. Modificar un objeto const a través de const_cast conduce a resultados impredecibles. El compilador puede optimizar basándose en la suposición de const.\n[Referencia](https://en.cppreference.com/w/cpp/language/const_cast)",
            "hint": null,
            "correctAnswer": ["10 (comportamiento indefinido)"],
            "options": ["10 (comportamiento indefinido)", "20", "Error de compilación", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "aca85c1c1e3cee7d522f0ad5",
            "question": "¿Qué es `std::function` en C++11?",
            "answer": "Un envoltorio de función polimórfico de propósito general",
            "explanation": "**Explicación:**\n`std::function` es un envoltorio con tipo borrado que puede almacenar cualquier objeto invocable (función, lambda, functor) con una firma específica.\n[Referencia](https://en.cppreference.com/w/cpp/utility/functional/function)",
            "hint": null,
            "correctAnswer": ["Un envoltorio de función polimórfico de propósito general"],
            "options": [
              "Una declaración de función",
              "Un envoltorio de función polimórfico de propósito general",
              "Un puntero a función",
              "Una biblioteca de programación funcional"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ca4a9044642506e26f49e2d3",
            "question": "¿Para qué se usa `std::bind`?",
            "answer": "Para crear un nuevo invocable enlazando argumentos a una función",
            "explanation": "**Explicación:**\n`std::bind` crea un nuevo objeto función enlazando algunos argumentos a una función, útil para aplicación parcial de funciones.\n[Referencia](https://en.cppreference.com/w/cpp/utility/functional/bind)",
            "hint": null,
            "correctAnswer": ["Para crear un nuevo invocable enlazando argumentos a una función"],
            "options": [
              "Para enlazar variables juntas",
              "Para crear un nuevo invocable enlazando argumentos a una función",
              "Para enlazar clases",
              "Para enlazar memoria"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a280652023794e801e5eb691",
            "question": "¿En qué se basa `std::unordered_map`?",
            "answer": "Tabla hash",
            "explanation": "**Explicación:**\n`std::unordered_map` se implementa usando una tabla hash, proporcionando tiempo de búsqueda promedio O(1) comparado con O(log n) para `std::map`.\n[Referencia](https://en.cppreference.com/w/cpp/container/unordered_map)",
            "hint": null,
            "correctAnswer": ["Tabla hash"],
            "options": ["Árbol binario de búsqueda", "Tabla hash", "Lista enlazada", "Array"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6a959f5f19e149a7846cbffb",
            "question": "¿Cuál es la salida de este código?\n```cpp\n#include <iostream>\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    std::cout << sizeof(arr) / sizeof(arr[0]);\n    return 0;\n}\n```",
            "answer": "5",
            "explanation": "**Explicación:**\nsizeof(arr) da el total de bytes, sizeof(arr[0]) da bytes por elemento. La división da el número de elementos: 5.\n[Referencia](https://en.cppreference.com/w/cpp/language/sizeof)",
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["4", "5", "20", "1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "13cb29aefd6b72199cb4d102",
            "question": "¿Qué es `std::make_unique` en C++14?",
            "answer": "Una función para crear objetos std::unique_ptr",
            "explanation": "**Explicación:**\n`std::make_unique` es una función de utilidad que crea y devuelve un `std::unique_ptr`, proporcionando seguridad de excepciones y sintaxis más limpia.\n[Referencia](https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique)",
            "hint": null,
            "correctAnswer": ["Una función para crear objetos std::unique_ptr"],
            "options": [
              "Un generador de identificadores únicos",
              "Una función para crear objetos std::unique_ptr",
              "Un verificador de unicidad",
              "Un creador de valores únicos"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c258c58eb86c5ad73e62a9fc",
            "question": "¿Qué es `std::exchange` en C++14?",
            "answer": "Reemplaza un valor y devuelve el valor antiguo atómicamente",
            "explanation": "**Explicación:**\n`std::exchange` reemplaza el valor de un objeto y devuelve su valor antiguo en una sola operación.\n[Referencia](https://en.cppreference.com/w/cpp/utility/exchange)",
            "hint": null,
            "correctAnswer": ["Reemplaza un valor y devuelve el valor antiguo atómicamente"],
            "options": [
              "Un programa de intercambio de valores",
              "Reemplaza un valor y devuelve el valor antiguo atómicamente",
              "Un operador de intercambio",
              "Una función de intercambio"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8ecdf6935e4ce42037bea6da",
            "question": "¿Qué es `std::apply` en C++17?",
            "answer": "Invoca un invocable con una tupla de argumentos",
            "explanation": "**Explicación:**\n`std::apply` invoca un objeto invocable con una tupla de argumentos, desempaquetando la tupla como argumentos de función.\n[Referencia](https://en.cppreference.com/w/cpp/utility/apply)",
            "hint": null,
            "correctAnswer": ["Invoca un invocable con una tupla de argumentos"],
            "options": [
              "Un lanzador de aplicaciones",
              "Invoca un invocable con una tupla de argumentos",
              "Una función de aplicación",
              "Un aplicador de funciones"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "56b09028fd4d28698036f6b0",
            "question": "¿Cuál es la salida de este código?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    int y = ++x + x++;\n    std::cout << y;\n    return 0;\n}\n```",
            "answer": "Comportamiento indefinido",
            "explanation": "**Explicación:**\nModificar x múltiples veces entre puntos de secuencia conduce a comportamiento indefinido. El resultado es impredecible.\n[Referencia](https://en.cppreference.com/w/cpp/language/eval_order)",
            "hint": null,
            "correctAnswer": ["Comportamiento indefinido"],
            "options": ["11", "12", "Comportamiento indefinido", "13"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c49a4707799c02d53639b585",
            "question": "¿Qué es `std::decay` en C++11?",
            "answer": "Aplica conversión de array a puntero, función a puntero y elimina calificadores cv",
            "explanation": "**Explicación:**\n`std::decay` aplica transformaciones de tipo similares a lo que sucede al pasar argumentos por valor.\n[Referencia](https://en.cppreference.com/w/cpp/types/decay)",
            "hint": null,
            "correctAnswer": [
              "Aplica conversión de array a puntero, función a puntero y elimina calificadores cv"
            ],
            "options": [
              "Una función de decaimiento",
              "Aplica conversión de array a puntero, función a puntero y elimina calificadores cv",
              "Un marcador de obsolescencia",
              "Una constante de decaimiento"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1530c53c9cfe821a08302dc5",
            "question": "¿Qué es `std::conditional` en C++11?",
            "answer": "Elige un tipo u otro basado en un booleano en tiempo de compilación",
            "explanation": "**Explicación:**\n`std::conditional` es una metafunción que selecciona uno de dos tipos basándose en una condición booleana en tiempo de compilación.\n[Referencia](https://en.cppreference.com/w/cpp/types/conditional)",
            "hint": null,
            "correctAnswer": [
              "Elige un tipo u otro basado en un booleano en tiempo de compilación"
            ],
            "options": [
              "Una declaración condicional",
              "Elige un tipo u otro basado en un booleano en tiempo de compilación",
              "Un operador condicional",
              "Un verificador de condiciones"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "07ab35cce8ab39a38c539514",
            "question": "¿Para qué se usa `std::is_same`?",
            "answer": "Para verificar si dos tipos son iguales en tiempo de compilación",
            "explanation": "**Explicación:**\n`std::is_same` es un trait de tipo que verifica si dos tipos son idénticos en tiempo de compilación.\n[Referencia](https://en.cppreference.com/w/cpp/types/is_same)",
            "hint": null,
            "correctAnswer": ["Para verificar si dos tipos son iguales en tiempo de compilación"],
            "options": [
              "Para verificar si los valores son iguales",
              "Para verificar si dos tipos son iguales en tiempo de compilación",
              "Para comparar objetos",
              "Para verificar igualdad"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f5c4a86e80c83b3137a85772",
            "question": "¿Cuál es la salida de este código?\n```cpp\n#include <iostream>\nint main() {\n    int x = 10;\n    int* p = &x;\n    int** pp = &p;\n    std::cout << **pp;\n    return 0;\n}\n```",
            "answer": "10",
            "explanation": "**Explicación:**\npp es un puntero a puntero. \\*\\*pp desreferencia dos veces para obtener el valor de x, que es 10.\n[Referencia](https://en.cppreference.com/w/cpp/language/pointer)",
            "hint": null,
            "correctAnswer": ["10"],
            "options": ["10", "Dirección de x", "Dirección de p", "Error de compilación"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4d73b1ab603ee917d6c42f1a",
            "question": "¿Para qué se usa `std::remove_if`?",
            "answer": "Para eliminar elementos de un rango que satisfacen un predicado",
            "explanation": "**Explicación:**\n`std::remove_if` elimina elementos de un rango que satisfacen un predicado dado, usado con erase para eliminación real.\n[Referencia](https://en.cppreference.com/w/cpp/algorithm/remove)",
            "hint": null,
            "correctAnswer": ["Para eliminar elementos de un rango que satisfacen un predicado"],
            "options": [
              "Para eliminar declaraciones if",
              "Para eliminar elementos de un rango que satisfacen un predicado",
              "Para eliminar archivos condicionalmente",
              "Para eliminar condiciones"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "15308f613d71a1497b62378e",
            "question": "¿Para qué se usa `std::transform`?",
            "answer": "Para aplicar una función a un rango y almacenar resultados en otro rango",
            "explanation": "**Explicación:**\n`std::transform` aplica una función dada a un rango de elementos y almacena el resultado en otro rango.\n[Referencia](https://en.cppreference.com/w/cpp/algorithm/transform)",
            "hint": null,
            "correctAnswer": [
              "Para aplicar una función a un rango y almacenar resultados en otro rango"
            ],
            "options": [
              "Para transformar código",
              "Para aplicar una función a un rango y almacenar resultados en otro rango",
              "Para transformar tipos",
              "Para realizar transformaciones"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7d472754cf8dc7667d574b5e",
            "question": "¿Para qué se usa `std::accumulate`?",
            "answer": "Para calcular la suma o plegar un rango de elementos",
            "explanation": "**Explicación:**\n`std::accumulate` calcula la suma de un rango de elementos o aplica una operación binaria para plegar el rango.\n[Referencia](https://en.cppreference.com/w/cpp/algorithm/accumulate)",
            "hint": null,
            "correctAnswer": ["Para calcular la suma o plegar un rango de elementos"],
            "options": [
              "Para acumular errores",
              "Para calcular la suma o plegar un rango de elementos",
              "Para acumular datos",
              "Para sumar números"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5698f6f8f58d94def4f284fe",
            "question": "¿Cuál es la salida de este código?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    int y = 10;\n    int z = x > y ? x : y;\n    std::cout << z;\n    return 0;\n}\n```",
            "answer": "10",
            "explanation": "**Explicación:**\nEl operador ternario verifica si x > y. Como es falso, z se asigna y, que es 10.\n[Referencia](https://en.cppreference.com/w/cpp/language/operator_other)",
            "hint": null,
            "correctAnswer": ["10"],
            "options": ["5", "10", "1", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a6e8e85df38d9a464d2f71a8",
            "question": "¿Para qué se usa `std::copy`?",
            "answer": "Para copiar elementos de un rango a otro",
            "explanation": "**Explicación:**\n`std::copy` copia elementos de un rango de origen a un rango de destino.\n[Referencia](https://en.cppreference.com/w/cpp/algorithm/copy)",
            "hint": null,
            "correctAnswer": ["Para copiar elementos de un rango a otro"],
            "options": [
              "Para copiar archivos",
              "Para copiar elementos de un rango a otro",
              "Para duplicar objetos",
              "Para copiar memoria"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "76b53bb7863a84a0c21fc7d1",
            "question": "¿Para qué se usa `std::find`?",
            "answer": "Para encontrar la primera ocurrencia de un valor en un rango",
            "explanation": "**Explicación:**\n`std::find` busca la primera ocurrencia de un valor en un rango y devuelve un iterador a él.\n[Referencia](https://en.cppreference.com/w/cpp/algorithm/find)",
            "hint": null,
            "correctAnswer": ["Para encontrar la primera ocurrencia de un valor en un rango"],
            "options": [
              "Para encontrar archivos",
              "Para encontrar la primera ocurrencia de un valor en un rango",
              "Para buscar patrones",
              "Para localizar objetos"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "204bdacc02d65a0ca961f4f2",
            "question": "¿En qué se basa `std::sort`?",
            "answer": "Introsort (híbrido de quicksort, heapsort y ordenamiento por inserción)",
            "explanation": "**Explicación:**\n`std::sort` típicamente usa introsort, que combina quicksort, heapsort y ordenamiento por inserción para rendimiento óptimo.\n[Referencia](https://en.cppreference.com/w/cpp/algorithm/sort)",
            "hint": null,
            "correctAnswer": [
              "Introsort (híbrido de quicksort, heapsort y ordenamiento por inserción)"
            ],
            "options": [
              "Ordenamiento de burbuja",
              "Introsort (híbrido de quicksort, heapsort y ordenamiento por inserción)",
              "Solo merge sort",
              "Ordenamiento por selección"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "94919ba46efe2c145d19b3b0",
            "question": "¿Cuál es la salida de este código?\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\nint main() {\n    std::vector<int> v = {5, 2, 8, 1, 9};\n    std::sort(v.begin(), v.end());\n    std::cout << v[2];\n    return 0;\n}\n```",
            "answer": "5",
            "explanation": "**Explicación:**\nDespués de ordenar, el vector se convierte en {1, 2, 5, 8, 9}. v[2] es el tercer elemento, que es 5.\n[Referencia](https://en.cppreference.com/w/cpp/algorithm/sort)",
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["8", "2", "5", "1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-es",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          }
        ]
      },
      {
        "id": "72f5aa2d090f4b90bc8be471-fr",
        "language": "fr",
        "title": "C++",
        "description": "Seeded from c++/c++-quiz-fr.md",
        "questions": [
          {
            "id": "57359ab0840a42c07d815f0e",
            "question": "What is the output of this code?\n```cpp\nvector<int> v(22);\nbool b = (v[6]);\nprintf(\"%d\", !b);\n```",
            "answer": "1",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["False", "0", "1", "This code has an error."],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3e8f30ba9603763af90876f3",
            "question": "Which of the following is a reason why using this line is considered a bad practice? (_Alternative_: Why is using this line considered a bad practice?)\n```cpp\nusing namespace std;\n```",
            "answer": "If the code uses a function defined in two different libraries with the same prototype but possibly with different implementations, there will be a compilation error due to ambiguity.",
            "explanation": "[Reference](https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/)",
            "hint": null,
            "correctAnswer": [
              "If the code uses a function defined in two different libraries with the same prototype but possibly with different implementations, there will be a compilation error due to ambiguity."
            ],
            "options": [
              "The compiled code is always bigger because of all of the imported symbols.",
              "If the code uses a function defined in two different libraries with the same prototype but possibly with different implementations, there will be a compilation error due to ambiguity.",
              "It automatically includes all header files in the standard library (cstdint, cstdlib, cstdio, iostream, etc).",
              "It causes the compiler to enforce the exclusive inclusion of header files belonging to the standard library, generating a compilation error when a different header file is included."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d0a23d82b4ccf6c61831dc3f",
            "question": "What is the smallest size a variable of the type child_t may occupy in memory?\n```cpp\ntypedef struct{\n    unsigned int  age    : 4;\n    unsigned char gender : 1;\n    unsigned int  size   : 2;\n}child_t;\n```",
            "answer": "1 byte.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": ["1 byte."],
            "options": ["7 bits.", "25 bytes.", "1 bit.", "1 byte."],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7d65b0c3c9aa2b020b390e73",
            "question": "What are the vectors v1 and v2 after executing the code?\n```cpp\nstd::vector<int> v1{1,2,3},v2;\nv2=v1;\nv1.push_back(4);\nv2.push_back(5);\n```",
            "answer": "v1:{1,2,3,4}; v2:{1,2,3,5};",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["v1:{1,2,3,4}; v2:{1,2,3,5};"],
            "options": [
              "Error",
              "v1:{1,2,3,4}; v2:{5};",
              "v1:{1,2,3,4,5}; v2:{1,2,3,4,5};",
              "v1:{1,2,3,4}; v2:{1,2,3,5};"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6c349a22dac213d9461d0e01",
            "question": "Which of the following is a true statement about the difference between pointers and iterators?",
            "answer": "Incrementing an iterator always means accessing the next element in the container(if any), no matter the container. Incrementing the pointer means pointing to the next element in memory, not always the next element.",
            "explanation": "[Reference](https://stackoverflow.com/a/31128162)",
            "hint": null,
            "correctAnswer": [
              "Incrementing an iterator always means accessing the next element in the container(if any), no matter the container. Incrementing the pointer means pointing to the next element in memory, not always the next element."
            ],
            "options": [
              "While pointers are variables that hold memory addresses, iterators are generic functions used to traverse containers. This function allows the programmer to implement read and write code as the container is traversed.",
              "Incrementing an iterator always means accessing the next element in the container(if any), no matter the container. Incrementing the pointer means pointing to the next element in memory, not always the next element.",
              "Pointers are variables that hold memory address whereas iterator is unsigned integers that refer to offsets in arrays.",
              "All iterators are implemented with pointers so all iterators are pointers but not all pointers are iterators."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6157acf85446ccda5969a32e",
            "question": "What's the storage occupied by u1?\n```cpp\nunion {\n    uint16_t a;\n    uint32_t b;\n    int8_t c;\n} u1;\n```",
            "answer": "4 bytes",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/union)",
            "hint": null,
            "correctAnswer": ["4 bytes"],
            "options": ["4 bytes", "7 bytes", "8 bytes", "2 bytes"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ce8d06497be38b09d7c8d9f1",
            "question": "Which of the following operator can be overloaded?",
            "answer": "`new`",
            "explanation": "[Reference](https://www.tutorialspoint.com/operators-that-cannot-be-overloaded-in-cplusplus)",
            "hint": null,
            "correctAnswer": ["`new`"],
            "options": ["`?:`", "`new`", "`::`", "`.`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "09a25be9f90bdb56a27fd47e",
            "question": "Which of the following shows the contents of the vector pointed by v1 and v2 after running this code?\n```cpp\nstd:: vector<int> *v1 = new std::vector<int>({1,2,3});\nstd:: vector<int> *v2;\nv2=v1;\nv1->push_back(4);\nv2->push_back(5);\n```",
            "answer": "`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`",
            "explanation": "v1 and v2 point to the same vector.",
            "hint": null,
            "correctAnswer": ["`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`"],
            "options": [
              "`*v1:{1,2,3,4}; *v2:{5};`",
              "`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`",
              "Error",
              "`*v1:{1,2,3,4}; *v2:{1,2,3,5};`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "74f1db4878f4af63bb8c50ec",
            "question": "Which of the following is not a difference between a class and a struct?",
            "answer": "Template type parameters can be declared with classes, but not with the struct keyword.",
            "explanation": "Templates can be used with both classes and structs\n[Reference](https://docs.microsoft.com/en-us/cpp/cpp/struct-cpp?view=msvc-170)\n[Reference](https://www.fluentcpp.com/2017/06/13/the-real-difference-between-struct-class/)",
            "hint": null,
            "correctAnswer": [
              "Template type parameters can be declared with classes, but not with the struct keyword."
            ],
            "options": [
              "Because structs are part of the C programming language, there is some complexity between C and C++ structs. This is not the case with classes.",
              "Classes may have member functions; structs are private.",
              "The default access specifier for members of a struct is public, whereas, for members of the class, it is private.",
              "Template type parameters can be declared with classes, but not with the struct keyword."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "de02a926534d454b1714d7dd",
            "question": "Suppose you need to keep a data struct with permission to access some resource based on the days of the week, but you can't use a bool variable for each day. You need to use one bit per day of the week. Which of the following is a correct implementation of a structure with bit fields for this application?",
            "answer": "A",
            "explanation": "```cpp\ntypedef struct {\nint sunday:1;\nint monday:1;\n// more days\nint friday:1;\nint saturday:1;\n} weekdays;\n```\n```cpp\ntypedef char[7]: weekdays;\n```\n```cpp\ntypedef struct {\nbit sunday:1;\nbit monday:1;\n// more days\nbit friday:1;\nbit saturday:1;\n} weekdays;\n```\n```cpp\ntypedef struct {\nbit sunday;\nbit monday;\n// more days\nbit friday;\nbit saturday;\n} weekdays;\n```\n[Reference](https://en.cppreference.com/w/cpp/language/bit_field) _NOTE_: Correct syntax is that each variable size is 1 bit. `bit` is not a type in C++.",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4c707a182e1fb2d69d8eaecc",
            "question": "What is an lvalue?",
            "answer": "It's a location value, meaning a memory address suitable for assigning to a pointer or reference.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "It's a location value, meaning a memory address suitable for assigning to a pointer or reference."
            ],
            "options": [
              "It's a constant expression, meaning an expression composed of constants and operations.",
              "It's an expression that represents an object with an address.",
              "It's an expression suitable for the left-hand side operand in a binary operation.",
              "It's a location value, meaning a memory address suitable for assigning to a pointer or reference."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b2831fb05965a9f2c26feafc",
            "question": "What does auto type specifier do in this line of code (since C++11)?\n```cpp\nauto x = 4000.22;\n```",
            "answer": "It specifies that the type of x will be deduced from the initializer - in this case, double.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "It specifies that the type of x will be deduced from the initializer - in this case, double."
            ],
            "options": [
              "It specifies that the type of x will be deduced from the initializer - in this case, double.",
              "It specifies that the type of x is automatic meaning that it can be assigned different types of data throughout the program.",
              "It specifies that x is a variable with automatic storage duration.",
              "It specifies that more memory will be allocated for x in case it needs more space, avoiding loss of data due to overflow."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8573540800522b76862f7b2b",
            "question": "A class template is a \\_?",
            "answer": "class written with the generic programming paradigm, specifying behavior in terms of type parameter rather than specific type.",
            "explanation": "[Reference](https://www.mygreatlearning.com/blog/templates-in-cpp/)",
            "hint": null,
            "correctAnswer": [
              "class written with the generic programming paradigm, specifying behavior in terms of type parameter rather than specific type."
            ],
            "options": [
              "class written with the generic programming paradigm, specifying behavior in terms of type parameter rather than specific type.",
              "blank superclass intended for inheritance and polymorphism.",
              "class that only consists of a member variable, with no constructor, destructor, or member functions.",
              "skeleton source code for a class where the programmer has to fill in specific parts to define the data types and algorithms used."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "280b6dc5f751005037d0cb18",
            "question": "What is the ternary operator equivalent to this code snippet?\n```cpp\nif(x)\n    y=a;\nelse\n    y=b;\n```",
            "answer": "`y=x?a:b;`",
            "explanation": "[Reference](https://www.w3schools.com/cpp/cpp_conditions_shorthand.asp)",
            "hint": null,
            "correctAnswer": ["`y=x?a:b;`"],
            "options": ["`y=a?b:x;`", "`y=if(x?a:b);`", "`y=(x&a)?a:(x&b)?b:0;`", "`y=x?a:b;`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "813878b1639cc41a32ee7a09",
            "question": "What is the output of the code given below?\n```cpp\n#include <iostream>\nint main(){\n    int x=10, y=20;\n    std::cout << \"x = \" << x++ << \" and y = \" << --y << std::endl;\n    std::cout << \"x = \" << x-- << \" and y = \" << ++y << std::endl;\n    return(0);\n}\n```",
            "answer": "`x = 10 and y = 19`",
            "explanation": "`x = 11 and y = 19`\n`x = 10 and y = 20`\n`x = 11 and y = 20`\n`x = 10 and y = 19`",
            "hint": null,
            "correctAnswer": ["`x = 10 and y = 19`"],
            "options": [
              "`x = 10 and y = 20`",
              "`x = 11 and y = 19`",
              "`x = 10 and y = 19`",
              "`x = 11 and y = 20`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c6580282381a1d975be9bbda",
            "question": "What is the meaning of the two parts specified between parentheses in a range-based for loop, separated by a colon?",
            "answer": "The first is a variable declaration that will hold an element in a sequence. The second is the sequence to traverse.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "The first is a variable declaration that will hold an element in a sequence. The second is the sequence to traverse."
            ],
            "options": [
              "The first is a variable declaration that will hold an element in a sequence. The second is the sequence to traverse.",
              "The first is an iterator, and the second is the increment value to be added to the iterator.",
              "The first is the iterating variable. The second is a `std::pair` that specifies the range (start and end) in which the variable will iterate.",
              "The first is a container object. The second is a `std::pair` that specifies the range (start and end) in which the elements will be accessed within the loop."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "277847213c740400c3769e4f",
            "question": "What is the output of the code given below?\n```cpp\nint8_t a=200;\nuint8_t b=100;\nif(a>b)\n    std::cout<<\"greater\";\nelse\n    std::cout<<\"less\";\n```",
            "answer": "less",
            "explanation": "Note: a variant of the question below.",
            "hint": null,
            "correctAnswer": ["less"],
            "options": [
              "There is no output because there is an exception when comparing an int8_t with a uint8_t.",
              "greater",
              "less",
              "There is no output because there is a compiler error."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f2ef03098c0583e77a2f039d",
            "question": "What is the output of this block of code?\n```cpp\nint8_t a=200;\nuint8_t b=100;\nstd::cout<<\"a=\"<<(int)a;\nstd::cout<<\", b=\"<<(int)b;\n```",
            "answer": "a=-56, b=100",
            "explanation": "Note: Implicit conversion from 'int' to 'int8_t' (aka 'signed char') changes value from 200 to -56",
            "hint": null,
            "correctAnswer": ["a=-56, b=100"],
            "options": ["a=-56, b=100", "a=-55, b=100", "a=200, b=-156", "a=200, b=100"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3f52105716d57c3234985bff",
            "question": "What is the output after executing this code snippet?\n```cpp\nint x=5, y=2;\nif(x & y) {\n    /*_part A_*/\n}\nelse {\n    /*_part B_*/\n}\n```",
            "answer": "Part B executes because (x & y) results in 0, or false.",
            "explanation": "[Reference](https://stackoverflow.com/questions/63867765/dont-understand-why-if-5-2-is-false)",
            "hint": null,
            "correctAnswer": ["Part B executes because (x & y) results in 0, or false."],
            "options": [
              "Part A executes because x==5 (true) and y==2 (true), thus the AND operation evaluates as true.",
              "Part B executes because (x & y) results in 0, or false.",
              "Part A executes because (x & y) results in a nonzero value, or true.",
              "Part B executes because the statement (x & y) is invalid, thus false."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1ac15e06e9f00672be691174",
            "question": "What is a valid definition for the `get_length` function, which returns the length of a null-terminated string?",
            "answer": "A",
            "explanation": "```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str[count++]);\nreturn count-1;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str!=NULL){\ncount++;\nstr++;\n}\nreturn count;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile((*str)++)\ncount++;\nreturn count;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str++)\ncount++;\nreturn count;\n}\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "522105f92ede7813fa7abdd8",
            "question": "Which STL class is the best fit for implementing a collection of data that is always ordered so that the pop operation always gets the greatest of the elements? Suppose you are interested only in push and pop operations.",
            "answer": "`std::priority_queue`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`std::priority_queue`"],
            "options": ["`std::list`", "`std::vector`", "`std::priority_queue`", "`std::map`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "dbb63894a067a7bceab19d46",
            "question": "What is the meaning of the three sections specified between parentheses in a for loop separated by semicolons?",
            "answer": "The first is the initialization block, the second is the condition to iterate, and the third is the increment block.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "The first is the initialization block, the second is the condition to iterate, and the third is the increment block."
            ],
            "options": [
              "The first is the iterating variable name, the second is the number of times to iterate, and the third is the desired increment or decrement (specified with a signed integer).",
              "The first is the initialization block, the second is the condition to iterate, and the third is the increment block.",
              "The first is the iterating variable, the second is the container in which it should operate, and the third is an exit condition to abort at any time.",
              "The first is the iterating variable name, the second is the starting value for the iterating variable, and the third is the stop value (the last value plus one)."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c2ca17fe963f171f8773a124",
            "question": "What does this code print?\n```cpp\nint i = 0;\nprintf(\"%d\", i++);\nprintf(\"%d\", i--);\nprintf(\"%d\", ++i);\nprintf(\"%d\", --i);\n```",
            "answer": "0,1,1,0",
            "explanation": "[Reference](https://www.geeksforgeeks.org/pre-increment-and-post-increment-in-c/)",
            "hint": null,
            "correctAnswer": ["0,1,1,0"],
            "options": ["0,1,1,0", "0,1,0,1", "0,0,1,0", "1,0,1,0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "090c6dad93c557fd2fc368c0",
            "question": "What is true about the variable named `ptr`?\n```cpp\nvoid *ptr;\n```",
            "answer": "It is a pointer to a value with no specific type, so it may be cast to point to any type.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/pointer)",
            "hint": null,
            "correctAnswer": [
              "It is a pointer to a value with no specific type, so it may be cast to point to any type."
            ],
            "options": [
              "It is a pointer initialized at NULL.",
              "It is a pointer to a void function.",
              "That declaration causes a compiler error, as pointers must specify a type.",
              "It is a pointer to a value with no specific type, so it may be cast to point to any type."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ee6e064aabad8eb7400973fd",
            "question": "What is the output of the code given below?\n```cpp\nint c=3; char d='A';\nstd::printf(\"c is %d and d is %c\",c,d);\n```",
            "answer": "c is 3 and d is A",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["c is 3 and d is A"],
            "options": [
              "c is d and d is c",
              "c is A and d is 3",
              "c is 3 and d is A",
              "c is c and d is d"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b01d3b9e5bc3a0f3b4bf8c6d",
            "question": "What is the output of this code?\n```cpp\nprintf(\"1/2 = %f\",(float)(1/2));\n```",
            "answer": "1/2 = 0.000000",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["1/2 = 0.000000"],
            "options": ["1/2 = 0.499999", "1/2 = 0", "1/2 = 0.000000", "1/2 = 0.5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7e4499c667886a9e4a46df66",
            "question": "What is the difference between a public and a private class member?",
            "answer": "Public members can be accessed by any function. Private members can be accessed only by the same class's member functions and the friends of the class.",
            "explanation": "[Reference](https://www.geeksforgeeks.org/difference-between-public-and-private-in-c-with-example/)",
            "hint": null,
            "correctAnswer": [
              "Public members can be accessed by any function. Private members can be accessed only by the same class's member functions and the friends of the class."
            ],
            "options": [
              "Public members are the same as global variables, so every part of the code has access to them. Private members are the same as automatic variables, so only their class has access to them.",
              "Public members are made accessible to any running application. Private members are made accessible only to the application where the object is instantiated.",
              "Public members will be compiled as shared variables in a multithreaded environment. Private members will be compiled as Thread-local variables.",
              "Public members can be accessed by any function. Private members can be accessed only by the same class's member functions and the friends of the class."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "022eb92f8410c9e3c6324b8c",
            "question": "What is the value of `x` after executing this code?\n```cpp\nint x=10, a=-3;\nx+=a;\n```",
            "answer": "7",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["7"],
            "options": ["3", "7", "-3", "13"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f43c5ffce213982bf5a5d7c1",
            "question": "Which statement is true?",
            "answer": "C++ supports multiple inheritance.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C++ supports multiple inheritance."],
            "options": [
              "Only classes can have member variables and methods.",
              "C++ supports multiple inheritance.",
              "C++ supports only single inheritance.",
              "Only structs can inherit."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e5646ff58a474934a90fe388",
            "question": "Consider a pointer to void, named `ptr`, which has been set to point to a floating point variable `g`. Which choice is a valid way to dereference `ptr` to assign its pointed value to a float variable `f` later in the program?\n```cpp\nfloat g;\nvoid *ptr=&g;\n```",
            "answer": "`float f=*(float *)ptr;`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`float f=*(float *)ptr;`"],
            "options": [
              "`float f=*(float)ptr;`",
              "`float f=(float *)ptr;`",
              "`float f=(float)*ptr;`",
              "`float f=*(float *)ptr;`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9c8510a02838c7da1fb6a7de",
            "question": "What is the `.*` operator and what does it do?",
            "answer": "It is the pointer to the member operator, and it allows you to access a member of an object through a pointer to that specific class member.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/operator_member_access)",
            "hint": null,
            "correctAnswer": [
              "It is the pointer to the member operator, and it allows you to access a member of an object through a pointer to that specific class member."
            ],
            "options": [
              "It is the same as the class member access operator, or arrow operator `(->)`, which allows you to access a member of an object through a pointer to the object.",
              "It is the pointer to the member operator, and it allows you to access a member of an object through a pointer to that specific class member.",
              "It is the member access with an address of the operator, which returns the address of a class or struct member.",
              "It is a combination of the member access operator `(.)` and the dereference operator `(*)`, so it allows you to access the object that a member pointer points to."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7045444d2d2edf6b6c598d84",
            "question": "For these declarations, which choice shows four equivalent ways to assign the character \"y\" in the string to a char variable c?\n```cpp\nchar buff[50] = \"strings as arrays of characters are fun!\"\nchar *str = buff+11;\nchar c;\n```",
            "answer": "C",
            "explanation": "```cpp\nc = buff[16];\nc = str[5];\nc = *(buff+16);\nc = *(str+5);\n```\n```cpp\nc = *(buff[15]);\nc = *(str[4]);\nc = buff+15;\nc = str+4;\n```\n```cpp\nc = buff[15];\nc = str[4];\nc = *(buff+15);\nc = *(str+4);\n```\n```cpp\nc = *(buff[16]);\nc = *(str[5]);\nc = buff+16;\nc = str+5;\n```",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d4031aab9d3ac1b5223ac9d8",
            "question": "Which choice is the correct declaration for the class named Dog, derived from the Animal class?\n```cpp\nclass Animal{\n    //....\n}\n```",
            "answer": "B",
            "explanation": "```cpp\nclass Dog :: public Animal {\n//....\n};\n```\n```cpp\nclass Dog : public Animal {\n//....\n};\n```\n```cpp\npublic class Animal :: Dog {\n//....\n};\n```\n```cpp\npublic class Dog extends Animal {\n//....\n};\n```",
            "hint": null,
            "correctAnswer": ["B"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a53dfa3277e905e232c3e81b",
            "question": "What is the output of this code given below?\n```cpp\n#include <cstdio>\nusing namespace std;\nint main(){\n    char c = 255;\n    if(c>10)\n        printf(\"c = %i, which is greater than 10\", c);\n    else\n        printf(\"c = %i, which is less than 10\", c);\n    return 0;\n}\n```",
            "answer": "c = -1, which is less than 10",
            "explanation": "Technically, whether a `char` is `signed` or `unsigned` is implementation-defined;\nin the latter case, the second answer would be correct.\n[Reference](https://en.cppreference.com/w/cpp/language/types)",
            "hint": null,
            "correctAnswer": ["c = -1, which is less than 10"],
            "options": [
              "c = -1, which is less than 10",
              "c = 255, which is greater than 10",
              "c = -1, which is greater than 10",
              "c = 255, which is less than 10"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f6613efe9af8c39b7af60c7f",
            "question": "How can C++ code call a C function?",
            "answer": "by using extern \"C\"",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["by using extern \"C\""],
            "options": [
              "by simply calling the C code",
              "There is no way for C++ to call a C function",
              "by using extern \"C\"",
              "by importing the source C code"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1018980c001f16eff63bf4a4",
            "question": "Which choice is _not_ a valid type definition of a structure that contains x and y coordinates as integers, and that can be used exactly as shown for the variable named `center`?\n```cpp\ncoord center;\ncenter.x = 5;\ncenter.y = 3;\n```",
            "answer": "A",
            "explanation": "```cpp\ntypedef struct coord {\nint x;\nint y;\n};\n```\n```cpp\ntypedef struct coord {\nint x;\nint y;\n} coord;\n```\n```cpp\ntypedef struct {\nint x;\nint y;\n} coord;\n```\n```cpp\nstruct coord {\nint x;\nint y;\n};\ntypedef struct coord coord;\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "88687038bf5b9da4efa80e0a",
            "question": "Which choice does _not_ produce the same output as this code snippet? Assume the variable `i` will not be used anywhere else in the code.\n```cpp\nfor (i=1;i<10;i++){\n    cout<<i<<endl;\n}\n```",
            "answer": "A",
            "explanation": "```cpp\ni=1;\nwhile(i<10){\ncout<<++i<<endl;\n}\n```\n```cpp\nfor (int i:{1,2,3,4,5,6,7,8,9}) {\ncout<<i<<endl;\n}\n```\n```cpp\ni = 1;\ndo {\ncout<<i++<<endl;\n} while(i<10);\n```\n```cpp\ni = 1;\nloop:\ncout<<i++<<endl;\nif(i<10) goto loop;\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "95c21d0ed4f052c69f609a33",
            "question": "What does this part of a main.cpp file do?\n```cpp\n#include \"library.h\"\n```",
            "answer": "It causes the replacement of the `#include` directive by the entire contents of the source file library.h. This is similar to the Copy-Paste operation of library.h into main.cpp.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "It causes the replacement of the `#include` directive by the entire contents of the source file library.h. This is similar to the Copy-Paste operation of library.h into main.cpp."
            ],
            "options": [
              "It causes the toolchain to compile all the contents of library.h so that its executable code is available when needed by the final application.",
              "It cherry-picks library.h for the declarations and definitions of all data and functions used in the remainder of the source file main.cpp, finally replacing the `#include` directive with those declarations and definitions.",
              "It informs the linker that some functions or data used in the source file main.cpp are contained in library.h, so that they can be called in run time. This is also known as dynamic linking.",
              "It causes the replacement of the `#include` directive by the entire contents of the source file library.h. This is similar to the Copy-Paste operation of library.h into main.cpp."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2b793abfc991cc9c4946dcc8",
            "question": "Consider this function declaration of `is_even`, which takes in an integer and returns true if the argument is an even number and false otherwise. Which declarations are correct for overloaded versions of that function to support floating point numbers and string representations of numbers?\n```cpp\nbool is_even(int);\n```",
            "answer": "A",
            "explanation": "```cpp\nbool is_even(float f);\nbool is_even(char *str);\n```\n```cpp\nbool is_even(float f);\nbool is_even(char str);\n```\n```cpp\nbool is_even_float(float f);\nbool is_even_str(char *str);\n```\n```cpp\nfloat is_even(float f);\nchar *is_even(char *str);\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c29e57e1898d551229868553",
            "question": "Which choice is an include guard for the header file `my_library.h`?",
            "answer": "B",
            "explanation": "```cpp\n#ifdef MY_LIBRARY_H\n#define MY_LIBRARY_H\n// my_library.h content\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#ifndef MY_LIBRARY_H\n#define MY_LIBRARY_H\n// my_library.h content\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#ifdef MY_LIBRARY_H\n#undef MY_LIBRARY_H\n// my_library.h content\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#define MY_LIBRARY_H\n#include MY_LIBRARY_H\n// my_library.h content\n#undef MY_LIBRARY_H\n```",
            "hint": null,
            "correctAnswer": ["B"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "53a37f9e4d4519434c0bbaa0",
            "question": "What's wrong with this definition when using a pre-C++11 compiler?\n```cpp\nstd::vector<std::vector<int>> thematrix;\n```",
            "answer": "`>>` is parsed as the shift-right operator, and thus results in a compile error.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "`>>` is parsed as the shift-right operator, and thus results in a compile error."
            ],
            "options": [
              "There's nothing wrong with it.",
              "An `std::vector` cannot contain more `std::vector` containers as its elements.",
              "The correct syntax should be: `std::vector[std::vector[int]] thematrix;`",
              "`>>` is parsed as the shift-right operator, and thus results in a compile error."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "eb91ca582d3f99e04dbd5838",
            "question": "What is the statement below equivalent to?",
            "answer": null,
            "explanation": null,
            "hint": null,
            "correctAnswer": [],
            "options": [],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d484c55863f6a088652ed0a2",
            "question": "b. What is the statement equivalent to?\n```cpp\nsprite->x\n```",
            "answer": "`(*sprite).x`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`(*sprite).x`"],
            "options": ["`sprite.x`", "`sprite.*x`", "`(*sprite).x`", "`*sprite.x`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ee3bcc6140d3a49f769b825c",
            "question": "Consider a class named `complexNumber`. Which code will result in an equivalent object?\n```cpp\ncomplexNumber(float real, float im)\n: real_part(real),\n im_part(im){}\n```",
            "answer": "C",
            "explanation": "```cpp\ncomplexNumber(float real, float im) {\nthis->real = real_part;\nthis->im = im_part;\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part(real);\nthis->im_part(im);\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part = real;\nthis->im_part = im;\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part = &real;\nthis->im_part = &im;\n}\n```",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a81cb16f75ddd2402f3fafa2",
            "question": "What is the result of executing this code snippet?\n```cpp\nbool x=true, y=false;\nif (~x || y) {\n    /*part A*/\n} else {\n    /*part B*/\n}\n```",
            "answer": "Part A executes because `~x` is not zero, meaning true.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Part A executes because `~x` is not zero, meaning true."],
            "options": [
              "Part A executes because the expression `(~x || y)` always results in true if `y==false`.",
              "Part B executes because the statement `(~x || y)` is invalid, thus false.",
              "Part A executes because `~x` is not zero, meaning true.",
              "Part B executes because `~x` is false and `y` is false, thus the `OR` operation evaluates as false."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6051542d9696b22f485aca62",
            "question": "What would be the output of this code?\n```cpp\nint32_t nums[3]={2,4,3};\nstd::cout << ( nums[0] << nums[1] << nums[2] );\n```",
            "answer": "256",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["256"],
            "options": [
              "The output is the addresses of `nums[0]`, `nums[1]`, and `nums[2]`, in that order, with no spaces.",
              "256",
              "`0`",
              "`243`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ed7c7407b771e4a7487608c6",
            "question": "What is the output of this code?\n```cpp\nfloat values[5]={0.54f, 2.71828f, 3.14159f, 5.499999f, 10.0f};\nfor(auto f:values)\n    printf(\"%i \",(int)(f+0.5f));\n```",
            "answer": "`1 3 3 5 10`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`1 3 3 5 10`"],
            "options": [
              "`0.54 2.71828 3.14159 5.499999 10.0`",
              "`1 3 4 6 11`",
              "`0 2 3 5 10`",
              "`1 3 3 5 10`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5dd087e3a00d2025dc52c1d3",
            "question": "Which of the following STL classes is the best fit for implementing a phonebook? Suppose each entry contains a name and a phone number, with no duplicates, and you want to have a lookup by name.",
            "answer": "`std::map`",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/container/map)",
            "hint": null,
            "correctAnswer": ["`std::map`"],
            "options": ["`std::priority_queue`", "`std::list`", "`std::vector`", "`std::map`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3b655f0a713931a9bdcca12a",
            "question": "What does this program do?\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\nint main(){\n    ifstream file1(\"text1.txt\", ios::binary);\n    ofstream file2(\"text2.txt\", ios::binary);\n    file2 << file1.rdbuf();\n}\n```",
            "answer": "It copies the contents of text1.txt into text2.txt - i.e., it makes a copy of text1.txt, named text2.txt.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/header/fstream)",
            "hint": null,
            "correctAnswer": [
              "It copies the contents of text1.txt into text2.txt - i.e., it makes a copy of text1.txt, named text2.txt."
            ],
            "options": [
              "It renames text1.txt to text2.txt.",
              "It makes a directory called text2.txt and moves text1.txt there.",
              "It copies the contents of text1.txt into text2.txt - i.e., it makes a copy of text1.txt, named text2.txt.",
              "It appends the contents of text1.txt into text2.txt - i.e., replaces the contents of text2.txt by the concatenation of text2.txt and text1.txt."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2a900fd3651de4336bb9cdf9",
            "question": "Which of the following is _not_ a consequence of declaring the member variable `count` of my_class as static? / Alt.: Which statement is true when declaring the member variable `count` as static?\n```cpp\nclass my_class {\n    public: static int count;\n}\n```",
            "answer": "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/static)",
            "hint": null,
            "correctAnswer": [
              "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it."
            ],
            "options": [
              "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it.",
              "The variable exists even when no objects of the class have been defined so it can be modified at any point in the source code.",
              "The variable is allocated only once, regardless of how many objects are instantiated because it is bound to the class itself, not its instances.",
              "All objects that try to access their count member variable actually refer to the only class-bound static count variable."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e6213b1309ed3217b6e2c541",
            "question": "What is the assumed type of a constant represented in the source code as `0.44`?",
            "answer": "double",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["double"],
            "options": ["double", "long float", "long double", "float"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "04a634fe1878af4a3a031aa8",
            "question": "What is an appropriate way of removing `my_object` as shown below?\n```cpp\nmy_class *my_object = new my_class();\n```",
            "answer": "`delete(my_object);`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`delete(my_object);`"],
            "options": [
              "`delete(my_object);`",
              "`free(my_object);`",
              "The garbage collector will destroy the object eventually.",
              "Exiting the scope will destroy the object."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c7d793fd35829d62a6cd9b78",
            "question": "What is the correct way to call the `count` member function for the object pointer called `grades`?\n```cpp\nclass my_array{\n    public:\n        int count();\n};  // ... more members above\nint main(){\n    my_array *grades = new my_array();\n};  // ... more code above\n```",
            "answer": "`grades->count();`",
            "explanation": "[Reference](https://en.cppreference.com/w/c/language/operator_member_access)",
            "hint": null,
            "correctAnswer": ["`grades->count();`"],
            "options": [
              "`grades.count();`",
              "`my_array->count();`",
              "`grades->count();`",
              "`my_array.count();`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "49e2287434eb8bcf7cb4cc12",
            "question": "What would be the output of this code?\n```cpp\nint i0=4, i1=6, i2=8;\nint& nums[3]={i2,i0,i1};\nstd::cout<<nums[0]<<nums[1]<<nums[2];\n```",
            "answer": "There is no output. The code causes a compiler error because `nums` is an array of references, which is illegal.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/array)",
            "hint": null,
            "correctAnswer": [
              "There is no output. The code causes a compiler error because `nums` is an array of references, which is illegal."
            ],
            "options": [
              "There is no output. The code causes a compiler error because `nums` is an array of references, which is illegal.",
              "846",
              "The output is the addresses of `i2`, `i0`, and `i1`, in that order, with no spaces.",
              "468"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bf7ca29125f7c7fa6f543dd7",
            "question": "Does this code cause a compiler error? If so, why, and if not, what is `child_t`?\n```cpp\ntypedef struct{\n    unsigned int  age    : 4;\n    unsigned char gender : 1;\n    char                 : 0;\n    unsigned int  size   : 2;\n}child_t;\n```",
            "answer": "No, and `child_t` is a type defined as a structure with bit fields. It has 4 bits for age and 1 bit for gender in the first byte, and 2 bits for size in the second byte.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": [
              "No, and `child_t` is a type defined as a structure with bit fields. It has 4 bits for age and 1 bit for gender in the first byte, and 2 bits for size in the second byte."
            ],
            "options": [
              "Yes, it causes a compiler error because the colon character is not allowed in struct definitions.",
              "No, and `child_t` is a type defined as a structure with bit fields. It has 4 bits for age and 1 bit for gender in the first byte, and 2 bits for size in the second byte.",
              "Yes, it causes a compiler error because there is an unnamed field.",
              "Yes, it causes a compiler error because one field is defined as having a size of 0."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "16e735b173b70729606de4ae",
            "question": "What is this expression equivalent to?\n```cpp\nA->B\n```",
            "answer": "`(*A).B`",
            "explanation": "Note: a simpler variant of the question below.",
            "hint": null,
            "correctAnswer": ["`(*A).B`"],
            "options": ["`*(A.B)`", "`B=A`", "`(*A).B`", "`&A.B`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cb7cbe26b84f604159f205e2",
            "question": "What is this expression equivalent to?\n```cpp\nA->B->C->D\n```",
            "answer": "`*(*((*A).B).C).D`",
            "explanation": "**Note:** a more complex variant of the question above.",
            "hint": null,
            "correctAnswer": ["`*(*((*A).B).C).D`"],
            "options": ["`A.B.C.D`", "`*A.*B.*C.*D`", "`&A.&B.&C.&D`", "`*(*((*A).B).C).D`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1f12957119413ac672e72148",
            "question": "What does this function do?\n```cpp\nauto buff = new char[50];\nstd::memset(buff,20,50);\n```",
            "answer": "It writes the value 20 in every memory address from buff to buff+49.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/string/byte/memset)",
            "hint": null,
            "correctAnswer": [
              "It writes the value 20 in every memory address from buff to buff+49."
            ],
            "options": [
              "It declares a memory buffer named buff that starts at address 20 and ends at address 70.",
              "It sets all bits in the array named buffer from its element at index 20 to its element at index 50.",
              "It writes the value 20 in every memory address from buff to buff+49.",
              "It declares a memory buffer named buff that starts at address 20 and ends at address 50."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "359e7183faa2b4e01c058c1c",
            "question": "Consider a class named `CustomData`. Which choice is a correct declaration syntax to overload the postfix `++` operator as a class member?",
            "answer": "`CustomData operator++(int);`",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/operators)",
            "hint": null,
            "correctAnswer": ["`CustomData operator++(int);`"],
            "options": [
              "`CustomData& operator++();`",
              "`void operator++(CustomData);`",
              "`CustomData operator++(CustomData);`",
              "`CustomData operator++(int);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "256f226a71a9adaab4bb0f9d",
            "question": "You want to sort my_array, declared below. Which choice is the correct call to std::sort, using a lambda expression as the comparison function?\n```cpp\nstd::array<uint32_t, 50> my_array;\n```",
            "answer": "A",
            "explanation": "```cpp\nstd::sort(my_array.begin(), my_array.end(),\n[](uint32_t a, uint32_t b) {\nreturn a < b;\n})\n```\n```cpp\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n}\nstd::sort(my_array.begin(), my_array.end(), lambda);\n```\n```cpp\nstd::sort(my_array.begin(), my_array.end(),\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n})\n```\n```cpp\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n}\nstd::sort(my_array.begin(), my_array.end(), &lambda);\n```\n[Reference](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160)",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "90f97d2efdf96c448dc96b6d",
            "question": "Which choice is the most reasonable implementation of the function std::mutex::lock() by using std::mutex::try_lock()?",
            "answer": "A",
            "explanation": "```cpp\nvoid std::mutex::lock(){\nwhile(!this->try_lock());\n}\n```\n```cpp\nvoid std::mutex::lock(){\nreturn (this->try_lock());\n}\n```\n```cpp\nvoid std::mutex::lock(){\nwhile(1)\nthis->try_lock();\n}\n```\n```cpp\nvoid std::mutex::lock(){\nwhile(this->try_lock());\n}\n```\nNote: variant of the question below.",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "94db5d44bf71381238f2e7eb",
            "question": "What is the main difference between these two Functions?\n```cpp\nstd::mutex::lock()\nstd::mutex::try_lock()\n```",
            "answer": "Both attempt to acquire a lock, but `lock()` blocks if the mutex is not available, whereas `try_lock()` returns whether the mutex is available or not.",
            "explanation": "Note: variant of the question above.\n[Reference](https://en.cppreference.com/w/cpp/thread/mutex/try_lock)",
            "hint": null,
            "correctAnswer": [
              "Both attempt to acquire a lock, but `lock()` blocks if the mutex is not available, whereas `try_lock()` returns whether the mutex is available or not."
            ],
            "options": [
              "`lock()` has a higher privilege over `try_lock()`. This means that you have a better chance of acquiring a mutex `with lock()`.",
              "Both attempt to acquire a lock, but `lock()` blocks if the mutex is not available, whereas `try_lock()` returns whether the mutex is available or not.",
              "`lock()` enforces preemption, whereas `try_lock()` suggests preemption.",
              "If the mutex is not available, `try_lock()` returns with a corresponding code, whereas `lock()` snatches the mutex from the thread that currently has it."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "852f4e0b75f6d9c51dd3bc77",
            "question": "What is the purpose of a destructor?",
            "answer": "It allows the programmer to write the necessary code to free the resources acquired by the object prior to deleting the object itself.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "It allows the programmer to write the necessary code to free the resources acquired by the object prior to deleting the object itself."
            ],
            "options": [
              "It allows the programmer to write the necessary code to free the resources acquired by the object prior to deleting the object itself.",
              "It deletes an object. One example of a destructor is the `delete()` function.",
              "It terminates a program. This may be achieved as a regular function call or as an exception.",
              "There are no destructors in C++."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "66c9b437489e6f7b194c6752",
            "question": "What is one benefit of declaring the parameter as a `const` reference instead of declaring it as a regular object?\n```cpp\nint calculateMedian(const my_array& a)\n```",
            "answer": "The `const` qualifier forbids the code to modify the argument, so the programmer can rest assured that the source object will remain unchanged. / Alt.: The argument is passed as a reference, so if the passed my_array object is large, the program will require less time and memory.",
            "explanation": "[Reference](https://stackoverflow.com/a/2627179/10773894)",
            "hint": null,
            "correctAnswer": [
              "The `const` qualifier forbids the code to modify the argument, so the programmer can rest assured that the source object will remain unchanged. / Alt.: The argument is passed as a reference, so if the passed my_array object is large, the program will require less time and memory."
            ],
            "options": [
              "Actually, objects cannot be passed as regular variables, because they require a constructor call. Therefore, a `const` reference is the only way to pass class instances to functions.",
              "There are no benefits because a reference and an object are treated as the same thing.",
              "The `const` qualifier forbids the code to modify the argument, so the programmer can rest assured that the source object will remain unchanged. / Alt.: The argument is passed as a reference, so if the passed my_array object is large, the program will require less time and memory.",
              "The argument is passed as a reference, so the function receives a copy that can be modified without affecting the original variable."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4a11a8a861c75ae5a0b32a11",
            "question": "What is an include guard?",
            "answer": "a preprocessor statement that prevents a source file from being included more than once in a project",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "a preprocessor statement that prevents a source file from being included more than once in a project"
            ],
            "options": [
              "a preprocessor directive that prevents inconsistent behaviors in lines that contain the #ifdef, #ifndef, or #elif directives",
              "a compiler option that prevents the user code from including additional libraries",
              "a preprocessor statement that prevents a source file from being included more than once in a project",
              "a library that adds safety features such as mutexes, watchdog timers, and assertions to the project"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "43052458c27f46b72e26759d",
            "question": "What would be the correct declaration of a default constructor for a class named Sprite?",
            "answer": "A",
            "explanation": "```cpp\npublic: Sprite();\n```\n```cpp\nprivate: void Sprite();\n```\n```cpp\npublic: void Sprite();\n```\n```cpp\nprivate: Sprite();\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "184a4f8ba58473a0866205cb",
            "question": "What is the purpose of this line in a header file?\n```cpp\n#pragma once\n```",
            "answer": "to make the compiler parse that header file only once, even if it is included multiple times in the source",
            "explanation": "[reference here](https://en.cppreference.com/w/cpp/preprocessor/impl)",
            "hint": null,
            "correctAnswer": [
              "to make the compiler parse that header file only once, even if it is included multiple times in the source"
            ],
            "options": [
              "to restrict the use of its contents to only one source file",
              "to tell the compiler that only one variable can be instantiated from the classes or types contained in this header file",
              "to help the compiler finish faster by assuring that only one compiler pass is necessary for the code included in this header file",
              "to make the compiler parse that header file only once, even if it is included multiple times in the source"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b64bf85ecc95b023a14d0e1e",
            "question": "What is a variable of type double?",
            "answer": "a floating point number",
            "explanation": "[Reference](https://www.educba.com/c-plus-plus-double/)",
            "hint": null,
            "correctAnswer": ["a floating point number"],
            "options": [
              "a 2-tuple",
              "an integer number",
              "a floating point number",
              "a string with more than 255 characters"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1c626ac83b42e745c864423c",
            "question": "Other than shifting bits to the left, what is the << operator used for?",
            "answer": "inserting characters into an output stream like std::cout.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["inserting characters into an output stream like std::cout."],
            "options": [
              "shifting characters to the left in a string.",
              "inserting characters into an output stream like std::cout.",
              "comparing floating point numbers as less-than.",
              "assigning a variable to a reference."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "aee4da0419c8faad59547cb2",
            "question": "Which choice is a reason to specify the type of a pointer instead of using `void *`, which works as a pointer to any type?",
            "answer": "The compiler needs the data type to know how much memory to allocate for the pointer because different data types require different pointer lengths.",
            "explanation": "[Reference](https://stackoverflow.com/questions/9802585/why-is-the-data-type-needed-in-pointer-declarations)",
            "hint": null,
            "correctAnswer": [
              "The compiler needs the data type to know how much memory to allocate for the pointer because different data types require different pointer lengths."
            ],
            "options": [
              "The compiler needs the data type to make sure that the pointer is not going to be used on illegal non-pointable types such as functions, labels, pointers, and references.",
              "`void *` does not work for any type. The language does not allow assigning anything other than `void` to a pointer to `void *`.",
              "The compiler needs the data type to know how much memory to allocate for the pointer because different data types require different pointer lengths.",
              "Yes, it causes a compiler error because one field is defined as having a size of 0."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "25c34acee8b521f1a578af89",
            "question": "What is wrong with this piece of code?\n```cpp\n#include <iostream>\nchar str[20];\nint main(){\n    std::cout << \"What's your name? \";\n    str << std::cin\n    std::cout << \"Hello, \" << str;\n    return 0;\n}\n```",
            "answer": "The input operator flow is inverted. it should start from `std::cin` and then flow (>>) into `str`.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "The input operator flow is inverted. it should start from `std::cin` and then flow (>>) into `str`."
            ],
            "options": [
              "The main function is supposed to have a void return type.",
              "`std::cin` and `std::cout` are invalid. The correct names for the character input and output streams are `cin` and `cout`.",
              "The address of `str` is supposed to be used. That is `&str` instead of `str`.",
              "The input operator flow is inverted. it should start from `std::cin` and then flow (>>) into `str`."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3e1552a46ff68f1d7892c2ba",
            "question": "When placed in a valid execution context, which statement will dynamically allocate memory from the heap for an integer of value 11?",
            "answer": "`int* anInt = new int(11);`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`int* anInt = new int(11);`"],
            "options": [
              "`int anInt = new int(11);`",
              "`int* anInt = new int[11];`",
              "`int anInt = new int[11];`",
              "`int* anInt = new int(11);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6672c682b0ab492405181f56",
            "question": "Which choice best describes the type `long`?",
            "answer": "an integer number of at least 32 bits",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["an integer number of at least 32 bits"],
            "options": [
              "an integer number of at least 32 bits",
              "a string with more than 255 characters",
              "a pointer",
              "a 64-bit floating point number"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a168f9b1a8d91935ae8fef9b",
            "question": "Which of the following types has the closest functionality to a class?",
            "answer": "`struct`",
            "explanation": "[Reference](https://en.cppreference.com/w/c/language/struct)",
            "hint": null,
            "correctAnswer": ["`struct`"],
            "options": ["`struct`", "`union`", "`enum`", "`namespace`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "af706cc597402e987d682342",
            "question": "Given these records in a map, how will you update the value for the key \"Sinead\" to 22?\n![image](images/Q79.png)",
            "answer": "`marks[\"Sinead\"] = 22`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`marks[\"Sinead\"] = 22`"],
            "options": [
              "`marks[\"Sinead\"] = 22`",
              "`marks[\"Sinead\"].22`",
              "`marks[\"Sinead\"] -> 22`",
              "`marks[\"Sinead\"].value = 22`"
            ],
            "nature": "ChooseOne",
            "attachments": [
              {
                "id": "5ded33e4f9551eda1c9769a0",
                "url": "/Users/arslankaleem/Workspace/Junk/linkedin-skill-assessments-quizzes/c++/images/Q79.png",
                "type": "question"
              }
            ],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8db6108fc88ec154e5deee0c",
            "question": "Why can the std::sort receive a function object as one of its parameters?",
            "answer": "`The std::sort function is a template. The programmer is free to enter the sorting algorithm in a function object as an argument.`",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "`The std::sort function is a template. The programmer is free to enter the sorting algorithm in a function object as an argument.`"
            ],
            "options": [
              "`The std::sort function is a template. The programmer is free to enter the sorting algorithm in a function object as an argument.`",
              "`Actually, std::sort takes only one argument, which is the container to be sorted.`",
              "`std::sort operates on a template container. The compiler does not know how to relationally compare the values it contains, so a function must be provided to do the comparison.`",
              "`std::sort will use the parameter function as an error handler. The function will be called if an error occurs.`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6f21014ee98b5242eec01d1c",
            "question": "What will happen when you execute this code snippet?\n```\n#include <iostream>\nint main() {\nfloat a = 5.51;\nint b = static_cast<int>(a);\nstd::cout << b;\n}\n```",
            "answer": "`5 will be printed on standard output, with no compilation warnings generated.`",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "`5 will be printed on standard output, with no compilation warnings generated.`"
            ],
            "options": [
              "`6 will be printed on standard output, with no compilation warnings generated.`",
              "`5 will be printed on standard output, with no compilation warnings generated.`",
              "`6 will be printed on standard output, with compilation warnings generated.`",
              "`5 will be printed on standard output, with compilation warnings generated.`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8207d633ba99efdcaefd715d",
            "question": "Which access specifier does not allow class members to be accessed from outside the class, but allows them to be accessed by derived classes?",
            "answer": "protected",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["protected"],
            "options": ["guarded", "protected", "public", "private"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e75229ef4ea4d01128451043",
            "question": "The default executable generation on UNIX for a C++ program is \\_",
            "answer": "a.out",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["a.out"],
            "options": ["a.exe", "a", "a.out", "out.a"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "de3e6e211fab1838bea63c9f",
            "question": "What will be the output of the following program?\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\n  int a=1;\n  cout<<(a++)*(++a)<<endl;\n  return 0;\n}\n```",
            "answer": "3",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["3"],
            "options": ["1", "2", "3", "6"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fd88f9e23608fba37735805a",
            "question": "What does \"c\" stand for in cout and cin?",
            "answer": "character",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["character"],
            "options": ["compiler", "console", "character", "standard namespace"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8e3ed2c0859a025feb5c3ef8",
            "question": "What is the use of tellp()?",
            "answer": "Current Output Pointer position",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Current Output Pointer position"],
            "options": [
              "Current Input Pointer position",
              "Current Output Pointer position",
              "Last Input Pointer position",
              "Last Output Pointer position"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "251521fc9857980fc12817df",
            "question": "What is callback function?",
            "answer": "Pointer for a function",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Pointer for a function"],
            "options": [
              "Pointer for a pointer",
              "Pointer for a function",
              "function for a pointer",
              "function for a class"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e0965e016be19d676f1e8477",
            "question": "What is the correct syntax to output \"Hello World\" in C++?",
            "answer": "`cout << \"Hello World\";`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`cout << \"Hello World\";`"],
            "options": [
              "`cout << \"Hello World\";`",
              "`System.out.println(\"Hello World\");`",
              "`print(\"Hello World\");`",
              "Console.WriteLine(\"Hello World\");```"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1648ea9982450a960f01203f",
            "question": "How many categories of iterators are there in C++?",
            "answer": "5",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["4", "3", "7", "5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3f5e884e6c631edc0458afc9",
            "question": "What is the meaning of base class in C++ ?",
            "answer": "Another class got inherited from this class",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Another class got inherited from this class"],
            "options": [
              "It inherits other class",
              "It has a pointer variable",
              "It is the first class declared",
              "Another class got inherited from this class"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2cf842c8f72941bd618e8c95",
            "question": "The size of C++ objects is expressed in terms of multiples of the size of a ** and the size of a char is **.",
            "answer": "char, 1",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["char, 1"],
            "options": ["char, 4", "float, 8", "int, 1", "char, 1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3681ffda203c0f9461642ee7",
            "question": "Implementation-dependent aspects about an implementation can be found in",
            "answer": "`<limits>`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`<limits>`"],
            "options": ["`<numeric>`", "`<limit>`", "`<limits>`", "`<implementation>`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2d3fe3a23b1a7af3a1b3af8c",
            "question": "What is a default constructor?",
            "answer": "a constructor that can be used with no arguments",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["a constructor that can be used with no arguments"],
            "options": [
              "a constructor that can be used with no arguments",
              "a constructor that does not have a return value",
              "a constructor that is used by multiple classes",
              "a constructor that initializes all members of a class"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "65f854a69a69ef1c158984a9",
            "question": "When protecting a header file, why would you use '#pragma once' instead of 'include' guard?",
            "answer": "An include guard uses a macro to achieve single inclusion, but the compiler cannot prevent the programmer from defining that macro elsewhere, which would result in no inclusion at all",
            "explanation": "defining that macro elsewhere, which would result in no inclusion at all\nmore than once in a project. This is not a problem with '#pragma once'",
            "hint": null,
            "correctAnswer": [
              "An include guard uses a macro to achieve single inclusion, but the compiler cannot prevent the programmer from defining that macro elsewhere, which would result in no inclusion at all"
            ],
            "options": [
              "There is no reason to choose because they serve different purposes",
              "An include guard uses a macro to achieve single inclusion, but the compiler cannot prevent the programmer from defining that macro elsewhere, which would result in no inclusion at all",
              "'#pragma once' guarantees that the header code will never be changed because it is enforced by the compiler",
              "Include guards refer to the header file in the file system, not to the code, so they are not helpful if the header file exists"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "201c7c4f1e68889d40dc66c7",
            "question": "Which of the following statements is valid?",
            "answer": "We can not change the operator templates.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["We can not change the operator templates."],
            "options": [
              "We can create a new C++ operator.",
              "We can change the precedence of the C++ operator.",
              "We can not change the operator templates.",
              "We can change the associativity of the C++ operators."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c5fd49b6707f40d705d8093e",
            "question": "Which of the following is/are automatically added to every class, if we do not write our own?",
            "answer": "All of the above",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["All of the above"],
            "options": [
              "Copy Constructor",
              "Assignment Operator",
              "A constructor without any parameter",
              "All of the above"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "15f942a3b715c574f5cc5975",
            "question": "The if-else statement can be replaced by which operator?",
            "answer": "selective structure",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["selective structure"],
            "options": [
              "certain structure",
              "choosing structure",
              "selective structure",
              "None of the Above"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "81db990733e1f44272790df3",
            "question": "Which choice would be a recursive solution to the factorial n! problem?",
            "answer": "&shy;",
            "explanation": "```cpp\nvoid fact(int n) {\nif (n <= 0)\nreturn 0;\nelse\nreturn 1;\n}\n```\n```cpp\nint fact(int n) {\nif (n <= 0)\nreturn 1;\nelse\nreturn (fact(n) * (n-1));\n}\n```\n```cpp\nint fact(int n) {\nif (n >= 0)\nreturn 1;\nelse\nreturn (fact(n-1) * n);\n}\n```\n```cpp\nint fact(int n) {\nif (n <= 0)\nreturn 1;\nelse\nreturn (fact(n-1) * n);\n}\n```",
            "hint": null,
            "correctAnswer": ["&shy;"],
            "options": ["&shy;", "&shy;", "&shy;", "&shy;"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c86198329a5ecc74b31338a1",
            "question": "A class destructor can be called when a variety of situations occur. Which choice is not one of those situations?",
            "answer": "The garbage collector detects that an object is no longer going to be used.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "The garbage collector detects that an object is no longer going to be used."
            ],
            "options": [
              "The program is terminated. This calls the destructor of static duration objects.",
              "The delete () function is called for an object pointer assigned with the new operator.",
              "The garbage collector detects that an object is no longer going to be used.",
              "An automatic storage duration object goes out of scope."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c3ce80b656366b2e94b9e611",
            "question": "You are designing a foreign exchange payments system in C++, You need to model a transaction of a currency that has an integer as its quantity and a float as its price. You then want to declare an actual object of this type. How will you achieve this?",
            "answer": "A",
            "explanation": "```cpp\nstruct currencyDeal {\nfloat price;\nint quantity;\n};\ncurrencyDeal firstDeal;\n```\n```cpp\nunion currencyDeal {\nfloat price;\nint quantity;\n};\ncurrencyDeal firstDeal;\n```\n```cpp\nstruct currencyDeal {\nfloat price;\nint quantity;\n};\n```\n```cpp\nunion currencyDeal {\nfloat price;\nint quantity;\n};\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f764c26369c116d4a352a78a",
            "question": "What will happen if you attempt to call this function with checkConcatThreshold(\"a\");?\n```cpp\nint checkConcatThreshold(string a, string b) {\n    return (a + b).length () > 120;\n}\n```",
            "answer": "A compilation error will occur.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["A compilation error will occur."],
            "options": [
              "A compilation warning will occur and the second argument will be given a default value of b.",
              "A compilation warning will occur and the second argument will be given a default value of the empty string.",
              "A compilation error will occur.",
              "No compilation errors will occur and no compilation warnings will occur."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cf3970aef60c022ed55af16b",
            "question": "You need to define a C++ lambda function. You want the function to have access to only the variables that are local to it. The function should receive a single parameter, and a name, and construct a simple greeting. How will you achieve this?",
            "answer": "C",
            "explanation": "```cpp\nauto myVeryFirstLambda = [=] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nmyVeryFirstLambda = [&] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nauto myVeryFirstLambda = [] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nmyVeryFirstLambda = [] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n[Reference](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160)",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bf21e6d951950cb48b77c37a",
            "question": "What is the value of X after running this code?\n```cpp\nint x=10, a=-3;\nX+=a;\n```",
            "answer": "7",
            "explanation": "**Explanation :** `+=` means increasing value. So `x += a` is equivalent to `x = x + a`",
            "hint": null,
            "correctAnswer": ["7"],
            "options": ["-3", "7", "13", "3"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "86a182d49df9a467081087e8",
            "question": "Once you are done writing to a file, what method will you call on the `ofstream` to notify the operating system?",
            "answer": "close()",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["close()"],
            "options": ["printout()", "close()", "destroy()", "flush()"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "18a45e0228c0052ce3bc2998",
            "question": "Which choice is not a C++ keyword?",
            "answer": "comPl",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["comPl"],
            "options": ["static_assert", "reinterpret_cast", "comPl", "alignas"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8756e42147958e9eefc2b6c1",
            "question": "The size_in_bits function seems to take any type of parameter. This can be done by overloading the function, or by letting the compiler take care of it by writing a template. Which choice is an implementation of that template?\n```cpp\nint main()\n{\ncout « size_in_bits(21) « endl;\ncout « size_in_bits('f') « endl;\ncout « size_in_bits(32.1f) « endl;\ncout « size_in_bits(32.1) « endl;\nreturn 0;\n}\n```",
            "answer": "A; C",
            "explanation": "```cpp\ntemplate <typename T>\nsize_t size_in_bits(const T& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\ntemplate size_t size_in_bits(const {int,float,double,char,long}& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\ntemplate <typename T {int,float,double,char,long>\nsize_t size_in_bits(const T& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\nsize_t size_in_bits(void * a){\nreturn sizeof(a)*8;\n}\n```",
            "hint": null,
            "correctAnswer": ["A", "C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4909c1ff582e30a0e1375495",
            "question": "To use the keyboard as input the iostream library is included. To read input from files as input what library is needed?",
            "answer": "fstream",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["fstream"],
            "options": ["fstream", "cstdlib", "filestream", "iostream"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e69290ea3af8b5b9903da547",
            "question": "What will this object-oriented program print?\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Vehicle {\npublic:\n    string fuel = \"none\";\n};\nclass MotorizedVehicle : public Vehicle {\npublic:\n    string fuel = \"fossil\";\n};\nclass NextgenMotorizedVehicle : public MotorizedVehicle {\npublic:\n    string fuel = \"hydrogen\";\n};\nint main() {\n    MotorizedVehicle aCar;\n    cout << aCar.fuel;\n    return 0;\n}\n```",
            "answer": "fossil",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["fossil"],
            "options": ["fossil", "fossil none", "hydrogen", "none"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "30daac78f4ccb78309679e87",
            "question": "The program below is handling a stack container. What is the output of running the program?\n```cpp\n#include <iostream>\n#include <stack>\nint main()\n{\n    std::stack<int> stack;\n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n    stack.pop();\n    stack.push(4);\n    stack.top();\n    stack.pop();\n    std::cout << stack.top();\n}\n```",
            "answer": "2",
            "explanation": "#Detailed explanation:\nNow here we are supposed to implement a stack data structure that follows the **FILO** or (First IN Last Out) principle,\n_stack.push()_ -> pushes an element into the from the end array.\n_stack.pop()_ -> removes an element from the end of the array.\n_stack.top()_ -> Just gives us the topmost element of the array.\nNow following the sequences of push and pop: **[1,2,3]** then pop function is used,\nThe newly formed array is: **[1,2,4]** then the top is used to retrieve the topmost element '4' then again the pop function is used which removes 4.\nthus, the resulting array is: 1,2.\nThen it prints the topmost element (ie: 2).",
            "hint": null,
            "correctAnswer": ["2"],
            "options": ["1", "2", "3", "4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9139191ec18a7d49590faf46",
            "question": "Which choice is a valid way to overload the ternary conditional operator?",
            "answer": "`The ternary operator is not overloadable.`",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/operators)",
            "hint": null,
            "correctAnswer": ["`The ternary operator is not overloadable.`"],
            "options": [
              "`void& operator ?:(const bool cond, const void& iftrue, const void& iffalse);`",
              "`The ternary operator is not overloadable.`",
              "`void& operator conditional(const bool cond, const void& iftrue, const void& iffalse);`",
              "`void* operator ?:(const bool cond, const void* iftrue, const void* iffalse);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fa53fffe732c533547fa7fe2",
            "question": "Which class hierarchy represents an example of multilevel inheritance?",
            "answer": "In the same program, at different points, a given class derives individually from more than two different classes.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "In the same program, at different points, a given class derives individually from more than two different classes."
            ],
            "options": [
              "In the same program, at different points, a given class derives individually from more than one different class.",
              "A first-class derives directly, at the same time, from a second and third class.",
              "In the same program, at different points, a given class derives individually from more than two different classes.",
              "A first classderives from a second class, and that second class is already derived from a third class"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f05172ed26a62d5e4e37aecb",
            "question": "Which of the following is the correct syntax to print the message in C++ language?",
            "answer": "cout <<\"Hello world!\";",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/io/cout)",
            "hint": null,
            "correctAnswer": ["cout <<\"Hello world!\";"],
            "options": [
              "Out <<\"Hello world!",
              "Cout << Hello world! ;",
              "cout <<\"Hello world!\";",
              "None of the above"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2042b9693fe128d919da388d",
            "question": "Consider the following program. What will be the output/error?\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nbool compare(char c1, char c2){\nreturn tolower(c1) > tolower(c2);    //LINE-1\n}\nint main(){\nchar arr1[20] = \"C++ Program\", arr2[20] = \"C Program\";\ncout << lexicographical_compare(arr1, arr1+strlen(arr1), arr2, arr2+strlen(arr2),\ncompare);\nreturn 0;\n}\n```",
            "answer": "1",
            "explanation": "[Reference](https://www.geeksforgeeks.org/tolower-function-in-cpp/)",
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["1", "0", "-1", "Compilation Error: function is not defined"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bd51acd9b00b1132f1450f17",
            "question": "Consider the following code segment. Fill in the blank at LINE-1 so that the program will print \"not found\"?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint data[] = {1,2,3,4,5};\nint key = 5;\nif(binary_search(__________))    //LINE-1\ncout << \"found\";\nelse\ncout << \"not found\";\nreturn 0;\n}\n```",
            "answer": "&data[0], &data[4], key; data+1, data+4, key",
            "explanation": "[Reference](https://www.geeksforgeeks.org/binary-search-algorithms-the-c-standard-template-library-stl/)",
            "hint": null,
            "correctAnswer": ["&data[0], &data[4], key", "data+1, data+4, key"],
            "options": [
              "&data[0], &data[5], key",
              "data, data+5, key",
              "&data[0], &data[4], key",
              "data+1, data+4, key"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "60424f7c401642926180ec70",
            "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main () {\nint data[] = {50, 30, 40, 10, 20};\nsort (&data[1], &data[4]);\nfor (int i = 0; i < 5; i++)\ncout << data[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "50 10 30 40 20",
            "explanation": "[Reference](https://cplusplus.com/reference/algorithm/sort/)",
            "hint": null,
            "correctAnswer": ["50 10 30 40 20"],
            "options": ["10 20 30 40 50", "10 30 40 50 20", "50 10 30 40 20", "50 10 20 30 40"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "58f81f8ecf33788ef41fd5c3",
            "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint element[5];\nfor(int i = 1; i <= 5; i++)\n*(element + i - 1) = i * 5;\nrotate(element, element + 4, element + 5);\nrotate(element, element + 1, element + 4);\nfor (int i = 0; i < 5; ++i)\ncout << element[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "5 10 15 25 20",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/algorithm/rotate)",
            "hint": null,
            "correctAnswer": ["5 10 15 25 20"],
            "options": ["5 10 15 20 25", "5 10 15 25 20", "20 10 15 25 5", "25 5 10 15 20"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0e8be47694caa5d73aacb699",
            "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nconst int size = 3, c = 65;\nvector<char> vc(size, ’A’);\nfor (int i = 1; i <= 2; i++)\nvc.push_back(65 + i);\nvc.resize(10, 90);\nvc.resize(8);\nfor (int i = 0; i < vc.size(); i++)\ncout << vc[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "A A A B C Z Z Z",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/container/vector)",
            "hint": null,
            "correctAnswer": ["A A A B C Z Z Z"],
            "options": ["A A A B C Z Z Z", "A A B B C Z Z Z", "A A A B C Z Z", "A A A B C Z Z Z Z"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e8a6057e9a9df595ed29fd9b",
            "question": "Consider the following code segment. Choose the appropriate option to fill in the blank at LINE-1, such that the output of the code would be: a C++ Program.\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nint main(void) {\nstring s1 = \"C++ \";\nstring s2 = \"Program\";\n__________________;    //LINE-1\ncout << s1;\nreturn 0;\n}\n```",
            "answer": "s1 += s2; s1.append(s2)",
            "explanation": "[Reference](https://www.geeksforgeeks.org/stdstringappend-in-c/)",
            "hint": null,
            "correctAnswer": ["s1 += s2", "s1.append(s2)"],
            "options": ["s1 += s2", "strcat(s1, s2)", "s1.append(s2)", "s1.insert(s2)"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6d1e33c4ef33b235790c92e8",
            "question": "Consider the following code segment. Fill in the blank at LINE-1 such that the output is 5 2 3 4 5\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint data[] = { 1, 2, 3, 4, 5 };\nfor (int i = 0; i < 1; i++) {\nint j = data[i];\nreplace(data, data + 5, j, *(_________________));    //LINE-1\n}\nfor (int i = 0; i < 5; ++i)\ncout << data[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "data + 4 - i",
            "explanation": "[Reference](https://www.geeksforgeeks.org/stdstringreplace-stdstringreplace_if-c/)",
            "hint": null,
            "correctAnswer": ["data + 4 - i"],
            "options": ["data + 4 - i", "data + 5 - i", "data + i - 4", "data + i - 5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4856bcb8b44089dccc58e6ff",
            "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\n#include <cstring>\n#include <stack>\nusing namespace std;\nint main(){\nchar str[10] = \"123456789\";\nstack<char> s1, s2;\nint i;\nfor(i = 0; i < strlen(str)/2; i++)\ns1.push(str[i]);\nfor(i=i-1; i < strlen(str); i++)\ns2.push(str[i]);\nwhile (!s1.empty()) {\ns2.push(s1.top()); s1.pop();\n}\nwhile (!s2.empty()) {\ncout << s2.top(); s2.pop();\n}\nreturn 0;\n}\n```",
            "answer": "1234987654",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/container/stack)",
            "hint": null,
            "correctAnswer": ["1234987654"],
            "options": ["1234987654", "123498765", "1234897654", "123459876"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ba7f48ab9e8dd15fe0277157",
            "question": "Consider the following code segment. Which statement/statements is/are correct?\n```cpp\nint i = 5;\nconst int *p = &i;\nint * const q = &i;\nint const *r = &i;\nint const * const s = &i;\n*p = 10; //STMT-1\n*q = 10; //STMT-2\n*r = 10; //STMT-3\n*s = 10; //STMT-4\n```",
            "answer": "STMT-2",
            "explanation": "[Reference](https://www.geeksforgeeks.org/const-keyword-in-cpp/)",
            "hint": null,
            "correctAnswer": ["STMT-2"],
            "options": ["STMT-1", "STMT-2", "STMT-3", "STMT-4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cc695ff06a4d496bb477875d",
            "question": "Consider the following program. What will be the output/error(s)?\n```cpp\n#include <iostream>\nusing namespace std;\nchar add(char c1 = ’a’) { return c1; }\nchar add(char c1 = ’a’, char c2 = ’b’) { return c1 + c2 - ’a’;}\nchar add(char c1 = ’a’, int d1 = 100){ return c1 + d1 - ’a’; }\nchar add(char c1 = ’a’, char c2 = ’b’, char c3) { return c1 + c2 + c3 - ’a’; }\nint main() {\nchar c = add(’o’, ’k’);\ncout << c << endl;\nreturn 0;\n}\n```",
            "answer": "Compilation Error: default argument missing for \"char add(char, char, char)\"; Compilation Error: call of overload \"add(char, char)\" is ambiguous",
            "explanation": "[Reference](https://learn.microsoft.com/en-us/cpp/cpp/function-overloading?view=msvc-170)",
            "hint": null,
            "correctAnswer": [
              "Compilation Error: default argument missing for \"char add(char, char, char)\"",
              "Compilation Error: call of overload \"add(char, char)\" is ambiguous"
            ],
            "options": [
              "y",
              "z",
              "Compilation Error: default argument missing for \"char add(char, char, char)\"",
              "Compilation Error: call of overload \"add(char, char)\" is ambiguous"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "df4d7ef60fa3e113074dcc38",
            "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\nusing namespace std;\n#define SQR(x) (x)*(x)\nint main() {\nint a=3;\ncout << SQR(a++) << endl;\nreturn 0;\n}\n```",
            "answer": "12",
            "explanation": "[Reference](https://www.geeksforgeeks.org/output-of-the-program-use-macros-carefully/)",
            "hint": null,
            "correctAnswer": ["12"],
            "options": ["12", "25", "9", "16"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0310eb3c0bbbfc822bb6b6be",
            "question": "Consider the following code segment. Which line/s will give you an error?\n```cpp\n#include<iostream>\n#define X 1\nusing namespace std;\nint main(){\nint i;\nconst int i1 = 2;\nconst int i2 = i1; //LINE-1\ni2 = X;\ni = i1;\ni1 = i;\nreturn 0;\n//LINE-2\n//LINE-3\n//LINE-4\n}\n```",
            "answer": "LINE-2; LINE-4",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["LINE-2", "LINE-4"],
            "options": ["LINE-1", "LINE-2", "LINE-3", "LINE-4"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "eec1b82ccf42f0710d7f984b",
            "question": "Consider the following code segment. What will be the output/error?\n```cpp\n#include<iostream>\nusing namespace std;\nint main(){\nint a = 5;\nint &b = a+1;\na = a*b;\ncout << a << \" \" << b;\nreturn 0;\n}\n```",
            "answer": "Compilation Error: invalid initialization of non-const reference",
            "explanation": "#Detailed explanation:\nThe error is occurring because it is trying to create a reference to a temporary value. In the line int &b = a+1; we are attempting to create a reference b to the result of the expression a + 1, which is a temporary value. References must be bound to an actual object, not a temporary value or an expression that does not have a memory location.",
            "hint": null,
            "correctAnswer": ["Compilation Error: invalid initialization of non-const reference"],
            "options": [
              "36",
              "30",
              "25",
              "Compilation Error: invalid initialization of non-const reference"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d5108549f2b425bc1e4658cc",
            "question": "Consider the following code segment. What will be the output?\n```cpp\n#include <iostream>\nusing namespace std;\nint& func(int& i) {     //LINE-1\nreturn i = i+5;\n}\nint main() {\nint x = 1, y = 2;\nint& z = func(x);\ncout << x << \" \" << z << \" \";\nfunc(x) = y;\ncout << x << \" \" << z;\nreturn 0;\n}\n```",
            "answer": "6 6 2 2",
            "explanation": "[Reference](https://www.ibm.com/docs/en/zos/2.4.0?topic=calls-pass-by-reference-c-only)",
            "hint": null,
            "correctAnswer": ["6 6 2 2"],
            "options": ["6 6 2 2", "6 6 7 7", "1 1 2 2", "1 1 7 7"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e214e8c6caf5e911f33ae6be",
            "question": "Consider the following code segment. Choose the appropriate option to fill in the blanks at LINE-1, such that the output of the code would be: 300 20000.\n```cpp\n#include <iostream>\nusing namespace std;\nvoid compute(int n1, int n2, ________, ________){ //LINE-1\nn3 = n1 + n2;\n*n4 = n1 * n2;\n}\nint main(){\nint a = 100, b = 200, c = 0, d = 0;\ncompute(a, b, c, &d); //LINE-2\ncout << c << \", \";\ncout << d;\nreturn 0;\n}\n```",
            "answer": "int& n3, int \\*n4",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["int& n3, int \\*n4"],
            "options": [
              "int n3, int\\* n4",
              "int& n3, int \\*n4",
              "int* n3, int* n4",
              "int& n3, int& n4"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "18e787479f146a5f8bcc9282",
            "question": "Consider the following code segment. What will be the output/error?\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\nint a = 2, *b;\n*b = 5;\nint * const ptr;    // LINE-1\n// LINE-2\nptr = b;\ncout << *ptr;\nreturn 0;\n}\n```",
            "answer": "Compilation Error at LINE-1: uninitialized const ’ptr’; Compilation Error at LINE-2: assignment of read-only variable ’ptr’",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Compilation Error at LINE-1: uninitialized const ’ptr’",
              "Compilation Error at LINE-2: assignment of read-only variable ’ptr’"
            ],
            "options": [
              "`<garbage value>`",
              "5",
              "Compilation Error at LINE-1: uninitialized const ’ptr’",
              "Compilation Error at LINE-2: assignment of read-only variable ’ptr’"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "75565f8b0975002d7d72e60e",
            "question": "Consider the following code segment. What will be the output/error?\n```cpp\n#include <iostream>\nusing namespace std;\nvoid fun(int a = 5) { cout << a << endl; }\n//LINE-1\nint fun(int x = 10) { cout << x << endl; return 0; }    //LINE-2\nint main() {\nfun();\nreturn 0;\n}\n```",
            "answer": "Compilation error at LINE-2: ambiguating new declaration of ’int fun(int)’",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Compilation error at LINE-2: ambiguating new declaration of ’int fun(int)’"
            ],
            "options": [
              "5",
              "10",
              "5",
              "Compilation error at LINE-2: ambiguating new declaration of ’int fun(int)’"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9d564c97a6e66ee2f0334264",
            "question": "Consider the following code segment. Fill in the blank at LINE-1 such that the program will print 5 + i3\n```cpp\n#include<iostream>\nusing namespace std;\nstruct complex{\nint re, im;\nvoid show(){ cout << re << \" + i\" << im; }\n};\n______________________________________{ //Line-1\nc2.re = c1.re+c2.re;\nc2.im = c1.im+c2.im;\nreturn c2;\n}\nint main(){\nstruct complex c1={2,5},c2{3,-2};\nstruct complex t = c1 + c2;\nt.show();\nreturn 0;\n}\n```",
            "answer": "complex operator+(complex &c1, complex &c2)",
            "explanation": "[Reference](https://www.w3schools.com/cpp/cpp_structs.asp)",
            "hint": null,
            "correctAnswer": ["complex operator+(complex &c1, complex &c2)"],
            "options": [
              "complex operator+(complex &c1, complex &c2)",
              "complex operator+(const complex &c1, const complex &c2)",
              "operator+(complex &c1, complex &c2)",
              "complex +(complex &c1, complex &c2)"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0e7c5e773800d06e4f5c08e2",
            "question": "Consider the following program. Which line/s will generate an error?\n```cpp\n#include<iostream>\nusing namespace std;\nclass myClass{\nint pra = 5;\npublic:\nint pub = 10;\nvoid set_pr(int x){ pra = x; }\nvoid set_pu(int x){ pub = x; }\n};\nint main(){\nmyClass m;\nint a, b;\na = m.pra; //LINE-1\nb = m.pub; //LINE-2\nm.set_pr(100); //LINE-3\nm.set_pu(200); //LINE-4\nreturn 0;\n}\n```",
            "answer": "LINE-1",
            "explanation": "[Reference](https://stackoverflow.com/questions/4855422/c-classes-public-private-and-protected)",
            "hint": null,
            "correctAnswer": ["LINE-1"],
            "options": ["LINE-1", "LINE-2", "LINE-3", "LINE-4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9b84051caf6c7654392a9b9d",
            "question": "Consider the following class. Fill in the blanks with proper access specifiers so that member y can be accessed from outside of the class but member x cannot be accessed.\n```cpp\nclass Test{\n________:\nint x;\n________:\nint y;\n/* Some more code */\n};\n```",
            "answer": "private, private",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["private, private"],
            "options": ["public, public", "public, private", "private, public", "private, private"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "14fe85ec4640c5c3ee82551c",
            "question": "Which C++ Standard did add in-class default member initializers?",
            "answer": "C++11",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C++11"],
            "options": ["C++98", "C++11", "C++14", "C++17."],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d365e8b193f5d3a86e2da366",
            "question": "Can you use auto type deduction for non-static data members?",
            "answer": "No",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["No"],
            "options": ["Yes, since C++11", "No", "Yes, since C++20"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "13f9b40ac6734b2fefa38798",
            "question": "Do you need to define a static inline data member in a cpp file?",
            "answer": "No, the definition happens at the same place where a static inline member is declared.",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": [
              "No, the definition happens at the same place where a static inline member is declared."
            ],
            "options": [
              "No, the definition happens at the same place where a static inline member is declared.",
              "Yes, the compiler needs the definition in a cpp file.",
              "Yes, the compiler needs a definition in all translation units that use this variable."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "36f44a6c1d24554f53e6cbe1",
            "question": "What's the output of the following code:\n```cpp\nstruct S {\n    int a { 10 };\n    int b { 42 };\n};\nS s { 1 };\nstd::cout << s.a << \", \" << s.b;\n```",
            "answer": "Output is: 1, 42",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Output is: 1, 42"],
            "options": ["Output is: 1, 0", "Output is: 10, 42", "Output is: 1, 42"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "94a9d143fe998d3c3d2a93d9",
            "question": "Can a static inline variable be non-constant?",
            "answer": "Yes, it's just a regular variable.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Yes, it's just a regular variable."],
            "options": [
              "Yes, it's just a regular variable.",
              "No, inline variables must be constant."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "45a702f6094acd343ea60140",
            "question": "Consider the following code:\n```cpp\nstruct C {\n    C(int x) : a(x) { }\n    int a { 10 };\n    int b { 42 };\n};\nC c(0);\n```",
            "answer": "C::a is initialized only once with 0 in the constructor.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C::a is initialized only once with 0 in the constructor."],
            "options": [
              "C::a is initialized twice. The first time, it's initialized with 10, and then the second time with 0 in the constructor.",
              "C::a is initialized only once with 0 in the constructor.",
              "The code doesn't compile because the compiler cannot decide how to initialize the C::a member.",
              "2 bytes"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1164f1a7f076a65892ceab85",
            "question": "What happens when you throw an exception from a constructor?",
            "answer": "The object is considered \"partially created,\" and thus, the compiler won't call its destructor.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "The object is considered \"partially created,\" and thus, the compiler won't call its destructor."
            ],
            "options": [
              "The object is considered \"created\" so it will follow the regular lifetime of an object.",
              "The object is considered \"partially created,\" and thus, the compiler won't call its destructor.",
              "he compiler calls std::terminate as you cannot throw exceptions from constructors."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "afb1d8a90ce89588f7df995f",
            "question": "What happens when you compile this code?\n```cpp\nstruct Point { int x; int y; };\nPoint pt {.y = 10, .x = 11 };\nstd::cout << pt.x << \", \" << pt.y;\n```",
            "answer": "The code doesn't compile. Designators have to be in the same order as the data members in the Point class.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "The code doesn't compile. Designators have to be in the same order as the data members in the Point class."
            ],
            "options": [
              "The code doesn't compile. Designators have to be in the same order as the data members in the Point class.",
              "The code compiles and prints 11, 10.",
              "The code compiles and prints 10, 11."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "46fa3ab041c29c692914baea",
            "question": "Will this code work in C++11?\n```cpp\nstruct User { std::string name = \"unknown\"; unsigned age { 0 }; };\nUser u { \"John\", 101 };\n```",
            "answer": "The code compiles starting with C++14 mode.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["The code compiles starting with C++14 mode."],
            "options": [
              "Yes, the code compiles in C++11 mode.",
              "The code compiles starting with C++14 mode.",
              "The code doesn't compile even in C++20."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "93abfc08b4a8d11cae1895f9",
            "question": "Assume you have a std::map<string, int> m;. Select the single true statement about the following loop:\n```cpp\nfor (const pair<string, int>& elem : m)\n```",
            "answer": "A The loop properly iterates over the map, creating no extra copies.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "A The loop properly iterates over the map, creating no extra copies."
            ],
            "options": [
              "A The loop properly iterates over the map, creating no extra copies.",
              "B The loop will create a copy of each element in the map as the type of elem mismatches.",
              "C The code won't compile as a const pair cannot bind to a map."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9ae89ad4d90c30d048137ec1",
            "question": "Identify the correct extension of the user-defined header file in C++.",
            "answer": ".h",
            "explanation": null,
            "hint": null,
            "correctAnswer": [".h"],
            "options": [".cpp", ".hg", ".h", ".hf"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "22cba7e22e79d19f012bffc5",
            "question": "Identify the incorrect constructor type.\n```cpp\nauto x = 4000.22;\n```",
            "answer": "Friend Constructor",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Friend Constructor"],
            "options": [
              "Friend Constructor",
              "Default Constructor",
              "Parameterised Constructor",
              "CopyConstructor"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8587d7250f8d2963dd25e973",
            "question": "Which of the following data types is supported in C++ but not in C?",
            "answer": "bool",
            "explanation": "[Reference]: https://stackoverflow.com/questions/1608318/is-bool-a-native-c-type",
            "hint": null,
            "correctAnswer": ["bool"],
            "options": ["bool", "int", "double", "float"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a231ec18c34d594afb2022c5",
            "question": "Identify the correct syntax for declaring arrays in C++.",
            "answer": "int arr[10]",
            "explanation": "[Reference]: (https://en.cppreference.com/w/cpp/language/array)",
            "hint": null,
            "correctAnswer": ["int arr[10]"],
            "options": ["int arr[10]", "array arr[10]", "array{10}", "int arr"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0ebe8413f5add0989ae6c500",
            "question": "Size of wchat_t is.",
            "answer": "Depends on the number of bits in the system",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Depends on the number of bits in the system"],
            "options": ["2", "4", "2 or 4", "Depends on the number of bits in the system"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f1cb64f5e50901d40bad55ab",
            "question": "Which of the following loops is best when we know the number of iterations?",
            "answer": "for",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["for"],
            "options": ["while", "for", "do", "All of the above"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c0a12db05d03ca8d284b3e26",
            "question": "Which keyword is used to define the macros in C++?",
            "answer": "#define",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["#define"],
            "options": ["#macro", "#define", "macro", "keyword"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4708468f7b3f946b5e50d531",
            "question": "Which of the following operators should be preferred to overload as a global function rather than a member method?",
            "answer": "Comparison Operator",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Comparison Operator"],
            "options": ["Postfix ++", "Comparison Operator", "Insertion Operator <<", "Prefix++"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "88d08bc7758ddbb9ddf36d05",
            "question": "How can we restrict the dynamic allocation of objects of a class using new?",
            "answer": "By making an empty private new and new[] operators",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["By making an empty private new and new[] operators"],
            "options": [
              "By overloading new operator",
              "By making an empty private new operator.",
              "By making an empty private new and new[] operators",
              "By overloading new operators and new[] operators"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "000f9192f6f0ce83ae4bd9a7",
            "question": "What is the time complexity of the below code?\n```cpp\nfor(int i=0;i<n;i++){\n   for(int j=0;j<n;j++){\n       cout<<\"hello\";\n    }\n}\n```",
            "answer": "O(n^2)",
            "explanation": "[Reference](<https://medium.com/enjoy-algorithm/analysis-of-loop-in-programming-cc9a644ef8cd#:~:text=At%20each%20step%20of%20the%20iteration%2C%20the%20nested%20loop%20is,%20%3D%20O(n%C2%B2)>)",
            "hint": null,
            "correctAnswer": ["O(n^2)"],
            "options": ["O(n^3)", "O(n^2)", "O(n)", "O(1)"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "201f6eb93de2425476399e2e",
            "question": "What is the output of the code given below?\n```cpp\nint a=10;\nint k=++a;\nint m=a++;\ncout<<k+m;\n```",
            "answer": "22",
            "explanation": "Both **++a** and **a++** increase the value of a by 1 (ie: 11) and hence k+m becomes 22.",
            "hint": null,
            "correctAnswer": ["22"],
            "options": ["20", "21", "22", "23"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "091e55afd2fbb7ec4e1c91d5",
            "question": "Which C++ construct is used for exception handling?",
            "answer": "try-catch",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["try-catch"],
            "options": ["try-catch", "if-else", "for loop", "switch-case"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0fca68902b86d9217d8e8b77",
            "question": "What is the purpose of the `break` statement in a loop in C++?",
            "answer": "Terminate the loop",
            "explanation": "[Reference]: (https://www.tutorialspoint.com/cprogramming/c_break_statement.htm)",
            "hint": null,
            "correctAnswer": ["Terminate the loop"],
            "options": [
              "Exit the program",
              "Skip the current iteration and continue with the next one",
              "Terminate the loop",
              "Return a value"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ed3f52a9b88618e52c36225d",
            "question": "In C++, what is the purpose of the `const` keyword when used with a variable?",
            "answer": "It makes the variable immutable",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["It makes the variable immutable"],
            "options": [
              "It makes the variable immutable",
              "It changes the data type",
              "It defines a constant function",
              "It makes the variable a pointer"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e53b82a3ff66a34769abfc35",
            "question": "Which is more effective while calling the C++ functions??",
            "answer": "Call by reference",
            "explanation": "[Reference]: (https://www.algbly.com/More/MCQs/Cpp-mcq/Cpp-functions.html)",
            "hint": null,
            "correctAnswer": ["Call by reference"],
            "options": ["Call by reference", "Call by value", "Call by pointer", "Call by object"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6dfe4bdfd0f9950cb40148ae",
            "question": "What will be the output of the following C++ program?\n```cpp\n#include <iostream>\nusing namespace std;\nclass A{\npublic:\n    A(){\n        cout<<\"Constructor called\\n\";\n       }\n    ~A(){\n        cout<<\"Destructor called\\n\";\n        }\n};\nint main(int argc, char const *argv[])\n{\n    A *a = new A[5];\n    delete[] a;\n    return 0;\n}\n```",
            "answer": "“Constructor called” five times and then “Destructor called” five times",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "“Constructor called” five times and then “Destructor called” five times"
            ],
            "options": [
              "Segmentation fault",
              "“Constructor called” five times and then “Destructor called” five times",
              "“Constructor called” five times and then “Destructor called” once",
              "Error"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b27e920f93f91382625a472d",
            "question": "Which choice is _not_ related to declaring the member variable count as static in my_class?\n```cpp\nclass my_class{\n    public: static int count;\n}\n```",
            "answer": "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it."
            ],
            "options": [
              "All objects that try to access their count member variable actually refer to the only class-bound static count variable.",
              "The variable exists even when no objects of the class have been defined, so it can be modified at any point in the source code.",
              "The variable cannot be modified by any part of the code in the same application or thread. However, other threads may modify it.",
              "The variable is allocated only once, regardless of how many objects are instantiated, because it is bound to the class itself, not its instances."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "19db87edd1bd13cd4da28603",
            "question": "What is the purpose of the `constexpr` keyword in C++?",
            "answer": "`constexpr` is used to indicate that an expression can be evaluated at compile-time, making it suitable for use in constant expressions.",
            "explanation": "[Ref](https://learn.microsoft.com/en-us/cpp/cpp/constexpr-cpp?view=msvc-170#:~:text=constexpr%20indicates%20that%20the%20value,template%20arguments%20and%20array%20declarations.)",
            "hint": null,
            "correctAnswer": [
              "`constexpr` is used to indicate that an expression can be evaluated at compile-time, making it suitable for use in constant expressions."
            ],
            "options": [
              "It is used to define constants in C++.",
              "`constexpr` is used to specify that a variable is a constant pointer.",
              "`constexpr` is used to indicate that an expression can be evaluated at compile-time, making it suitable for use in constant expressions.",
              "It is a keyword used to create asynchronous functions."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a58214addebf2b9faf27d972",
            "question": "What is a template metaprogram in C++?\n- Ref(https://www.geeksforgeeks.org/template-metaprogramming-in-c/)",
            "answer": "A template metaprogram is a compile-time computation, where templates and template specialization are used to perform computations at compile time.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "A template metaprogram is a compile-time computation, where templates and template specialization are used to perform computations at compile time."
            ],
            "options": [
              "A template metaprogram is a high-level programming language.",
              "It refers to metaprogramming that uses templates in C++.",
              "It's a type of user interface design pattern.",
              "A template metaprogram is a compile-time computation, where templates and template specialization are used to perform computations at compile time."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "90e31e1dbeb315e76a81ca3a",
            "question": "Identify the correct example for a pre-increment operator.",
            "answer": "++i",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["++i"],
            "options": ["++i", "i++", "--i", "+i"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2174fb6a180d8f76dc6fbf9a",
            "question": "What will be the output of following code?\n```cpp\n{% raw %}\nint matrix[3][3] = {{1, 2, 3},{4, 5, 6},{7, 8, 9}};\nfor(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n        int a = matrix[i][j];\n        matrix[i][j] = matrix[j][i];\n        matrix[j][i] = a;\n    }\n}\n{% endraw %}\n```",
            "answer": "Same matrix",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Same matrix"],
            "options": [
              "Transpose of matrix",
              "Same matrix",
              "Mirror image of Matrix",
              "Inverted matrix"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3d1d630369a9837476c211c2",
            "question": "What is a race condition in C++?",
            "answer": "A condition where multiple threads access shared data concurrently, and the outcome depends on the timing of their execution",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/language/memory_model)",
            "hint": null,
            "correctAnswer": [
              "A condition where multiple threads access shared data concurrently, and the outcome depends on the timing of their execution"
            ],
            "options": [
              "A condition where the program runs faster than expected",
              "A condition where multiple threads access shared data concurrently, and the outcome depends on the timing of their execution",
              "A condition where two threads compete for CPU time",
              "A condition where a loop executes too quickly and needs to be slowed down"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a47ef4dddd9e1f4ce0caba56",
            "question": "Consider the following code that has a race condition. What is the correct way to fix it?\n```cpp\n#include <thread>\n#include <vector>\nint counter = 0;\nvoid incrementCounter() {\n    for(int i = 0; i < 1000; i++) {\n        counter++;\n    }\n}\nint main() {\n    std::vector<std::thread> threads;\n    for(int i = 0; i < 10; i++) {\n        threads.push_back(std::thread(incrementCounter));\n    }\n    for(auto& t : threads) {\n        t.join();\n    }\n    return 0;\n}\n```",
            "answer": "Use `std::mutex` to lock/unlock around `counter++` in the critical section",
            "explanation": "[Reference](https://en.cppreference.com/w/cpp/thread/mutex)",
            "hint": null,
            "correctAnswer": [
              "Use `std::mutex` to lock/unlock around `counter++` in the critical section"
            ],
            "options": [
              "Add `volatile` keyword: `volatile int counter = 0;`",
              "Use `std::mutex` to lock/unlock around `counter++` in the critical section",
              "Use `std::this_thread::sleep_for()` to delay each increment",
              "Change `counter++` to `++counter` for atomic operation"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a7f7ed656a36df336d05b0b8",
            "question": "Quel est le but de `std::move` en C++11 ?",
            "answer": "Convertir un objet en référence rvalue, permettant la sémantique de déplacement",
            "explanation": "**Explication :**\n`std::move` est un cast qui produit une référence rvalue à son argument, permettant aux ressources d'être déplacées plutôt que copiées. Il ne déplace rien lui-même, mais permet l'appel des constructeurs de déplacement et des opérateurs d'affectation de déplacement.\n[Référence](https://en.cppreference.com/w/cpp/utility/move)",
            "hint": null,
            "correctAnswer": [
              "Convertir un objet en référence rvalue, permettant la sémantique de déplacement"
            ],
            "options": [
              "Copier un objet vers un nouvel emplacement",
              "Convertir un objet en référence rvalue, permettant la sémantique de déplacement",
              "Déplacer physiquement la mémoire d'une adresse à une autre",
              "Supprimer un objet et en créer un nouveau"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8cc4f4a63d764473f71f15fe",
            "question": "Quel est le résultat de ce code ?\n```cpp\n#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v1 = {1, 2, 3};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v1.size() << \" \" << v2.size();\n    return 0;\n}\n```",
            "answer": "0 3",
            "explanation": "**Explication :**\nAprès `std::move(v1)`, v1 est dans un état valide mais non spécifié. Typiquement, il devient vide (taille 0) et v2 prend possession des éléments.\n[Référence](https://en.cppreference.com/w/cpp/utility/move)",
            "hint": null,
            "correctAnswer": ["0 3"],
            "options": ["3 3", "0 3", "3 0", "Erreur de compilation"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "20852badf79b8f82e7a903fb",
            "question": "Qu'est-ce qu'une expression lambda en C++ ?",
            "answer": "Un objet fonction anonyme qui peut capturer des variables de sa portée englobante",
            "explanation": "**Explication :**\nLes expressions lambda, introduites en C++11, permettent d'écrire des fonctions anonymes en ligne. Elles peuvent capturer des variables de la portée environnante et sont souvent utilisées avec les algorithmes STL.\n[Référence](https://en.cppreference.com/w/cpp/language/lambda)",
            "hint": null,
            "correctAnswer": [
              "Un objet fonction anonyme qui peut capturer des variables de sa portée englobante"
            ],
            "options": [
              "Une fonction mathématique",
              "Un objet fonction anonyme qui peut capturer des variables de sa portée englobante",
              "Une fonction template",
              "Une définition de macro"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9a8e55b7901ef47df0a6c0fd",
            "question": "Que fait le mot-clé `auto` en C++11 ?",
            "answer": "Déduit automatiquement le type d'une variable à partir de son initialiseur",
            "explanation": "**Explication :**\nLe mot-clé `auto` en C++11 permet la déduction automatique du type à partir de l'initialiseur, rendant le code plus concis et plus facile à maintenir.\n[Référence](https://en.cppreference.com/w/cpp/language/auto)",
            "hint": null,
            "correctAnswer": [
              "Déduit automatiquement le type d'une variable à partir de son initialiseur"
            ],
            "options": [
              "Donne à une variable une durée de stockage automatique",
              "Déduit automatiquement le type d'une variable à partir de son initialiseur",
              "Rend une fonction inline",
              "Déclare une variable globale"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3340cdd907a86ebe6ba515e3",
            "question": "Quelle est la différence entre `std::unique_ptr` et `std::shared_ptr` ?",
            "answer": "unique_ptr a une propriété exclusive, shared_ptr permet plusieurs propriétaires",
            "explanation": "**Explication :**\n`std::unique_ptr` fournit une propriété exclusive - un seul unique_ptr peut posséder une ressource. `std::shared_ptr` utilise le comptage de références pour permettre à plusieurs shared_ptrs de posséder la même ressource.\n[Référence](https://en.cppreference.com/w/cpp/memory/unique_ptr)",
            "hint": null,
            "correctAnswer": [
              "unique_ptr a une propriété exclusive, shared_ptr permet plusieurs propriétaires"
            ],
            "options": [
              "unique_ptr a une propriété exclusive, shared_ptr permet plusieurs propriétaires",
              "unique_ptr est plus rapide mais moins sûr",
              "shared_ptr ne peut être utilisé qu'avec des classes",
              "Il n'y a pas de différence"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "743af7080ffd126dec0ad60f",
            "question": "Qu'est-ce que RAII en C++ ?",
            "answer": "Resource Acquisition Is Initialization (L'acquisition de ressource est l'initialisation)",
            "explanation": "**Explication :**\nRAII est un idiome de programmation C++ où l'acquisition de ressource est liée à la durée de vie de l'objet. Les ressources sont acquises dans les constructeurs et libérées dans les destructeurs, garantissant un nettoyage approprié.\n[Référence](https://en.cppreference.com/w/cpp/language/raii)",
            "hint": null,
            "correctAnswer": [
              "Resource Acquisition Is Initialization (L'acquisition de ressource est l'initialisation)"
            ],
            "options": [
              "Random Access Iterator Interface",
              "Resource Acquisition Is Initialization (L'acquisition de ressource est l'initialisation)",
              "Recursive Algorithm Implementation Interface",
              "Runtime Allocation and Initialization"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3ef8bfe122a34508fdaaa5c1",
            "question": "Quel est le résultat de ce code ?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    auto lambda = [x]() mutable { x += 10; return x; };\n    std::cout << lambda() << \" \" << x;\n    return 0;\n}\n```",
            "answer": "15 5",
            "explanation": "**Explication :**\nLa lambda capture x par valeur. Le mot-clé `mutable` permet de modifier la copie capturée. Le x original reste inchangé.\n[Référence](https://en.cppreference.com/w/cpp/language/lambda)",
            "hint": null,
            "correctAnswer": ["15 5"],
            "options": ["5 5", "15 5", "15 15", "5 15"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3bd8308d6abf53c24f318627",
            "question": "Qu'est-ce que `constexpr` en C++11 ?",
            "answer": "Spécifie qu'une fonction ou variable peut être évaluée au moment de la compilation",
            "explanation": "**Explication :**\n`constexpr` indique qu'une valeur ou fonction peut être évaluée au moment de la compilation, permettant le calcul et l'optimisation à la compilation.\n[Référence](https://en.cppreference.com/w/cpp/language/constexpr)",
            "hint": null,
            "correctAnswer": [
              "Spécifie qu'une fonction ou variable peut être évaluée au moment de la compilation"
            ],
            "options": [
              "Une expression constante qui ne peut être utilisée qu'avec des entiers",
              "Spécifie qu'une fonction ou variable peut être évaluée au moment de la compilation",
              "Une macro pour définir des constantes",
              "Un mot-clé pour déclarer des pointeurs const"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7d46d8e9363851e014c6972d",
            "question": "Quel est le but de `std::forward` ?",
            "answer": "Préserver la catégorie de valeur (lvalue/rvalue) d'un argument transmis",
            "explanation": "**Explication :**\n`std::forward` est utilisé dans les fonctions template pour transmettre parfaitement les arguments tout en préservant leur catégorie de valeur, essentiel pour implémenter le perfect forwarding.\n[Référence](https://en.cppreference.com/w/cpp/utility/forward)",
            "hint": null,
            "correctAnswer": [
              "Préserver la catégorie de valeur (lvalue/rvalue) d'un argument transmis"
            ],
            "options": [
              "Déplacer un objet vers l'avant en mémoire",
              "Préserver la catégorie de valeur (lvalue/rvalue) d'un argument transmis",
              "Itérer vers l'avant dans un conteneur",
              "Déclarer une déclaration forward"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "01d25de6c5cd691c1204ea7f",
            "question": "Qu'est-ce qu'un template variadique ?",
            "answer": "Un template qui accepte un nombre variable de paramètres template",
            "explanation": "**Explication :**\nLes templates variadiques, introduits en C++11, permettent aux templates d'accepter un nombre quelconque d'arguments template, permettant une programmation générique flexible.\n[Référence](https://en.cppreference.com/w/cpp/language/parameter_pack)",
            "hint": null,
            "correctAnswer": ["Un template qui accepte un nombre variable de paramètres template"],
            "options": [
              "Un template avec des types de retour variables",
              "Un template qui accepte un nombre variable de paramètres template",
              "Un template qui peut être instancié plusieurs fois",
              "Un template avec des paramètres optionnels"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f27287fe8acfaf20bca4dde4",
            "question": "Que représente `nullptr` ?",
            "answer": "Une constante de pointeur nul avec le type std::nullptr_t",
            "explanation": "**Explication :**\n`nullptr` est un mot-clé introduit en C++11 qui représente un pointeur nul. Il est sûr au niveau du type contrairement à NULL ou 0.\n[Référence](https://en.cppreference.com/w/cpp/language/nullptr)",
            "hint": null,
            "correctAnswer": ["Une constante de pointeur nul avec le type std::nullptr_t"],
            "options": [
              "Un caractère nul",
              "Une constante de pointeur nul avec le type std::nullptr_t",
              "Une chaîne vide",
              "Une valeur zéro"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "bc337065470a06dfb063d629",
            "question": "Quel est le résultat de ce code ?\n```cpp\n#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> p1 = std::make_shared<int>(42);\n    std::shared_ptr<int> p2 = p1;\n    std::cout << p1.use_count();\n    return 0;\n}\n```",
            "answer": "2",
            "explanation": "**Explication :**\np1 et p2 partagent la propriété du même entier, donc le compteur de références est 2.\n[Référence](https://en.cppreference.com/w/cpp/memory/shared_ptr)",
            "hint": null,
            "correctAnswer": ["2"],
            "options": ["1", "2", "42", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "30b310173a11072c289a5a6c",
            "question": "Qu'est-ce que `std::optional` en C++17 ?",
            "answer": "Un wrapper qui peut ou non contenir une valeur",
            "explanation": "**Explication :**\n`std::optional` est une classe template qui représente une valeur optionnelle - elle contient soit une valeur soit est vide, fournissant un moyen sûr au niveau du type pour représenter \"aucune valeur\".\n[Référence](https://en.cppreference.com/w/cpp/utility/optional)",
            "hint": null,
            "correctAnswer": ["Un wrapper qui peut ou non contenir une valeur"],
            "options": [
              "Un paramètre optionnel dans une fonction",
              "Un wrapper qui peut ou non contenir une valeur",
              "Un template pour la compilation optionnelle",
              "Un mot-clé pour les types optionnels"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2fb2fdb28ed5884ab5196467",
            "question": "Qu'est-ce que la liaison structurée en C++17 ?\n```cpp\nauto [x, y, z] = std::make_tuple(1, 2, 3);\n```",
            "answer": "Une fonctionnalité qui décompresse des objets de type tuple en variables individuelles",
            "explanation": "**Explication :**\nLes liaisons structurées permettent de décomposer les objets en leurs éléments constitutifs, rendant le code plus lisible lors du travail avec des tuples, paires ou structures.\n[Référence](https://en.cppreference.com/w/cpp/language/structured_binding)",
            "hint": null,
            "correctAnswer": [
              "Une fonctionnalité qui décompresse des objets de type tuple en variables individuelles"
            ],
            "options": [
              "Un moyen de lier des structures ensemble",
              "Une fonctionnalité qui décompresse des objets de type tuple en variables individuelles",
              "Une méthode pour créer des données structurées",
              "Une liaison pour les membres de struct"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b067f55187b5e7c7bd24a8d4",
            "question": "Qu'est-ce que `std::string_view` en C++17 ?",
            "answer": "Une référence non propriétaire à une chaîne qui évite la copie",
            "explanation": "**Explication :**\n`std::string_view` fournit une référence légère et non propriétaire à une chaîne, évitant les copies inutiles et améliorant les performances.\n[Référence](https://en.cppreference.com/w/cpp/string/basic_string_view)",
            "hint": null,
            "correctAnswer": ["Une référence non propriétaire à une chaîne qui évite la copie"],
            "options": [
              "Une vue d'une chaîne dans une interface graphique",
              "Une référence non propriétaire à une chaîne qui évite la copie",
              "Une chaîne qui ne peut être que visualisée, pas modifiée",
              "Une classe de vue pour afficher des chaînes"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "53f2240bfa18c96ef1070445",
            "question": "Que sont les concepts en C++20 ?",
            "answer": "Des ensembles nommés d'exigences pour les paramètres template",
            "explanation": "**Explication :**\nLes concepts sont une fonctionnalité de C++20 qui permet de spécifier des contraintes sur les paramètres template, rendant le code template plus lisible et fournissant de meilleurs messages d'erreur.\n[Référence](https://en.cppreference.com/w/cpp/language/constraints)",
            "hint": null,
            "correctAnswer": ["Des ensembles nommés d'exigences pour les paramètres template"],
            "options": [
              "Des idées abstraites en programmation",
              "Des ensembles nommés d'exigences pour les paramètres template",
              "Des modèles de conception conceptuels",
              "Des commentaires de documentation"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "29885665dde66717df6fcd39",
            "question": "Qu'est-ce que l'opérateur de comparaison à trois voies (<=>) en C++20 ?",
            "answer": "Un opérateur qui retourne des informations d'ordre (inférieur, égal, supérieur)",
            "explanation": "**Explication :**\nL'opérateur vaisseau spatial (<=>) effectue une comparaison à trois voies et retourne une catégorie d'ordre, simplifiant les définitions d'opérateurs de comparaison.\n[Référence](https://en.cppreference.com/w/cpp/language/operator_comparison)",
            "hint": null,
            "correctAnswer": [
              "Un opérateur qui retourne des informations d'ordre (inférieur, égal, supérieur)"
            ],
            "options": [
              "Une comparaison de trois valeurs",
              "Un opérateur qui retourne des informations d'ordre (inférieur, égal, supérieur)",
              "Trois opérateurs de comparaison séparés",
              "Une comparaison ternaire"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a91c1c25286e36ad99a6dea4",
            "question": "Qu'est-ce que `std::span` en C++20 ?",
            "answer": "Une vue non propriétaire sur une séquence contiguë d'objets",
            "explanation": "**Explication :**\n`std::span` fournit une vue sur une séquence contiguë d'objets sans les posséder, utile pour passer des données de type tableau sans copie.\n[Référence](https://en.cppreference.com/w/cpp/container/span)",
            "hint": null,
            "correctAnswer": ["Une vue non propriétaire sur une séquence contiguë d'objets"],
            "options": [
              "Une mesure de temps",
              "Une vue non propriétaire sur une séquence contiguë d'objets",
              "Une structure de données d'arbre couvrant",
              "Un élément span en HTML"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7313983624a4c34bbc90ecf5",
            "question": "Quel est le résultat de ce code ?\n```cpp\n#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v = {1, 2, 3, 4, 5};\n    for (auto& x : v) {\n        x *= 2;\n    }\n    std::cout << v[2];\n    return 0;\n}\n```",
            "answer": "6",
            "explanation": "**Explication :**\nLa boucle for basée sur la plage avec `auto&` modifie chaque élément sur place. v[2] (originellement 3) devient 6.\n[Référence](https://en.cppreference.com/w/cpp/language/range-for)",
            "hint": null,
            "correctAnswer": ["6"],
            "options": ["3", "6", "2", "12"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1920d1d596a49f28701114ae",
            "question": "Qu'est-ce que `std::variant` en C++17 ?",
            "answer": "Une union sûre au niveau du type qui peut contenir un de plusieurs types",
            "explanation": "**Explication :**\n`std::variant` est une union sûre au niveau du type qui peut contenir une valeur de l'un des plusieurs types spécifiés, fournissant une alternative plus sûre aux unions C.\n[Référence](https://en.cppreference.com/w/cpp/utility/variant)",
            "hint": null,
            "correctAnswer": [
              "Une union sûre au niveau du type qui peut contenir un de plusieurs types"
            ],
            "options": [
              "Une variable qui peut varier",
              "Une union sûre au niveau du type qui peut contenir un de plusieurs types",
              "Une variante d'une classe",
              "Un template de variable"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c56f13c0d3a6887dd23ab76b",
            "question": "Qu'est-ce que `std::any` en C++17 ?",
            "answer": "Un conteneur sûr au niveau du type pour des valeurs uniques de n'importe quel type",
            "explanation": "**Explication :**\n`std::any` peut stocker une valeur unique de n'importe quel type copiable par construction, fournissant un stockage sûr au niveau du type avec vérification de type à l'exécution.\n[Référence](https://en.cppreference.com/w/cpp/utility/any)",
            "hint": null,
            "correctAnswer": [
              "Un conteneur sûr au niveau du type pour des valeurs uniques de n'importe quel type"
            ],
            "options": [
              "N'importe quel type de variable",
              "Un conteneur sûr au niveau du type pour des valeurs uniques de n'importe quel type",
              "Un type générique",
              "Un type optionnel"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "31c8f4faa8dffe9af67eb063",
            "question": "Quelle est la différence entre `std::array` et les tableaux de style C ?",
            "answer": "std::array connaît sa taille et fournit des fonctions membres",
            "explanation": "**Explication :**\n`std::array` est un conteneur qui encapsule des tableaux de taille fixe, fournissant des informations sur la taille et l'interface de conteneur STL tout en maintenant les performances des tableaux de style C.\n[Référence](https://en.cppreference.com/w/cpp/container/array)",
            "hint": null,
            "correctAnswer": ["std::array connaît sa taille et fournit des fonctions membres"],
            "options": [
              "std::array connaît sa taille et fournit des fonctions membres",
              "std::array est plus lent",
              "Les tableaux de style C sont plus sûrs",
              "Il n'y a pas de différence"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1e69ca48a48169f45273a5b3",
            "question": "Qu'est-ce que le perfect forwarding ?",
            "answer": "La préservation de la catégorie de valeur des arguments lors de leur transmission à une autre fonction",
            "explanation": "**Explication :**\nLe perfect forwarding utilise `std::forward` et des références universelles pour passer des arguments à une autre fonction tout en préservant leur catégorie de valeur (lvalue ou rvalue).\n[Référence](https://en.cppreference.com/w/cpp/utility/forward)",
            "hint": null,
            "correctAnswer": [
              "La préservation de la catégorie de valeur des arguments lors de leur transmission à une autre fonction"
            ],
            "options": [
              "La transmission sans erreurs",
              "La préservation de la catégorie de valeur des arguments lors de leur transmission à une autre fonction",
              "Le passage rapide de paramètres",
              "La déclaration forward de fonctions"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e5af42b9f67144aea585ac89",
            "question": "Quel est le résultat de ce code ?\n```cpp\n#include <iostream>\ntemplate<typename T>\nvoid func(T&& x) {\n    std::cout << std::is_lvalue_reference<T>::value;\n}\nint main() {\n    int a = 5;\n    func(a);\n    return 0;\n}\n```",
            "answer": "1",
            "explanation": "**Explication :**\nLorsqu'une lvalue est passée à une référence universelle, T est déduit comme une référence lvalue, donc `std::is_lvalue_reference<T>::value` est vrai (1).\n[Référence](https://en.cppreference.com/w/cpp/language/reference)",
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["1", "0", "5", "Erreur de compilation"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ba9a67abc191114092a9235f",
            "question": "Qu'est-ce que `std::invoke` en C++17 ?",
            "answer": "Un utilitaire pour appeler n'importe quel objet appelable avec des arguments donnés",
            "explanation": "**Explication :**\n`std::invoke` fournit un moyen uniforme d'appeler n'importe quel appelable (fonction, pointeur de fonction, fonction membre, foncteur) avec des arguments.\n[Référence](https://en.cppreference.com/w/cpp/utility/functional/invoke)",
            "hint": null,
            "correctAnswer": [
              "Un utilitaire pour appeler n'importe quel objet appelable avec des arguments donnés"
            ],
            "options": [
              "Une fonction pour invoquer des programmes",
              "Un utilitaire pour appeler n'importe quel objet appelable avec des arguments donnés",
              "Un opérateur d'invocation de méthode",
              "Un invocateur pour les constructeurs"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "043beff36fc581c66c63241d",
            "question": "Qu'est-ce que `if constexpr` en C++17 ?",
            "answer": "Une condition à la compilation qui élimine les branches à la compilation",
            "explanation": "**Explication :**\n`if constexpr` évalue la condition à la compilation et n'instancie que la branche prise, utile dans la métaprogrammation template.\n[Référence](https://en.cppreference.com/w/cpp/language/if)",
            "hint": null,
            "correctAnswer": [
              "Une condition à la compilation qui élimine les branches à la compilation"
            ],
            "options": [
              "Une instruction if constante",
              "Une condition à la compilation qui élimine les branches à la compilation",
              "Une instruction if qui doit être constante",
              "Une fonction constexpr avec if"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "599382629f503e2c80ecbcf8",
            "question": "Qu'est-ce qu'une expression de pliage en C++17 ?",
            "answer": "Un moyen d'appliquer un opérateur binaire à tous les éléments d'un paquet de paramètres",
            "explanation": "**Explication :**\nLes expressions de pliage fournissent une syntaxe concise pour appliquer des opérateurs binaires aux paquets de paramètres dans les templates variadiques.\n[Référence](https://en.cppreference.com/w/cpp/language/fold)",
            "hint": null,
            "correctAnswer": [
              "Un moyen d'appliquer un opérateur binaire à tous les éléments d'un paquet de paramètres"
            ],
            "options": [
              "Une expression qui plie le code",
              "Un moyen d'appliquer un opérateur binaire à tous les éléments d'un paquet de paramètres",
              "Un algorithme de pliage",
              "Une expression pour plier des conteneurs"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7bef424f015945cb9f2e32a1",
            "question": "Quel est le résultat de ce code ?\n```cpp\n#include <iostream>\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int* p = arr;\n    std::cout << *(p + 3);\n    return 0;\n}\n```",
            "answer": "4",
            "explanation": "**Explication :**\nArithmétique de pointeur : p + 3 pointe vers le 4ème élément (indice 3), qui est 4.\n[Référence](https://en.cppreference.com/w/cpp/language/operator_arithmetic)",
            "hint": null,
            "correctAnswer": ["4"],
            "options": ["1", "2", "3", "4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "22ff05cdc46f01b2595e0685",
            "question": "Qu'est-ce que `std::filesystem` en C++17 ?",
            "answer": "Une bibliothèque pour effectuer des opérations sur les systèmes de fichiers et les chemins",
            "explanation": "**Explication :**\n`std::filesystem` fournit des facilités pour effectuer des opérations sur les systèmes de fichiers et leurs composants, tels que les chemins, fichiers réguliers et répertoires.\n[Référence](https://en.cppreference.com/w/cpp/filesystem)",
            "hint": null,
            "correctAnswer": [
              "Une bibliothèque pour effectuer des opérations sur les systèmes de fichiers et les chemins"
            ],
            "options": [
              "Un pilote de système de fichiers",
              "Une bibliothèque pour effectuer des opérations sur les systèmes de fichiers et les chemins",
              "Un système de fichiers virtuel",
              "Une classe de flux de fichiers"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9276cb23580621c9a2de695d",
            "question": "À quoi sert `std::atomic` ?",
            "answer": "Aux opérations thread-safe sur des variables partagées sans verrous",
            "explanation": "**Explication :**\n`std::atomic` fournit des opérations atomiques sur des variables partagées, garantissant un accès thread-safe sans verrouillage explicite.\n[Référence](https://en.cppreference.com/w/cpp/atomic/atomic)",
            "hint": null,
            "correctAnswer": [
              "Aux opérations thread-safe sur des variables partagées sans verrous"
            ],
            "options": [
              "Aux calculs d'énergie atomique",
              "Aux opérations thread-safe sur des variables partagées sans verrous",
              "Aux types de données atomiques",
              "Aux opérations indivisibles sur les atomes"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ad9ca1d929e6f35fcb46e66e",
            "question": "Quelle est la différence entre `std::mutex` et `std::recursive_mutex` ?",
            "answer": "recursive_mutex peut être verrouillé plusieurs fois par le même thread",
            "explanation": "**Explication :**\n`std::recursive_mutex` permet au même thread de le verrouiller plusieurs fois, tandis que `std::mutex` provoquerait un interblocage si le même thread essayait de le verrouiller deux fois.\n[Référence](https://en.cppreference.com/w/cpp/thread/recursive_mutex)",
            "hint": null,
            "correctAnswer": [
              "recursive_mutex peut être verrouillé plusieurs fois par le même thread"
            ],
            "options": [
              "recursive_mutex peut être verrouillé plusieurs fois par le même thread",
              "mutex est plus rapide",
              "recursive_mutex est déprécié",
              "Il n'y a pas de différence"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "02fd0a8486418dac44516cd5",
            "question": "Qu'est-ce que `std::future` en C++11 ?",
            "answer": "Un objet qui fournit l'accès au résultat d'une opération asynchrone",
            "explanation": "**Explication :**\n`std::future` est utilisé pour récupérer le résultat d'une opération asynchrone démarrée avec `std::async` ou `std::promise`.\n[Référence](https://en.cppreference.com/w/cpp/thread/future)",
            "hint": null,
            "correctAnswer": [
              "Un objet qui fournit l'accès au résultat d'une opération asynchrone"
            ],
            "options": [
              "Une version future de C++",
              "Un objet qui fournit l'accès au résultat d'une opération asynchrone",
              "Une classe basée sur le temps",
              "Une déclaration future"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f72f6fa000b68d215ff59af6",
            "question": "Quel est le résultat de ce code ?\n```cpp\n#include <iostream>\nclass Base {\npublic:\n    virtual void show() { std::cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void show() override { std::cout << \"Derived\"; }\n};\nint main() {\n    Base* b = new Derived();\n    b->show();\n    delete b;\n    return 0;\n}\n```",
            "answer": "Derived",
            "explanation": "**Explication :**\nEn raison du polymorphisme de fonction virtuelle, la méthode show() de la classe Derived est appelée même si le pointeur est de type Base\\*.\n[Référence](https://en.cppreference.com/w/cpp/language/virtual)",
            "hint": null,
            "correctAnswer": ["Derived"],
            "options": ["Base", "Derived", "Erreur de compilation", "Comportement indéfini"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6e8ef083cddebfea8480f56e",
            "question": "À quoi sert `std::enable_if` ?",
            "answer": "Pour l'instanciation conditionnelle de template basée sur SFINAE",
            "explanation": "**Explication :**\n`std::enable_if` est utilisé pour SFINAE (Substitution Failure Is Not An Error) pour activer ou désactiver conditionnellement les spécialisations de template.\n[Référence](https://en.cppreference.com/w/cpp/types/enable_if)",
            "hint": null,
            "correctAnswer": ["Pour l'instanciation conditionnelle de template basée sur SFINAE"],
            "options": [
              "À activer les instructions if",
              "Pour l'instanciation conditionnelle de template basée sur SFINAE",
              "À activer des fonctionnalités",
              "À vérifier si quelque chose est activé"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e20761c381d7c00e67d87010",
            "question": "Qu'est-ce que `std::tuple` en C++11 ?",
            "answer": "Une collection de taille fixe de valeurs hétérogènes",
            "explanation": "**Explication :**\n`std::tuple` est une collection de taille fixe qui peut contenir des éléments de différents types, généralisant `std::pair` à n'importe quel nombre d'éléments.\n[Référence](https://en.cppreference.com/w/cpp/utility/tuple)",
            "hint": null,
            "correctAnswer": ["Une collection de taille fixe de valeurs hétérogènes"],
            "options": [
              "Une paire de deux éléments",
              "Une collection de taille fixe de valeurs hétérogènes",
              "Un triplet de valeurs",
              "Un tuple en mathématiques"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "03bf9bf46870462f53fb1a68",
            "question": "Quel est le résultat de ce code ?\n```cpp\n#include <iostream>\nint main() {\n    int x = 10;\n    int& ref = x;\n    ref = 20;\n    std::cout << x;\n    return 0;\n}\n```",
            "answer": "20",
            "explanation": "**Explication :**\nref est une référence à x. Modifier ref modifie directement x, donc x devient 20.\n[Référence](https://en.cppreference.com/w/cpp/language/reference)",
            "hint": null,
            "correctAnswer": ["20"],
            "options": ["10", "20", "Erreur de compilation", "Indéfini"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d4b1005faf95eeaef47d5791",
            "question": "À quoi sert `std::chrono` ?",
            "answer": "Aux utilitaires de temps incluant horloges, points temporels et durées",
            "explanation": "**Explication :**\n`std::chrono` est une bibliothèque pour les opérations liées au temps, fournissant des horloges, points temporels et durées avec sécurité de type.\n[Référence](https://en.cppreference.com/w/cpp/chrono)",
            "hint": null,
            "correctAnswer": [
              "Aux utilitaires de temps incluant horloges, points temporels et durées"
            ],
            "options": [
              "À l'ordonnancement chronologique",
              "Aux utilitaires de temps incluant horloges, points temporels et durées",
              "Aux fonctions de chronomètre",
              "À la gestion des maladies chroniques"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1d5ba0bb3b2dc444c45945c9",
            "question": "Qu'est-ce que `std::regex` en C++11 ?",
            "answer": "Une bibliothèque pour la correspondance de motifs d'expressions régulières",
            "explanation": "**Explication :**\n`std::regex` fournit un support d'expressions régulières pour la correspondance de motifs et le traitement de texte en C++.\n[Référence](https://en.cppreference.com/w/cpp/regex)",
            "hint": null,
            "correctAnswer": [
              "Une bibliothèque pour la correspondance de motifs d'expressions régulières"
            ],
            "options": [
              "Un moteur d'expression régulière",
              "Une bibliothèque pour la correspondance de motifs d'expressions régulières",
              "Un outil de remplacement de texte",
              "Un formateur de chaînes"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b2b6820379de6b0abfdcf278",
            "question": "Qu'est-ce que `std::initializer_list` ?",
            "answer": "Un objet proxy léger pour accéder aux tableaux de const T",
            "explanation": "**Explication :**\n`std::initializer_list` permet aux fonctions d'accepter des listes de valeurs entre accolades, permettant une syntaxe d'initialisation uniforme.\n[Référence](https://en.cppreference.com/w/cpp/utility/initializer_list)",
            "hint": null,
            "correctAnswer": ["Un objet proxy léger pour accéder aux tableaux de const T"],
            "options": [
              "Une liste d'initialisateurs",
              "Un objet proxy léger pour accéder aux tableaux de const T",
              "Une fonction d'initialisation",
              "Un constructeur de liste"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "08c0d27537471963776418bd",
            "question": "Quel est le résultat de ce code ?\n```cpp\n#include <iostream>\nint main() {\n    const int x = 10;\n    int* p = const_cast<int*>(&x);\n    *p = 20;\n    std::cout << x;\n    return 0;\n}\n```",
            "answer": "10 (comportement indéfini)",
            "explanation": "**Explication :**\nCeci est un comportement indéfini. Modifier un objet const via const_cast conduit à des résultats imprévisibles. Le compilateur peut optimiser en se basant sur l'hypothèse const.\n[Référence](https://en.cppreference.com/w/cpp/language/const_cast)",
            "hint": null,
            "correctAnswer": ["10 (comportement indéfini)"],
            "options": ["10 (comportement indéfini)", "20", "Erreur de compilation", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "199614f8889bcc1f50d686d8",
            "question": "Qu'est-ce que `std::function` en C++11 ?",
            "answer": "Un wrapper de fonction polymorphe à usage général",
            "explanation": "**Explication :**\n`std::function` est un wrapper avec effacement de type qui peut stocker n'importe quel objet appelable (fonction, lambda, foncteur) avec une signature spécifique.\n[Référence](https://en.cppreference.com/w/cpp/utility/functional/function)",
            "hint": null,
            "correctAnswer": ["Un wrapper de fonction polymorphe à usage général"],
            "options": [
              "Une déclaration de fonction",
              "Un wrapper de fonction polymorphe à usage général",
              "Un pointeur de fonction",
              "Une bibliothèque de programmation fonctionnelle"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "51adabf9b1abd8e2d3af8cc7",
            "question": "À quoi sert `std::bind` ?",
            "answer": "À créer un nouvel appelable en liant des arguments à une fonction",
            "explanation": "**Explication :**\n`std::bind` crée un nouvel objet fonction en liant certains arguments à une fonction, utile pour l'application partielle de fonction.\n[Référence](https://en.cppreference.com/w/cpp/utility/functional/bind)",
            "hint": null,
            "correctAnswer": ["À créer un nouvel appelable en liant des arguments à une fonction"],
            "options": [
              "À lier des variables ensemble",
              "À créer un nouvel appelable en liant des arguments à une fonction",
              "À lier des classes",
              "À lier de la mémoire"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "faa8183ee2de6ff43598e690",
            "question": "Sur quoi est basé `std::unordered_map` ?",
            "answer": "Table de hachage",
            "explanation": "**Explication :**\n`std::unordered_map` est implémenté en utilisant une table de hachage, fournissant un temps de recherche moyen O(1) comparé à O(log n) pour `std::map`.\n[Référence](https://en.cppreference.com/w/cpp/container/unordered_map)",
            "hint": null,
            "correctAnswer": ["Table de hachage"],
            "options": [
              "Arbre de recherche binaire",
              "Table de hachage",
              "Liste chaînée",
              "Tableau"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cbb35cb554718d976e1a38ee",
            "question": "Quel est le résultat de ce code ?\n```cpp\n#include <iostream>\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    std::cout << sizeof(arr) / sizeof(arr[0]);\n    return 0;\n}\n```",
            "answer": "5",
            "explanation": "**Explication :**\nsizeof(arr) donne le nombre total d'octets, sizeof(arr[0]) donne les octets par élément. La division donne le nombre d'éléments : 5.\n[Référence](https://en.cppreference.com/w/cpp/language/sizeof)",
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["4", "5", "20", "1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fc5692d64a9053ad02ecc4ec",
            "question": "Qu'est-ce que `std::make_unique` en C++14 ?",
            "answer": "Une fonction pour créer des objets std::unique_ptr",
            "explanation": "**Explication :**\n`std::make_unique` est une fonction utilitaire qui crée et retourne un `std::unique_ptr`, fournissant sécurité d'exception et syntaxe plus claire.\n[Référence](https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique)",
            "hint": null,
            "correctAnswer": ["Une fonction pour créer des objets std::unique_ptr"],
            "options": [
              "Un générateur d'identifiant unique",
              "Une fonction pour créer des objets std::unique_ptr",
              "Un vérificateur d'unicité",
              "Un créateur de valeur unique"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9904974700d22f88515bce54",
            "question": "Qu'est-ce que `std::exchange` en C++14 ?",
            "answer": "Remplace une valeur et retourne l'ancienne valeur de manière atomique",
            "explanation": "**Explication :**\n`std::exchange` remplace la valeur d'un objet et retourne son ancienne valeur en une seule opération.\n[Référence](https://en.cppreference.com/w/cpp/utility/exchange)",
            "hint": null,
            "correctAnswer": [
              "Remplace une valeur et retourne l'ancienne valeur de manière atomique"
            ],
            "options": [
              "Un programme d'échange de valeurs",
              "Remplace une valeur et retourne l'ancienne valeur de manière atomique",
              "Un opérateur d'échange",
              "Une fonction de swap"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "33299bc8e967bcbf6811352a",
            "question": "Qu'est-ce que `std::apply` en C++17 ?",
            "answer": "Invoque un appelable avec un tuple d'arguments",
            "explanation": "**Explication :**\n`std::apply` invoque un objet appelable avec un tuple d'arguments, décompressant le tuple en arguments de fonction.\n[Référence](https://en.cppreference.com/w/cpp/utility/apply)",
            "hint": null,
            "correctAnswer": ["Invoque un appelable avec un tuple d'arguments"],
            "options": [
              "Un lanceur d'application",
              "Invoque un appelable avec un tuple d'arguments",
              "Une fonction d'application",
              "Un applicateur de fonction"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e45feeef53d8fc6db248ba52",
            "question": "Quel est le résultat de ce code ?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    int y = ++x + x++;\n    std::cout << y;\n    return 0;\n}\n```",
            "answer": "Comportement indéfini",
            "explanation": "**Explication :**\nModifier x plusieurs fois entre des points de séquence conduit à un comportement indéfini. Le résultat est imprévisible.\n[Référence](https://en.cppreference.com/w/cpp/language/eval_order)",
            "hint": null,
            "correctAnswer": ["Comportement indéfini"],
            "options": ["11", "12", "Comportement indéfini", "13"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "773f179791079e8c960ddfca",
            "question": "Qu'est-ce que `std::decay` en C++11 ?",
            "answer": "Applique les conversions tableau-vers-pointeur, fonction-vers-pointeur et retire les qualificateurs cv",
            "explanation": "**Explication :**\n`std::decay` applique des transformations de type similaires à ce qui se passe lors du passage d'arguments par valeur.\n[Référence](https://en.cppreference.com/w/cpp/types/decay)",
            "hint": null,
            "correctAnswer": [
              "Applique les conversions tableau-vers-pointeur, fonction-vers-pointeur et retire les qualificateurs cv"
            ],
            "options": [
              "Une fonction de décroissance",
              "Applique les conversions tableau-vers-pointeur, fonction-vers-pointeur et retire les qualificateurs cv",
              "Un marqueur de dépréciation",
              "Une constante de décroissance"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b2a0f88073678d0313e2330b",
            "question": "Qu'est-ce que `std::conditional` en C++11 ?",
            "answer": "Choisit un type ou un autre basé sur un booléen à la compilation",
            "explanation": "**Explication :**\n`std::conditional` est une métafonction qui sélectionne l'un de deux types basé sur une condition booléenne à la compilation.\n[Référence](https://en.cppreference.com/w/cpp/types/conditional)",
            "hint": null,
            "correctAnswer": ["Choisit un type ou un autre basé sur un booléen à la compilation"],
            "options": [
              "Une instruction conditionnelle",
              "Choisit un type ou un autre basé sur un booléen à la compilation",
              "Un opérateur conditionnel",
              "Un vérificateur de condition"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8ad968efdd7abf767e234433",
            "question": "À quoi sert `std::is_same` ?",
            "answer": "À vérifier si deux types sont identiques à la compilation",
            "explanation": "**Explication :**\n`std::is_same` est un trait de type qui vérifie si deux types sont identiques à la compilation.\n[Référence](https://en.cppreference.com/w/cpp/types/is_same)",
            "hint": null,
            "correctAnswer": ["À vérifier si deux types sont identiques à la compilation"],
            "options": [
              "À vérifier si les valeurs sont identiques",
              "À vérifier si deux types sont identiques à la compilation",
              "À comparer des objets",
              "À vérifier la similitude"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cce785b4af0dcad2ef4171b2",
            "question": "Quel est le résultat de ce code ?\n```cpp\n#include <iostream>\nint main() {\n    int x = 10;\n    int* p = &x;\n    int** pp = &p;\n    std::cout << **pp;\n    return 0;\n}\n```",
            "answer": "10",
            "explanation": "**Explication :**\npp est un pointeur vers un pointeur. \\*\\*pp déréférence deux fois pour obtenir la valeur de x, qui est 10.\n[Référence](https://en.cppreference.com/w/cpp/language/pointer)",
            "hint": null,
            "correctAnswer": ["10"],
            "options": ["10", "Adresse de x", "Adresse de p", "Erreur de compilation"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "09e527693c660a0bd8d5c317",
            "question": "À quoi sert `std::remove_if` ?",
            "answer": "À supprimer les éléments d'une plage qui satisfont un prédicat",
            "explanation": "**Explication :**\n`std::remove_if` supprime les éléments d'une plage qui satisfont un prédicat donné, utilisé avec erase pour une suppression réelle.\n[Référence](https://en.cppreference.com/w/cpp/algorithm/remove)",
            "hint": null,
            "correctAnswer": ["À supprimer les éléments d'une plage qui satisfont un prédicat"],
            "options": [
              "À supprimer les instructions if",
              "À supprimer les éléments d'une plage qui satisfont un prédicat",
              "À supprimer conditionnellement des fichiers",
              "À supprimer des conditions"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "94ffc4cfde90b43649988971",
            "question": "À quoi sert `std::transform` ?",
            "answer": "À appliquer une fonction à une plage et stocker les résultats dans une autre plage",
            "explanation": "**Explication :**\n`std::transform` applique une fonction donnée à une plage d'éléments et stocke le résultat dans une autre plage.\n[Référence](https://en.cppreference.com/w/cpp/algorithm/transform)",
            "hint": null,
            "correctAnswer": [
              "À appliquer une fonction à une plage et stocker les résultats dans une autre plage"
            ],
            "options": [
              "À transformer le code",
              "À appliquer une fonction à une plage et stocker les résultats dans une autre plage",
              "À transformer les types",
              "À effectuer des transformations"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e88ffae03634793982434507",
            "question": "À quoi sert `std::accumulate` ?",
            "answer": "À calculer la somme ou plier une plage d'éléments",
            "explanation": "**Explication :**\n`std::accumulate` calcule la somme d'une plage d'éléments ou applique une opération binaire pour plier la plage.\n[Référence](https://en.cppreference.com/w/cpp/algorithm/accumulate)",
            "hint": null,
            "correctAnswer": ["À calculer la somme ou plier une plage d'éléments"],
            "options": [
              "À accumuler des erreurs",
              "À calculer la somme ou plier une plage d'éléments",
              "À accumuler des données",
              "À additionner des nombres"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "81521bf9db021d188db0b3bd",
            "question": "Quel est le résultat de ce code ?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    int y = 10;\n    int z = x > y ? x : y;\n    std::cout << z;\n    return 0;\n}\n```",
            "answer": "10",
            "explanation": "**Explication :**\nL'opérateur ternaire vérifie si x > y. Comme c'est faux, z est assigné y, qui est 10.\n[Référence](https://en.cppreference.com/w/cpp/language/operator_other)",
            "hint": null,
            "correctAnswer": ["10"],
            "options": ["5", "10", "1", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3bab0f3c0f1840d3d2b9f83a",
            "question": "À quoi sert `std::copy` ?",
            "answer": "À copier des éléments d'une plage à une autre",
            "explanation": "**Explication :**\n`std::copy` copie les éléments d'une plage source vers une plage de destination.\n[Référence](https://en.cppreference.com/w/cpp/algorithm/copy)",
            "hint": null,
            "correctAnswer": ["À copier des éléments d'une plage à une autre"],
            "options": [
              "À copier des fichiers",
              "À copier des éléments d'une plage à une autre",
              "À dupliquer des objets",
              "À copier de la mémoire"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "38f55db2a1f5e5fa466fedcb",
            "question": "À quoi sert `std::find` ?",
            "answer": "À trouver la première occurrence d'une valeur dans une plage",
            "explanation": "**Explication :**\n`std::find` recherche la première occurrence d'une valeur dans une plage et retourne un itérateur vers celle-ci.\n[Référence](https://en.cppreference.com/w/cpp/algorithm/find)",
            "hint": null,
            "correctAnswer": ["À trouver la première occurrence d'une valeur dans une plage"],
            "options": [
              "À trouver des fichiers",
              "À trouver la première occurrence d'une valeur dans une plage",
              "À rechercher des motifs",
              "À localiser des objets"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b294b798eb7ebff1edd6c8b3",
            "question": "Sur quoi est basé `std::sort` ?",
            "answer": "Introsort (hybride de quicksort, heapsort et tri par insertion)",
            "explanation": "**Explication :**\n`std::sort` utilise typiquement introsort, qui combine quicksort, heapsort et tri par insertion pour des performances optimales.\n[Référence](https://en.cppreference.com/w/cpp/algorithm/sort)",
            "hint": null,
            "correctAnswer": ["Introsort (hybride de quicksort, heapsort et tri par insertion)"],
            "options": [
              "Tri à bulles",
              "Introsort (hybride de quicksort, heapsort et tri par insertion)",
              "Tri fusion uniquement",
              "Tri par sélection"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0ab48bba18e988876eef4882",
            "question": "Quel est le résultat de ce code ?\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\nint main() {\n    std::vector<int> v = {5, 2, 8, 1, 9};\n    std::sort(v.begin(), v.end());\n    std::cout << v[2];\n    return 0;\n}\n```",
            "answer": "5",
            "explanation": "**Explication :**\nAprès le tri, le vecteur devient {1, 2, 5, 8, 9}. v[2] est le troisième élément, qui est 5.\n[Référence](https://en.cppreference.com/w/cpp/algorithm/sort)",
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["8", "2", "5", "1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-fr",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          }
        ]
      },
      {
        "id": "72f5aa2d090f4b90bc8be471-it",
        "language": "it",
        "title": "C++",
        "description": "Seeded from c++/c++-quiz-it.md",
        "questions": [
          {
            "id": "9d0f881446f388ab52665c28",
            "question": "Qual è l'output di questo codice?\n```cpp\nvector<int> v(22);\nbool b = (v[6]);\nprintf(\"%d\", !b);\n```",
            "answer": "1",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["False", "0", "1", "Questo codice ha un errore."],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "86afa483bc87f02aa7208954",
            "question": "Quale delle seguenti è una ragione per cui l'uso di questa riga è considerato una cattiva pratica? (_Alternativa_: Perché l'uso di questa riga è considerato una cattiva pratica?)\n```cpp\nusing namespace std;\n```",
            "answer": "Se il codice utilizza una funzione definita in due librerie diverse con lo stesso prototipo ma possibilmente con implementazioni diverse, ci sarà un errore di compilazione dovuto all'ambiguità.",
            "explanation": "[Riferimento](https://www.geeksforgeeks.org/using-namespace-std-considered-bad-practice/)",
            "hint": null,
            "correctAnswer": [
              "Se il codice utilizza una funzione definita in due librerie diverse con lo stesso prototipo ma possibilmente con implementazioni diverse, ci sarà un errore di compilazione dovuto all'ambiguità."
            ],
            "options": [
              "Il codice compilato è sempre più grande a causa di tutti i simboli importati.",
              "Se il codice utilizza una funzione definita in due librerie diverse con lo stesso prototipo ma possibilmente con implementazioni diverse, ci sarà un errore di compilazione dovuto all'ambiguità.",
              "Include automaticamente tutti i file di intestazione nella libreria standard (cstdint, cstdlib, cstdio, iostream, ecc.).",
              "Fa sì che il compilatore imponga l'inclusione esclusiva dei file di intestazione appartenenti alla libreria standard, generando un errore di compilazione quando viene incluso un file di intestazione diverso."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "92aa4daee51e3bec4f770eb0",
            "question": "Qual è la dimensione minima che una variabile di tipo child_t può occupare in memoria?\n```cpp\ntypedef struct{\n    unsigned int  age    : 4;\n    unsigned char gender : 1;\n    unsigned int  size   : 2;\n}child_t;\n```",
            "answer": "1 byte.",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": ["1 byte."],
            "options": ["7 bit.", "25 byte.", "1 bit.", "1 byte."],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e38302b6df6b0ab460bce250",
            "question": "Quali sono i vettori v1 e v2 dopo aver eseguito il codice?\n```cpp\nstd::vector<int> v1{1,2,3},v2;\nv2=v1;\nv1.push_back(4);\nv2.push_back(5);\n```",
            "answer": "v1:{1,2,3,4}; v2:{1,2,3,5};",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["v1:{1,2,3,4}; v2:{1,2,3,5};"],
            "options": [
              "Errore",
              "v1:{1,2,3,4}; v2:{5};",
              "v1:{1,2,3,4,5}; v2:{1,2,3,4,5};",
              "v1:{1,2,3,4}; v2:{1,2,3,5};"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e617e2a1b8c0f4c75ea40cb2",
            "question": "Quale delle seguenti è un'affermazione vera sulla differenza tra puntatori e iteratori?",
            "answer": "Incrementare un iteratore significa sempre accedere al prossimo elemento nel contenitore (se presente), indipendentemente dal contenitore. Incrementare il puntatore significa puntare al prossimo elemento in memoria, non sempre al prossimo elemento.",
            "explanation": "[Riferimento](https://stackoverflow.com/a/31128162)",
            "hint": null,
            "correctAnswer": [
              "Incrementare un iteratore significa sempre accedere al prossimo elemento nel contenitore (se presente), indipendentemente dal contenitore. Incrementare il puntatore significa puntare al prossimo elemento in memoria, non sempre al prossimo elemento."
            ],
            "options": [
              "Mentre i puntatori sono variabili che contengono indirizzi di memoria, gli iteratori sono funzioni generiche utilizzate per attraversare i contenitori. Questa funzione consente al programmatore di implementare codice di lettura e scrittura mentre il contenitore viene attraversato.",
              "Incrementare un iteratore significa sempre accedere al prossimo elemento nel contenitore (se presente), indipendentemente dal contenitore. Incrementare il puntatore significa puntare al prossimo elemento in memoria, non sempre al prossimo elemento.",
              "I puntatori sono variabili che contengono indirizzi di memoria mentre l'iteratore è un intero senza segno che si riferisce agli offset negli array.",
              "Tutti gli iteratori sono implementati con puntatori quindi tutti gli iteratori sono puntatori ma non tutti i puntatori sono iteratori."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d51b000d2ad1f201659ce2d0",
            "question": "Qual è la memoria occupata da u1?\n```cpp\nunion {\n    uint16_t a;\n    uint32_t b;\n    int8_t c;\n} u1;\n```",
            "answer": "4 byte",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/language/union)",
            "hint": null,
            "correctAnswer": ["4 byte"],
            "options": ["4 byte", "7 byte", "8 byte", "2 byte"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a16aff9b3a9081e8f3dc4988",
            "question": "Quale dei seguenti operatori può essere sovraccaricato?",
            "answer": "`new`",
            "explanation": "[Riferimento](https://www.tutorialspoint.com/operators-that-cannot-be-overloaded-in-cplusplus)",
            "hint": null,
            "correctAnswer": ["`new`"],
            "options": ["`?:`", "`new`", "`::`", "`.`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "409926f21da58ef69bf9aacd",
            "question": "Quale delle seguenti mostra i contenuti del vettore puntato da v1 e v2 dopo aver eseguito questo codice?\n```cpp\nstd:: vector<int> *v1 = new std::vector<int>({1,2,3});\nstd:: vector<int> *v2;\nv2=v1;\nv1->push_back(4);\nv2->push_back(5);\n```",
            "answer": "`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`",
            "explanation": "v1 e v2 puntano allo stesso vettore.",
            "hint": null,
            "correctAnswer": ["`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`"],
            "options": [
              "`*v1:{1,2,3,4}; *v2:{5};`",
              "`*v1:{1,2,3,4,5}; *v2:{1,2,3,4,5};`",
              "Errore",
              "`*v1:{1,2,3,4}; *v2:{1,2,3,5};`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4ccb6df73086d5af5f7643b1",
            "question": "Quale delle seguenti NON è una differenza tra una classe e una struct?",
            "answer": "I parametri di tipo template possono essere dichiarati con le classi, ma non con la parola chiave struct.",
            "explanation": "I template possono essere utilizzati sia con classi che con struct\n[Riferimento](https://docs.microsoft.com/en-us/cpp/cpp/struct-cpp?view=msvc-170)\n[Riferimento](https://www.fluentcpp.com/2017/06/13/the-real-difference-between-struct-class/)",
            "hint": null,
            "correctAnswer": [
              "I parametri di tipo template possono essere dichiarati con le classi, ma non con la parola chiave struct."
            ],
            "options": [
              "Poiché le struct fanno parte del linguaggio di programmazione C, c'è una certa complessità tra le struct C e C++. Questo non è il caso delle classi.",
              "Le classi possono avere funzioni membro; le struct sono private.",
              "Lo specificatore di accesso predefinito per i membri di una struct è pubblico, mentre per i membri della classe è privato.",
              "I parametri di tipo template possono essere dichiarati con le classi, ma non con la parola chiave struct."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "649843409692c7f49d822efb",
            "question": "Supponi di dover mantenere una struttura dati con il permesso di accedere a una risorsa in base ai giorni della settimana, ma non puoi usare una variabile bool per ogni giorno. Devi usare un bit per giorno della settimana. Quale delle seguenti è un'implementazione corretta di una struttura con campi di bit per questa applicazione?",
            "answer": "A",
            "explanation": "```cpp\ntypedef struct {\nint sunday:1;\nint monday:1;\n// altri giorni\nint friday:1;\nint saturday:1;\n} weekdays;\n```\n```cpp\ntypedef char[7]: weekdays;\n```\n```cpp\ntypedef struct {\nbit sunday:1;\nbit monday:1;\n// altri giorni\nbit friday:1;\nbit saturday:1;\n} weekdays;\n```\n```cpp\ntypedef struct {\nbit sunday;\nbit monday;\n// altri giorni\nbit friday;\nbit saturday;\n} weekdays;\n```\n[Riferimento](https://en.cppreference.com/w/cpp/language/bit_field) _NOTA_: La sintassi corretta è che ogni variabile ha dimensione di 1 bit. `bit` non è un tipo in C++.",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8a234a7095129774d589c38c",
            "question": "Cos'è un lvalue?",
            "answer": "È un valore di posizione, cioè un indirizzo di memoria adatto per essere assegnato a un puntatore o riferimento.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "È un valore di posizione, cioè un indirizzo di memoria adatto per essere assegnato a un puntatore o riferimento."
            ],
            "options": [
              "È un'espressione costante, cioè un'espressione composta da costanti e operazioni.",
              "È un'espressione che rappresenta un oggetto con un indirizzo.",
              "È un'espressione adatta per l'operando sinistro in un'operazione binaria.",
              "È un valore di posizione, cioè un indirizzo di memoria adatto per essere assegnato a un puntatore o riferimento."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c51fe82ff4a35b4afea98d13",
            "question": "Cosa fa lo specificatore di tipo auto in questa riga di codice (da C++11)?\n```cpp\nauto x = 4000.22;\n```",
            "answer": "Specifica che il tipo di x sarà dedotto dall'inizializzatore - in questo caso, double.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Specifica che il tipo di x sarà dedotto dall'inizializzatore - in questo caso, double."
            ],
            "options": [
              "Specifica che il tipo di x sarà dedotto dall'inizializzatore - in questo caso, double.",
              "Specifica che il tipo di x è automatico, il che significa che può essere assegnato a diversi tipi di dati durante il programma.",
              "Specifica che x è una variabile con durata di archiviazione automatica.",
              "Specifica che verrà allocata più memoria per x nel caso ne abbia bisogno, evitando la perdita di dati dovuta all'overflow."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3649ab26975846062782e016",
            "question": "Un template di classe è un \\_?",
            "answer": "classe scritta con il paradigma di programmazione generica, specificando il comportamento in termini di parametro di tipo piuttosto che di tipo specifico.",
            "explanation": "[Riferimento](https://www.mygreatlearning.com/blog/templates-in-cpp/)",
            "hint": null,
            "correctAnswer": [
              "classe scritta con il paradigma di programmazione generica, specificando il comportamento in termini di parametro di tipo piuttosto che di tipo specifico."
            ],
            "options": [
              "classe scritta con il paradigma di programmazione generica, specificando il comportamento in termini di parametro di tipo piuttosto che di tipo specifico.",
              "superclasse vuota destinata all'ereditarietà e al polimorfismo.",
              "classe che consiste solo di una variabile membro, senza costruttore, distruttore o funzioni membro.",
              "codice sorgente scheletro per una classe in cui il programmatore deve compilare parti specifiche per definire i tipi di dati e gli algoritmi utilizzati."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fdedec78b05e646a04807ea4",
            "question": "Qual è l'equivalente dell'operatore ternario per questo frammento di codice?\n```cpp\nif(x)\n    y=a;\nelse\n    y=b;\n```",
            "answer": "`y=x?a:b;`",
            "explanation": "[Riferimento](https://www.w3schools.com/cpp/cpp_conditions_shorthand.asp)",
            "hint": null,
            "correctAnswer": ["`y=x?a:b;`"],
            "options": ["`y=a?b:x;`", "`y=if(x?a:b);`", "`y=(x&a)?a:(x&b)?b:0;`", "`y=x?a:b;`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "33d0c3d1a6e8693d393e56da",
            "question": "Qual è l'output del codice fornito qui sotto?\n```cpp\n#include <iostream>\nint main(){\n    int x=10, y=20;\n    std::cout << \"x = \" << x++ << \" and y = \" << --y << std::endl;\n    std::cout << \"x = \" << x-- << \" and y = \" << ++y << std::endl;\n    return(0);\n}\n```",
            "answer": "`x = 10 and y = 19`",
            "explanation": "`x = 11 and y = 19`\n`x = 10 and y = 20`\n`x = 11 and y = 20`\n`x = 10 and y = 19`",
            "hint": null,
            "correctAnswer": ["`x = 10 and y = 19`"],
            "options": [
              "`x = 10 and y = 20`",
              "`x = 11 and y = 19`",
              "`x = 10 and y = 19`",
              "`x = 11 and y = 20`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "11024e698667076050113716",
            "question": "Qual è il significato delle due parti specificate tra parentesi in un ciclo for basato su intervallo, separate da due punti?",
            "answer": "La prima è una dichiarazione di variabile che conterrà un elemento in una sequenza. La seconda è la sequenza da attraversare.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "La prima è una dichiarazione di variabile che conterrà un elemento in una sequenza. La seconda è la sequenza da attraversare."
            ],
            "options": [
              "La prima è una dichiarazione di variabile che conterrà un elemento in una sequenza. La seconda è la sequenza da attraversare.",
              "La prima è un iteratore, e la seconda è il valore di incremento da aggiungere all'iteratore.",
              "La prima è la variabile iterante. La seconda è una `std::pair` che specifica l'intervallo (inizio e fine) in cui la variabile itererà.",
              "La prima è un oggetto contenitore. La seconda è una `std::pair` che specifica l'intervallo (inizio e fine) in cui gli elementi saranno accessibili all'interno del ciclo."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4a78b696ad13f43fdb917604",
            "question": "Qual è l'output del codice fornito qui sotto?\n```cpp\nint8_t a=200;\nuint8_t b=100;\nif(a>b)\n    std::cout<<\"greater\";\nelse\n    std::cout<<\"less\";\n```",
            "answer": "less",
            "explanation": "Nota: una variante della domanda qui sotto.",
            "hint": null,
            "correctAnswer": ["less"],
            "options": [
              "Non c'è output perché c'è un'eccezione quando si confronta un int8_t con un uint8_t.",
              "greater",
              "less",
              "Non c'è output perché c'è un errore del compilatore."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "dadaf3a786b3eb2b53c15bb9",
            "question": "Qual è l'output di questo blocco di codice?\n```cpp\nint8_t a=200;\nuint8_t b=100;\nstd::cout<<\"a=\"<<(int)a;\nstd::cout<<\", b=\"<<(int)b;\n```",
            "answer": "a=-56, b=100",
            "explanation": "Nota: Conversione implicita da 'int' a 'int8_t' (alias 'signed char') cambia il valore da 200 a -56",
            "hint": null,
            "correctAnswer": ["a=-56, b=100"],
            "options": ["a=-56, b=100", "a=-55, b=100", "a=200, b=-156", "a=200, b=100"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "de022b6cd25dc6ffed715cbe",
            "question": "Qual è l'output dopo aver eseguito questo frammento di codice?\n```cpp\nint x=5, y=2;\nif(x & y) {\n    /*_parte A_*/\n}\nelse {\n    /*_parte B_*/\n}\n```",
            "answer": "La parte B viene eseguita perché (x & y) risulta in 0, o falso.",
            "explanation": "[Riferimento](https://stackoverflow.com/questions/63867765/dont-understand-why-if-5-2-is-false)",
            "hint": null,
            "correctAnswer": ["La parte B viene eseguita perché (x & y) risulta in 0, o falso."],
            "options": [
              "La parte A viene eseguita perché x==5 (vero) e y==2 (vero), quindi l'operazione AND valuta come vera.",
              "La parte B viene eseguita perché (x & y) risulta in 0, o falso.",
              "La parte A viene eseguita perché (x & y) risulta in un valore diverso da zero, o vero.",
              "La parte B viene eseguita perché l'istruzione (x & y) non è valida, quindi falsa."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2a23a0f52530c149c22b71e0",
            "question": "Qual è una definizione valida per la funzione `get_length`, che restituisce la lunghezza di una stringa terminata con null?",
            "answer": "A",
            "explanation": "```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str[count++]);\nreturn count-1;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str!=NULL){\ncount++;\nstr++;\n}\nreturn count;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile((*str)++)\ncount++;\nreturn count;\n}\n```\n```cpp\nint get_length(char *str) {\nint count=0;\nwhile(str++)\ncount++;\nreturn count;\n}\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d4f85a17d6bef829f51572e2",
            "question": "Quale classe STL è la più adatta per implementare una collezione di dati che è sempre ordinata in modo che l'operazione pop ottenga sempre il più grande degli elementi? Supponi di essere interessato solo alle operazioni push e pop.",
            "answer": "`std::priority_queue`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`std::priority_queue`"],
            "options": ["`std::list`", "`std::vector`", "`std::priority_queue`", "`std::map`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "952fa57845823471b42161f4",
            "question": "Qual è il significato delle tre sezioni specificate tra parentesi in un ciclo for separate da punti e virgola?",
            "answer": "La prima è il blocco di inizializzazione, la seconda è la condizione per iterare, e la terza è il blocco di incremento.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "La prima è il blocco di inizializzazione, la seconda è la condizione per iterare, e la terza è il blocco di incremento."
            ],
            "options": [
              "La prima è il nome della variabile iterante, la seconda è il numero di volte da iterare, e la terza è l'incremento o decremento desiderato (specificato con un intero con segno).",
              "La prima è il blocco di inizializzazione, la seconda è la condizione per iterare, e la terza è il blocco di incremento.",
              "La prima è la variabile iterante, la seconda è il contenitore in cui dovrebbe operare, e la terza è una condizione di uscita per interrompere in qualsiasi momento.",
              "La prima è il nome della variabile iterante, la seconda è il valore iniziale per la variabile iterante, e la terza è il valore di stop (l'ultimo valore più uno)."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0d805c333f868f63de60ef49",
            "question": "Cosa stampa questo codice?\n```cpp\nint i = 0;\nprintf(\"%d\", i++);\nprintf(\"%d\", i--);\nprintf(\"%d\", ++i);\nprintf(\"%d\", --i);\n```",
            "answer": "0,1,1,0",
            "explanation": "[Riferimento](https://www.geeksforgeeks.org/pre-increment-and-post-increment-in-c/)",
            "hint": null,
            "correctAnswer": ["0,1,1,0"],
            "options": ["0,1,1,0", "0,1,0,1", "0,0,1,0", "1,0,1,0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5bb1f005239fc70209b1d1aa",
            "question": "Cosa è vero riguardo alla variabile chiamata `ptr`?\n```cpp\nvoid *ptr;\n```",
            "answer": "È un puntatore a un valore senza tipo specifico, quindi può essere convertito per puntare a qualsiasi tipo.",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/language/pointer)",
            "hint": null,
            "correctAnswer": [
              "È un puntatore a un valore senza tipo specifico, quindi può essere convertito per puntare a qualsiasi tipo."
            ],
            "options": [
              "È un puntatore inizializzato a NULL.",
              "È un puntatore a una funzione void.",
              "Quella dichiarazione causa un errore del compilatore, poiché i puntatori devono specificare un tipo.",
              "È un puntatore a un valore senza tipo specifico, quindi può essere convertito per puntare a qualsiasi tipo."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "cd376e38ee89c75149366349",
            "question": "Qual è l'output del codice fornito qui sotto?\n```cpp\nint c=3; char d='A';\nstd::printf(\"c is %d and d is %c\",c,d);\n```",
            "answer": "c is 3 and d is A",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["c is 3 and d is A"],
            "options": [
              "c is d and d is c",
              "c is A and d is 3",
              "c is 3 and d is A",
              "c is c and d is d"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f73403e11db2f9bf74489b43",
            "question": "Qual è l'output di questo codice?\n```cpp\nprintf(\"1/2 = %f\",(float)(1/2));\n```",
            "answer": "1/2 = 0.000000",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["1/2 = 0.000000"],
            "options": ["1/2 = 0.499999", "1/2 = 0", "1/2 = 0.000000", "1/2 = 0.5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4f6f1e37718db810fde9b264",
            "question": "Qual è la differenza tra un membro di classe pubblico e uno privato?",
            "answer": "I membri pubblici possono essere accessibili da qualsiasi funzione. I membri privati possono essere accessibili solo dalle funzioni membro della stessa classe e dagli amici della classe.",
            "explanation": "[Riferimento](https://www.geeksforgeeks.org/difference-between-public-and-private-in-c-with-example/)",
            "hint": null,
            "correctAnswer": [
              "I membri pubblici possono essere accessibili da qualsiasi funzione. I membri privati possono essere accessibili solo dalle funzioni membro della stessa classe e dagli amici della classe."
            ],
            "options": [
              "I membri pubblici sono gli stessi delle variabili globali, quindi ogni parte del codice ha accesso ad essi. I membri privati sono gli stessi delle variabili automatiche, quindi solo la loro classe ha accesso ad essi.",
              "I membri pubblici sono resi accessibili a qualsiasi applicazione in esecuzione. I membri privati sono resi accessibili solo all'applicazione in cui l'oggetto è istanziato.",
              "I membri pubblici saranno compilati come variabili condivise in un ambiente multithread. I membri privati saranno compilati come variabili locali al thread.",
              "I membri pubblici possono essere accessibili da qualsiasi funzione. I membri privati possono essere accessibili solo dalle funzioni membro della stessa classe e dagli amici della classe."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2032ad30a2a98d5a16e23fb7",
            "question": "Qual è il valore di `x` dopo aver eseguito questo codice?\n```cpp\nint x=10, a=-3;\nx+=a;\n```",
            "answer": "7",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["7"],
            "options": ["3", "7", "-3", "13"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9655550c9baaaa80dea6944e",
            "question": "Quale affermazione è vera?",
            "answer": "C++ supporta l'ereditarietà multipla.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C++ supporta l'ereditarietà multipla."],
            "options": [
              "Solo le classi possono avere variabili e metodi membro.",
              "C++ supporta l'ereditarietà multipla.",
              "C++ supporta solo l'ereditarietà singola.",
              "Solo le struct possono ereditare."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3ba8528869b0f2b05306f7e3",
            "question": "Considera un puntatore a void, chiamato `ptr`, che è stato impostato per puntare a una variabile floating point `g`. Quale scelta è un modo valido per dereferenziare `ptr` per assegnare il suo valore puntato a una variabile float `f` successivamente nel programma?\n```cpp\nfloat g;\nvoid *ptr=&g;\n```",
            "answer": "`float f=*(float *)ptr;`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`float f=*(float *)ptr;`"],
            "options": [
              "`float f=*(float)ptr;`",
              "`float f=(float *)ptr;`",
              "`float f=(float)*ptr;`",
              "`float f=*(float *)ptr;`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5d32b5d3b3381ed534f5fa72",
            "question": "Cos'è l'operatore `.*` e cosa fa?",
            "answer": "È l'operatore puntatore a membro, e consente di accedere a un membro di un oggetto tramite un puntatore a quel membro di classe specifico.",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/language/operator_member_access)",
            "hint": null,
            "correctAnswer": [
              "È l'operatore puntatore a membro, e consente di accedere a un membro di un oggetto tramite un puntatore a quel membro di classe specifico."
            ],
            "options": [
              "È lo stesso dell'operatore di accesso ai membri della classe, o operatore freccia `(->)`, che consente di accedere a un membro di un oggetto tramite un puntatore all'oggetto.",
              "È l'operatore puntatore a membro, e consente di accedere a un membro di un oggetto tramite un puntatore a quel membro di classe specifico.",
              "È l'operatore di accesso ai membri con indirizzo, che restituisce l'indirizzo di un membro di classe o struct.",
              "È una combinazione dell'operatore di accesso ai membri `(.)` e dell'operatore di dereferenziazione `(*)`, quindi consente di accedere all'oggetto a cui punta un puntatore membro."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0189c98e6a560ef4b14af00b",
            "question": "Per queste dichiarazioni, quale scelta mostra quattro modi equivalenti per assegnare il carattere \"y\" nella stringa a una variabile char c?\n```cpp\nchar buff[50] = \"strings as arrays of characters are fun!\"\nchar *str = buff+11;\nchar c;\n```",
            "answer": "C",
            "explanation": "```cpp\nc = buff[16];\nc = str[5];\nc = *(buff+16);\nc = *(str+5);\n```\n```cpp\nc = *(buff[15]);\nc = *(str[4]);\nc = buff+15;\nc = str+4;\n```\n```cpp\nc = buff[15];\nc = str[4];\nc = *(buff+15);\nc = *(str+4);\n```\n```cpp\nc = *(buff[16]);\nc = *(str[5]);\nc = buff+16;\nc = str+5;\n```",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "21156bd7ff5cb9b450a6b23a",
            "question": "Quale scelta è la dichiarazione corretta per la classe chiamata Dog, derivata dalla classe Animal?\n```cpp\nclass Animal{\n    //....\n}\n```",
            "answer": "B",
            "explanation": "```cpp\nclass Dog :: public Animal {\n//....\n};\n```\n```cpp\nclass Dog : public Animal {\n//....\n};\n```\n```cpp\npublic class Animal :: Dog {\n//....\n};\n```\n```cpp\npublic class Dog extends Animal {\n//....\n};\n```",
            "hint": null,
            "correctAnswer": ["B"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "45028d631247da3ab0c79f34",
            "question": "Qual è l'output di questo codice qui sotto?\n```cpp\n#include <cstdio>\nusing namespace std;\nint main(){\n    char c = 255;\n    if(c>10)\n        printf(\"c = %i, which is greater than 10\", c);\n    else\n        printf(\"c = %i, which is less than 10\", c);\n    return 0;\n}\n```",
            "answer": "c = -1, which is less than 10",
            "explanation": "Tecnicamente, se un `char` è `signed` o `unsigned` è definito dall'implementazione;\nnel secondo caso, la seconda risposta sarebbe corretta.\n[Riferimento](https://en.cppreference.com/w/cpp/language/types)",
            "hint": null,
            "correctAnswer": ["c = -1, which is less than 10"],
            "options": [
              "c = -1, which is less than 10",
              "c = 255, which is greater than 10",
              "c = -1, which is greater than 10",
              "c = 255, which is less than 10"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d0014918d1eeb46cdcdcd2e0",
            "question": "Come può il codice C++ chiamare una funzione C?",
            "answer": "usando extern \"C\"",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["usando extern \"C\""],
            "options": [
              "semplicemente chiamando il codice C",
              "Non c'è modo per C++ di chiamare una funzione C",
              "usando extern \"C\"",
              "importando il codice sorgente C"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8ed2e209d968e62b8bfdc7d4",
            "question": "Quale scelta NON è una definizione di tipo valida di una struttura che contiene coordinate x e y come interi, e che può essere utilizzata esattamente come mostrato per la variabile chiamata `center`?\n```cpp\ncoord center;\ncenter.x = 5;\ncenter.y = 3;\n```",
            "answer": "A",
            "explanation": "```cpp\ntypedef struct coord {\nint x;\nint y;\n};\n```\n```cpp\ntypedef struct coord {\nint x;\nint y;\n} coord;\n```\n```cpp\ntypedef struct {\nint x;\nint y;\n} coord;\n```\n```cpp\nstruct coord {\nint x;\nint y;\n};\ntypedef struct coord coord;\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "98ecb99f758cc2590ce5b002",
            "question": "Quale scelta NON produce lo stesso output di questo frammento di codice? Supponi che la variabile `i` non verrà utilizzata altrove nel codice.\n```cpp\nfor (i=1;i<10;i++){\n    cout<<i<<endl;\n}\n```",
            "answer": "A",
            "explanation": "```cpp\ni=1;\nwhile(i<10){\ncout<<++i<<endl;\n}\n```\n```cpp\nfor (int i:{1,2,3,4,5,6,7,8,9}) {\ncout<<i<<endl;\n}\n```\n```cpp\ni = 1;\ndo {\ncout<<i++<<endl;\n} while(i<10);\n```\n```cpp\ni = 1;\nloop:\ncout<<i++<<endl;\nif(i<10) goto loop;\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3658d6bbbd6e06e71fa425e5",
            "question": "Cosa fa questa parte di un file main.cpp?\n```cpp\n#include \"library.h\"\n```",
            "answer": "Causa la sostituzione della direttiva `#include` con l'intero contenuto del file sorgente library.h. Questo è simile all'operazione Copia-Incolla di library.h in main.cpp.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Causa la sostituzione della direttiva `#include` con l'intero contenuto del file sorgente library.h. Questo è simile all'operazione Copia-Incolla di library.h in main.cpp."
            ],
            "options": [
              "Fa sì che la toolchain compili tutti i contenuti di library.h in modo che il suo codice eseguibile sia disponibile quando necessario dall'applicazione finale.",
              "Seleziona library.h per le dichiarazioni e definizioni di tutti i dati e funzioni utilizzate nel resto del file sorgente main.cpp, sostituendo infine la direttiva `#include` con quelle dichiarazioni e definizioni.",
              "Informa il linker che alcune funzioni o dati utilizzati nel file sorgente main.cpp sono contenuti in library.h, in modo che possano essere chiamati in fase di esecuzione. Questo è anche noto come collegamento dinamico.",
              "Causa la sostituzione della direttiva `#include` con l'intero contenuto del file sorgente library.h. Questo è simile all'operazione Copia-Incolla di library.h in main.cpp."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d7e4b4d56c213d2709848462",
            "question": "Considera questa dichiarazione di funzione di `is_even`, che prende un intero e restituisce true se l'argomento è un numero pari e false altrimenti. Quali dichiarazioni sono corrette per le versioni sovraccaricate di quella funzione per supportare numeri in virgola mobile e rappresentazioni stringa di numeri?\n```cpp\nbool is_even(int);\n```",
            "answer": "A",
            "explanation": "```cpp\nbool is_even(float f);\nbool is_even(char *str);\n```\n```cpp\nbool is_even(float f);\nbool is_even(char str);\n```\n```cpp\nbool is_even_float(float f);\nbool is_even_str(char *str);\n```\n```cpp\nfloat is_even(float f);\nchar *is_even(char *str);\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "28a3002ceb70061299dc300b",
            "question": "Quale scelta è una guardia di inclusione per il file di intestazione `my_library.h`?",
            "answer": "B",
            "explanation": "```cpp\n#ifdef MY_LIBRARY_H\n#define MY_LIBRARY_H\n// contenuto my_library.h\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#ifndef MY_LIBRARY_H\n#define MY_LIBRARY_H\n// contenuto my_library.h\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#ifdef MY_LIBRARY_H\n#undef MY_LIBRARY_H\n// contenuto my_library.h\n#endif /* MY_LIBRARY_H */\n```\n```cpp\n#define MY_LIBRARY_H\n#include MY_LIBRARY_H\n// contenuto my_library.h\n#undef MY_LIBRARY_H\n```",
            "hint": null,
            "correctAnswer": ["B"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "10e9913ded9ee88321382c97",
            "question": "Cosa c'è di sbagliato con questa definizione quando si utilizza un compilatore pre-C++11?\n```cpp\nstd::vector<std::vector<int>> thematrix;\n```",
            "answer": "`>>` è analizzato come operatore di shift a destra, e quindi risulta in un errore di compilazione.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "`>>` è analizzato come operatore di shift a destra, e quindi risulta in un errore di compilazione."
            ],
            "options": [
              "Non c'è niente di sbagliato.",
              "Uno `std::vector` non può contenere altri contenitori `std::vector` come suoi elementi.",
              "La sintassi corretta dovrebbe essere: `std::vector[std::vector[int]] thematrix;`",
              "`>>` è analizzato come operatore di shift a destra, e quindi risulta in un errore di compilazione."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e74f9c0b3101482fb3dadbbd",
            "question": "A cosa è equivalente l'istruzione qui sotto?",
            "answer": null,
            "explanation": null,
            "hint": null,
            "correctAnswer": [],
            "options": [],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a17d67bee0373142d3ea5b32",
            "question": "b. A cosa è equivalente l'istruzione?\n```cpp\nsprite->x\n```",
            "answer": "`(*sprite).x`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`(*sprite).x`"],
            "options": ["`sprite.x`", "`sprite.*x`", "`(*sprite).x`", "`*sprite.x`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b1b8e424023e16b6ac2bbad3",
            "question": "Considera una classe chiamata `complexNumber`. Quale codice risulterà in un oggetto equivalente?\n```cpp\ncomplexNumber(float real, float im)\n: real_part(real),\n im_part(im){}\n```",
            "answer": "C",
            "explanation": "```cpp\ncomplexNumber(float real, float im) {\nthis->real = real_part;\nthis->im = im_part;\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part(real);\nthis->im_part(im);\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part = real;\nthis->im_part = im;\n}\n```\n```cpp\ncomplexNumber(float real, float im) {\nthis->real_part = &real;\nthis->im_part = &im;\n}\n```",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0bb871e845e804f3a39ea5dd",
            "question": "Qual è il risultato dell'esecuzione di questo frammento di codice?\n```cpp\nbool x=true, y=false;\nif (~x || y) {\n    /*parte A*/\n} else {\n    /*parte B*/\n}\n```",
            "answer": "La parte A viene eseguita perché `~x` non è zero, il che significa vero.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "La parte A viene eseguita perché `~x` non è zero, il che significa vero."
            ],
            "options": [
              "La parte A viene eseguita perché l'espressione `(~x || y)` risulta sempre vera se `y==false`.",
              "La parte B viene eseguita perché l'istruzione `(~x || y)` non è valida, quindi falsa.",
              "La parte A viene eseguita perché `~x` non è zero, il che significa vero.",
              "La parte B viene eseguita perché `~x` è falso e `y` è falso, quindi l'operazione OR valuta come falsa."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "78bec166ec57a1756b53583c",
            "question": "Quale sarebbe l'output di questo codice?\n```cpp\nint32_t nums[3]={2,4,3};\nstd::cout << ( nums[0] << nums[1] << nums[2] );\n```",
            "answer": "256",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["256"],
            "options": [
              "L'output sono gli indirizzi di `nums[0]`, `nums[1]`, e `nums[2]`, in quell'ordine, senza spazi.",
              "256",
              "`0`",
              "`243`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f4615ceac7e71c9c9e469ec5",
            "question": "Qual è l'output di questo codice?\n```cpp\nfloat values[5]={0.54f, 2.71828f, 3.14159f, 5.499999f, 10.0f};\nfor(auto f:values)\n    printf(\"%i \",(int)(f+0.5f));\n```",
            "answer": "`1 3 3 5 10`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`1 3 3 5 10`"],
            "options": [
              "`0.54 2.71828 3.14159 5.499999 10.0`",
              "`1 3 4 6 11`",
              "`0 2 3 5 10`",
              "`1 3 3 5 10`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3a71bae06e8475c3d37dfe8e",
            "question": "Quale delle seguenti classi STL è la più adatta per implementare una rubrica telefonica? Supponi che ogni voce contenga un nome e un numero di telefono, senza duplicati, e che si voglia effettuare una ricerca per nome.",
            "answer": "`std::map`",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/container/map)",
            "hint": null,
            "correctAnswer": ["`std::map`"],
            "options": ["`std::priority_queue`", "`std::list`", "`std::vector`", "`std::map`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "36fec6766a4cf753cb4b891d",
            "question": "Cosa fa questo programma?\n```cpp\n#include <iostream>\n#include <fstream>\nusing namespace std;\nint main(){\n    ifstream file1(\"text1.txt\", ios::binary);\n    ofstream file2(\"text2.txt\", ios::binary);\n    file2 << file1.rdbuf();\n}\n```",
            "answer": "Copia il contenuto di text1.txt in text2.txt - cioè, crea una copia di text1.txt, chiamata text2.txt.",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/header/fstream)",
            "hint": null,
            "correctAnswer": [
              "Copia il contenuto di text1.txt in text2.txt - cioè, crea una copia di text1.txt, chiamata text2.txt."
            ],
            "options": [
              "Rinomina text1.txt in text2.txt.",
              "Crea una directory chiamata text2.txt e sposta text1.txt lì.",
              "Copia il contenuto di text1.txt in text2.txt - cioè, crea una copia di text1.txt, chiamata text2.txt.",
              "Aggiunge il contenuto di text1.txt in text2.txt - cioè, sostituisce il contenuto di text2.txt con la concatenazione di text2.txt e text1.txt."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a6d0e1aa560d70a0ae02da7f",
            "question": "Quale delle seguenti NON è una conseguenza della dichiarazione della variabile membro `count` di my_class come statica? / Alt.: Quale affermazione è vera quando si dichiara la variabile membro `count` come statica?\n```cpp\nclass my_class {\n    public: static int count;\n}\n```",
            "answer": "La variabile non può essere modificata da nessuna parte del codice nella stessa applicazione o thread. Tuttavia, altri thread possono modificarla.",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/language/static)",
            "hint": null,
            "correctAnswer": [
              "La variabile non può essere modificata da nessuna parte del codice nella stessa applicazione o thread. Tuttavia, altri thread possono modificarla."
            ],
            "options": [
              "La variabile non può essere modificata da nessuna parte del codice nella stessa applicazione o thread. Tuttavia, altri thread possono modificarla.",
              "La variabile esiste anche quando non sono stati definiti oggetti della classe, quindi può essere modificata in qualsiasi punto del codice sorgente.",
              "La variabile viene allocata una sola volta, indipendentemente da quanti oggetti vengono istanziati, perché è legata alla classe stessa, non alle sue istanze.",
              "Tutti gli oggetti che tentano di accedere alla loro variabile membro count in realtà fanno riferimento all'unica variabile statica count legata alla classe."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "dccd1819f65a85f396d11c2d",
            "question": "Qual è il tipo presunto di una costante rappresentata nel codice sorgente come `0.44`?",
            "answer": "double",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["double"],
            "options": ["double", "long float", "long double", "float"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ae76c66171f1eba28d6be53b",
            "question": "Qual è un modo appropriato di rimuovere `my_object` come mostrato qui sotto?\n```cpp\nmy_class *my_object = new my_class();\n```",
            "answer": "`delete(my_object);`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`delete(my_object);`"],
            "options": [
              "`delete(my_object);`",
              "`free(my_object);`",
              "Il garbage collector distruggerà l'oggetto alla fine.",
              "Uscire dallo scope distruggerà l'oggetto."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ddb8bee0e89dd9884c5655c6",
            "question": "Qual è il modo corretto di chiamare la funzione membro `count` per il puntatore all'oggetto chiamato `grades`?\n```cpp\nclass my_array{\n    public:\n        int count();\n};  // ... altri membri sopra\nint main(){\n    my_array *grades = new my_array();\n};  // ... altro codice sopra\n```",
            "answer": "`grades->count();`",
            "explanation": "[Riferimento](https://en.cppreference.com/w/c/language/operator_member_access)",
            "hint": null,
            "correctAnswer": ["`grades->count();`"],
            "options": [
              "`grades.count();`",
              "`my_array->count();`",
              "`grades->count();`",
              "`my_array.count();`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6fa0cf4db27c42c20d81b06d",
            "question": "Quale sarebbe l'output di questo codice?\n```cpp\nint i0=4, i1=6, i2=8;\nint& nums[3]={i2,i0,i1};\nstd::cout<<nums[0]<<nums[1]<<nums[2];\n```",
            "answer": "Non c'è output. Il codice causa un errore del compilatore perché `nums` è un array di riferimenti, che è illegale.",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/language/array)",
            "hint": null,
            "correctAnswer": [
              "Non c'è output. Il codice causa un errore del compilatore perché `nums` è un array di riferimenti, che è illegale."
            ],
            "options": [
              "Non c'è output. Il codice causa un errore del compilatore perché `nums` è un array di riferimenti, che è illegale.",
              "846",
              "L'output sono gli indirizzi di `i2`, `i0`, e `i1`, in quell'ordine, senza spazi.",
              "468"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6a543b0ed141daf409d3992f",
            "question": "Questo codice causa un errore del compilatore? Se sì, perché, e se no, cos'è `child_t`?\n```cpp\ntypedef struct{\n    unsigned int  age    : 4;\n    unsigned char gender : 1;\n    char                 : 0;\n    unsigned int  size   : 2;\n}child_t;\n```",
            "answer": "No, e `child_t` è un tipo definito come una struttura con campi di bit. Ha 4 bit per l'età e 1 bit per il genere nel primo byte, e 2 bit per la dimensione nel secondo byte.",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": [
              "No, e `child_t` è un tipo definito come una struttura con campi di bit. Ha 4 bit per l'età e 1 bit per il genere nel primo byte, e 2 bit per la dimensione nel secondo byte."
            ],
            "options": [
              "Sì, causa un errore del compilatore perché il carattere due punti non è consentito nelle definizioni di struct.",
              "No, e `child_t` è un tipo definito come una struttura con campi di bit. Ha 4 bit per l'età e 1 bit per il genere nel primo byte, e 2 bit per la dimensione nel secondo byte.",
              "Sì, causa un errore del compilatore perché c'è un campo senza nome.",
              "Sì, causa un errore del compilatore perché un campo è definito come avente una dimensione di 0."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f0507b86d3498f16a21956df",
            "question": "A cosa è equivalente questa espressione?\n```cpp\nA->B\n```",
            "answer": "`(*A).B`",
            "explanation": "Nota: una variante più semplice della domanda qui sotto.",
            "hint": null,
            "correctAnswer": ["`(*A).B`"],
            "options": ["`*(A.B)`", "`B=A`", "`(*A).B`", "`&A.B`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ed5f9d2adb6326b1e1278986",
            "question": "A cosa è equivalente questa espressione?\n```cpp\nA->B->C->D\n```",
            "answer": "`*(*((*A).B).C).D`",
            "explanation": "**Nota:** una variante più complessa della domanda sopra.",
            "hint": null,
            "correctAnswer": ["`*(*((*A).B).C).D`"],
            "options": ["`A.B.C.D`", "`*A.*B.*C.*D`", "`&A.&B.&C.&D`", "`*(*((*A).B).C).D`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "87a421227d8df340ac6f0267",
            "question": "Cosa fa questa funzione?\n```cpp\nauto buff = new char[50];\nstd::memset(buff,20,50);\n```",
            "answer": "Scrive il valore 20 in ogni indirizzo di memoria da buff a buff+49.",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/string/byte/memset)",
            "hint": null,
            "correctAnswer": [
              "Scrive il valore 20 in ogni indirizzo di memoria da buff a buff+49."
            ],
            "options": [
              "Dichiara un buffer di memoria chiamato buff che inizia all'indirizzo 20 e termina all'indirizzo 70.",
              "Imposta tutti i bit nell'array chiamato buffer dal suo elemento all'indice 20 al suo elemento all'indice 50.",
              "Scrive il valore 20 in ogni indirizzo di memoria da buff a buff+49.",
              "Dichiara un buffer di memoria chiamato buff che inizia all'indirizzo 20 e termina all'indirizzo 50."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fc41574b48b3a9dcb6b3ca8a",
            "question": "Considera una classe chiamata `CustomData`. Quale scelta è una sintassi di dichiarazione corretta per sovraccaricare l'operatore postfisso `++` come membro di classe?",
            "answer": "`CustomData operator++(int);`",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/language/operators)",
            "hint": null,
            "correctAnswer": ["`CustomData operator++(int);`"],
            "options": [
              "`CustomData& operator++();`",
              "`void operator++(CustomData);`",
              "`CustomData operator++(CustomData);`",
              "`CustomData operator++(int);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1045ef5d02f36a7a270eb49c",
            "question": "Vuoi ordinare my_array, dichiarato qui sotto. Quale scelta è la chiamata corretta a std::sort, utilizzando un'espressione lambda come funzione di confronto?\n```cpp\nstd::array<uint32_t, 50> my_array;\n```",
            "answer": "A",
            "explanation": "```cpp\nstd::sort(my_array.begin(), my_array.end(),\n[](uint32_t a, uint32_t b) {\nreturn a < b;\n})\n```\n```cpp\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n}\nstd::sort(my_array.begin(), my_array.end(), lambda);\n```\n```cpp\nstd::sort(my_array.begin(), my_array.end(),\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n})\n```\n```cpp\nlambda(uint32_t a, uint32_t b){\nreturn a < b;\n}\nstd::sort(my_array.begin(), my_array.end(), &lambda);\n```\n[Riferimento](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160)",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2e0e40e27e59d81677257a33",
            "question": "Quale scelta è l'implementazione più ragionevole della funzione std::mutex::lock() usando std::mutex::try_lock()?",
            "answer": "A",
            "explanation": "```cpp\nvoid std::mutex::lock(){\nwhile(!this->try_lock());\n}\n```\n```cpp\nvoid std::mutex::lock(){\nreturn (this->try_lock());\n}\n```\n```cpp\nvoid std::mutex::lock(){\nwhile(1)\nthis->try_lock();\n}\n```\n```cpp\nvoid std::mutex::lock(){\nwhile(this->try_lock());\n}\n```\nNota: variante della domanda qui sotto.",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "48406197650d550718a89ef9",
            "question": "Qual è la differenza principale tra queste due funzioni?\n```cpp\nstd::mutex::lock()\nstd::mutex::try_lock()\n```",
            "answer": "Entrambe tentano di acquisire un lock, ma `lock()` si blocca se il mutex non è disponibile, mentre `try_lock()` restituisce se il mutex è disponibile o meno.",
            "explanation": "Nota: variante della domanda precedente.\n[Riferimento](https://en.cppreference.com/w/cpp/thread/mutex/try_lock)",
            "hint": null,
            "correctAnswer": [
              "Entrambe tentano di acquisire un lock, ma `lock()` si blocca se il mutex non è disponibile, mentre `try_lock()` restituisce se il mutex è disponibile o meno."
            ],
            "options": [
              "`lock()` ha un privilegio maggiore su `try_lock()`. Questo significa che hai una migliore possibilità di acquisire un mutex con `lock()`.",
              "Entrambe tentano di acquisire un lock, ma `lock()` si blocca se il mutex non è disponibile, mentre `try_lock()` restituisce se il mutex è disponibile o meno.",
              "`lock()` impone la preemption, mentre `try_lock()` suggerisce la preemption.",
              "Se il mutex non è disponibile, `try_lock()` ritorna con un codice corrispondente, mentre `lock()` strappa il mutex dal thread che lo possiede attualmente."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c17b628ba6048a30342c5de1",
            "question": "Qual è lo scopo di un distruttore?",
            "answer": "Permette al programmatore di scrivere il codice necessario per liberare le risorse acquisite dall'oggetto prima di eliminare l'oggetto stesso.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Permette al programmatore di scrivere il codice necessario per liberare le risorse acquisite dall'oggetto prima di eliminare l'oggetto stesso."
            ],
            "options": [
              "Permette al programmatore di scrivere il codice necessario per liberare le risorse acquisite dall'oggetto prima di eliminare l'oggetto stesso.",
              "Elimina un oggetto. Un esempio di distruttore è la funzione `delete()`.",
              "Termina un programma. Questo può essere ottenuto come una normale chiamata di funzione o come un'eccezione.",
              "Non ci sono distruttori in C++."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "262ca907aa0f7c657e688bcc",
            "question": "Qual è un vantaggio di dichiarare il parametro come riferimento `const` invece di dichiararlo come oggetto normale?\n```cpp\nint calculateMedian(const my_array& a)\n```",
            "answer": "Il qualificatore `const` vieta al codice di modificare l'argomento, quindi il programmatore può essere sicuro che l'oggetto sorgente rimarrà invariato. / Alt.: L'argomento è passato come riferimento, quindi se l'oggetto my_array passato è grande, il programma richiederà meno tempo e memoria.",
            "explanation": "[Riferimento](https://stackoverflow.com/a/2627179/10773894)",
            "hint": null,
            "correctAnswer": [
              "Il qualificatore `const` vieta al codice di modificare l'argomento, quindi il programmatore può essere sicuro che l'oggetto sorgente rimarrà invariato. / Alt.: L'argomento è passato come riferimento, quindi se l'oggetto my_array passato è grande, il programma richiederà meno tempo e memoria."
            ],
            "options": [
              "In realtà, gli oggetti non possono essere passati come variabili normali, perché richiedono una chiamata al costruttore. Pertanto, un riferimento `const` è l'unico modo per passare istanze di classe alle funzioni.",
              "Non ci sono vantaggi perché un riferimento e un oggetto sono trattati come la stessa cosa.",
              "Il qualificatore `const` vieta al codice di modificare l'argomento, quindi il programmatore può essere sicuro che l'oggetto sorgente rimarrà invariato. / Alt.: L'argomento è passato come riferimento, quindi se l'oggetto my_array passato è grande, il programma richiederà meno tempo e memoria.",
              "L'argomento è passato come riferimento, quindi la funzione riceve una copia che può essere modificata senza influenzare la variabile originale."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "132b2cdcc3ef09809230c498",
            "question": "Cos'è una guardia di inclusione?",
            "answer": "un'istruzione del preprocessore che impedisce a un file sorgente di essere incluso più di una volta in un progetto",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "un'istruzione del preprocessore che impedisce a un file sorgente di essere incluso più di una volta in un progetto"
            ],
            "options": [
              "una direttiva del preprocessore che previene comportamenti incoerenti nelle righe che contengono le direttive #ifdef, #ifndef o #elif",
              "un'opzione del compilatore che impedisce al codice utente di includere librerie aggiuntive",
              "un'istruzione del preprocessore che impedisce a un file sorgente di essere incluso più di una volta in un progetto",
              "una libreria che aggiunge funzionalità di sicurezza come mutex, watchdog timer e asserzioni al progetto"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "88e3435b753a0580620ba6ef",
            "question": "Qual è la dichiarazione corretta di un costruttore predefinito per una classe chiamata Sprite?",
            "answer": "A",
            "explanation": "```cpp\npublic: Sprite();\n```\n```cpp\nprivate: void Sprite();\n```\n```cpp\npublic: void Sprite();\n```\n```cpp\nprivate: Sprite();\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d4f70b5b98d4e7385e0c86c5",
            "question": "Qual è lo scopo di questa riga in un file di intestazione?\n```cpp\n#pragma once\n```",
            "answer": "per far sì che il compilatore analizzi quel file di intestazione una sola volta, anche se è incluso più volte nel sorgente",
            "explanation": "[riferimento qui](https://en.cppreference.com/w/cpp/preprocessor/impl)",
            "hint": null,
            "correctAnswer": [
              "per far sì che il compilatore analizzi quel file di intestazione una sola volta, anche se è incluso più volte nel sorgente"
            ],
            "options": [
              "per limitare l'uso dei suoi contenuti a un solo file sorgente",
              "per dire al compilatore che può essere istanziata solo una variabile dalle classi o tipi contenuti in questo file di intestazione",
              "per aiutare il compilatore a terminare più velocemente assicurando che sia necessario un solo passaggio del compilatore per il codice incluso in questo file di intestazione",
              "per far sì che il compilatore analizzi quel file di intestazione una sola volta, anche se è incluso più volte nel sorgente"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7a09de046d223020ce0f3d8a",
            "question": "Cos'è una variabile di tipo double?",
            "answer": "un numero in virgola mobile",
            "explanation": "[Riferimento](https://www.educba.com/c-plus-plus-double/)",
            "hint": null,
            "correctAnswer": ["un numero in virgola mobile"],
            "options": [
              "una 2-tupla",
              "un numero intero",
              "un numero in virgola mobile",
              "una stringa con più di 255 caratteri"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e7fbf0a98db2b7c2a99f18fe",
            "question": "Oltre allo spostamento di bit a sinistra, per cosa viene utilizzato l'operatore <<?",
            "answer": "inserire caratteri in un flusso di output come std::cout.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["inserire caratteri in un flusso di output come std::cout."],
            "options": [
              "spostare caratteri a sinistra in una stringa.",
              "inserire caratteri in un flusso di output come std::cout.",
              "confrontare numeri in virgola mobile come minore di.",
              "assegnare una variabile a un riferimento."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "335610aae1521b0ab6f3b268",
            "question": "Quale scelta è una ragione per specificare il tipo di un puntatore invece di usare `void *`, che funziona come puntatore a qualsiasi tipo?",
            "answer": "Il compilatore ha bisogno del tipo di dato per sapere quanta memoria allocare per il puntatore perché diversi tipi di dati richiedono diverse lunghezze di puntatore.",
            "explanation": "[Riferimento](https://stackoverflow.com/questions/9802585/why-is-the-data-type-needed-in-pointer-declarations)",
            "hint": null,
            "correctAnswer": [
              "Il compilatore ha bisogno del tipo di dato per sapere quanta memoria allocare per il puntatore perché diversi tipi di dati richiedono diverse lunghezze di puntatore."
            ],
            "options": [
              "Il compilatore ha bisogno del tipo di dato per assicurarsi che il puntatore non verrà utilizzato su tipi illegali non puntabili come funzioni, etichette, puntatori e riferimenti.",
              "`void *` non funziona per nessun tipo. Il linguaggio non consente di assegnare nulla diverso da `void` a un puntatore a `void *`.",
              "Il compilatore ha bisogno del tipo di dato per sapere quanta memoria allocare per il puntatore perché diversi tipi di dati richiedono diverse lunghezze di puntatore.",
              "Sì, causa un errore del compilatore perché un campo è definito come avente una dimensione di 0."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "85cee50ed8277333ab21bc0d",
            "question": "Cosa c'è di sbagliato con questo pezzo di codice?\n```cpp\n#include <iostream>\nchar str[20];\nint main(){\n    std::cout << \"What's your name? \";\n    str << std::cin\n    std::cout << \"Hello, \" << str;\n    return 0;\n}\n```",
            "answer": "Il flusso dell'operatore di input è invertito. dovrebbe iniziare da `std::cin` e poi fluire (>>) in `str`.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Il flusso dell'operatore di input è invertito. dovrebbe iniziare da `std::cin` e poi fluire (>>) in `str`."
            ],
            "options": [
              "La funzione main dovrebbe avere un tipo di ritorno void.",
              "`std::cin` e `std::cout` non sono validi. I nomi corretti per i flussi di input e output dei caratteri sono `cin` e `cout`.",
              "Dovrebbe essere utilizzato l'indirizzo di `str`. Cioè `&str` invece di `str`.",
              "Il flusso dell'operatore di input è invertito. dovrebbe iniziare da `std::cin` e poi fluire (>>) in `str`."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f2cbe8667a61b2fc6ea46a31",
            "question": "Quando posto in un contesto di esecuzione valido, quale istruzione allocherà dinamicamente memoria dall'heap per un intero con valore 11?",
            "answer": "`int* anInt = new int(11);`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`int* anInt = new int(11);`"],
            "options": [
              "`int anInt = new int(11);`",
              "`int* anInt = new int[11];`",
              "`int anInt = new int[11];`",
              "`int* anInt = new int(11);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4de696c4d836a1d48563dea2",
            "question": "Quale scelta descrive meglio il tipo `long`?",
            "answer": "un numero intero di almeno 32 bit",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["un numero intero di almeno 32 bit"],
            "options": [
              "un numero intero di almeno 32 bit",
              "una stringa con più di 255 caratteri",
              "un puntatore",
              "un numero in virgola mobile a 64 bit"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "601a43bec0b6d283389bbf43",
            "question": "Quale dei seguenti tipi ha la funzionalità più simile a una classe?",
            "answer": "`struct`",
            "explanation": "[Riferimento](https://en.cppreference.com/w/c/language/struct)",
            "hint": null,
            "correctAnswer": ["`struct`"],
            "options": ["`struct`", "`union`", "`enum`", "`namespace`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "33c157aefcb268ec38c74d2f",
            "question": "Dati questi record in una mappa, come aggiornerai il valore per la chiave \"Sinead\" a 22?\n![image](images/Q79.png)",
            "answer": "`marks[\"Sinead\"] = 22`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`marks[\"Sinead\"] = 22`"],
            "options": [
              "`marks[\"Sinead\"] = 22`",
              "`marks[\"Sinead\"].22`",
              "`marks[\"Sinead\"] -> 22`",
              "`marks[\"Sinead\"].value = 22`"
            ],
            "nature": "ChooseOne",
            "attachments": [
              {
                "id": "86c3af326fa06382778cd81e",
                "url": "/Users/arslankaleem/Workspace/Junk/linkedin-skill-assessments-quizzes/c++/images/Q79.png",
                "type": "question"
              }
            ],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "67d9e8538977beae0fc9819a",
            "question": "Perché std::sort può ricevere un oggetto funzione come uno dei suoi parametri?",
            "answer": "`La funzione std::sort è un template. Il programmatore è libero di inserire l'algoritmo di ordinamento in un oggetto funzione come argomento.`",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "`La funzione std::sort è un template. Il programmatore è libero di inserire l'algoritmo di ordinamento in un oggetto funzione come argomento.`"
            ],
            "options": [
              "`La funzione std::sort è un template. Il programmatore è libero di inserire l'algoritmo di ordinamento in un oggetto funzione come argomento.`",
              "`In realtà, std::sort accetta un solo argomento, che è il contenitore da ordinare.`",
              "`std::sort opera su un contenitore template. Il compilatore non sa come confrontare relazionalmente i valori che contiene, quindi deve essere fornita una funzione per fare il confronto.`",
              "`std::sort utilizzerà la funzione parametro come gestore di errori. La funzione verrà chiamata se si verifica un errore.`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "28b1c77cf77255ba7eb6446b",
            "question": "Cosa succederà quando eseguirai questo frammento di codice?\n```\n#include <iostream>\nint main() {\nfloat a = 5.51;\nint b = static_cast<int>(a);\nstd::cout << b;\n}\n```",
            "answer": "`5 verrà stampato sull'output standard, senza avvisi di compilazione generati.`",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "`5 verrà stampato sull'output standard, senza avvisi di compilazione generati.`"
            ],
            "options": [
              "`6 verrà stampato sull'output standard, senza avvisi di compilazione generati.`",
              "`5 verrà stampato sull'output standard, senza avvisi di compilazione generati.`",
              "`6 verrà stampato sull'output standard, con avvisi di compilazione generati.`",
              "`5 verrà stampato sull'output standard, con avvisi di compilazione generati.`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4434dd09feec3fbf475e0859",
            "question": "Quale specificatore di accesso non consente ai membri della classe di essere accessibili dall'esterno della classe, ma consente loro di essere accessibili dalle classi derivate?",
            "answer": "protected",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["protected"],
            "options": ["guarded", "protected", "public", "private"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ae4cd080dc8b232a6500c63d",
            "question": "La generazione eseguibile predefinita su UNIX per un programma C++ è \\_",
            "answer": "a.out",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["a.out"],
            "options": ["a.exe", "a", "a.out", "out.a"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fe8b4dc2203c80c29fdefe4e",
            "question": "Quale sarà l'output del seguente programma?\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\n  int a=1;\n  cout<<(a++)*(++a)<<endl;\n  return 0;\n}\n```",
            "answer": "3",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["3"],
            "options": ["1", "2", "3", "6"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "480e8c7fe95507745be8aed1",
            "question": "Cosa significa \"c\" in cout e cin?",
            "answer": "character",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["character"],
            "options": ["compiler", "console", "character", "standard namespace"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "33ffa014fc2fbc6f6e905c72",
            "question": "Qual è l'uso di tellp()?",
            "answer": "Posizione corrente del puntatore di output",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Posizione corrente del puntatore di output"],
            "options": [
              "Posizione corrente del puntatore di input",
              "Posizione corrente del puntatore di output",
              "Ultima posizione del puntatore di input",
              "Ultima posizione del puntatore di output"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4e62e32941cb0458c2d37a31",
            "question": "Cos'è una funzione callback?",
            "answer": "Puntatore per una funzione",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Puntatore per una funzione"],
            "options": [
              "Puntatore per un puntatore",
              "Puntatore per una funzione",
              "funzione per un puntatore",
              "funzione per una classe"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4f4a9856da1686210e1b328a",
            "question": "Qual è la sintassi corretta per stampare \"Hello World\" in C++?",
            "answer": "`cout << \"Hello World\";`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`cout << \"Hello World\";`"],
            "options": [
              "`cout << \"Hello World\";`",
              "`System.out.println(\"Hello World\");`",
              "`print(\"Hello World\");`",
              "`Console.WriteLine(\"Hello World\");`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "473e2c34b2c225827b0773c0",
            "question": "Quante categorie di iteratori ci sono in C++?",
            "answer": "5",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["4", "3", "7", "5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ba7e9416d3ec0d5052e1c435",
            "question": "Qual è il significato di classe base in C++?",
            "answer": "Un'altra classe è stata ereditata da questa classe",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Un'altra classe è stata ereditata da questa classe"],
            "options": [
              "Eredita altre classi",
              "Ha una variabile puntatore",
              "È la prima classe dichiarata",
              "Un'altra classe è stata ereditata da questa classe"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2142e068f0043618f3963408",
            "question": "La dimensione degli oggetti C++ è espressa in termini di multipli della dimensione di un ** e la dimensione di un char è **.",
            "answer": "char, 1",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["char, 1"],
            "options": ["char, 4", "float, 8", "int, 1", "char, 1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "580bbd2a9a17101126270f12",
            "question": "Gli aspetti dipendenti dall'implementazione relativi a un'implementazione possono essere trovati in",
            "answer": "`<limits>`",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["`<limits>`"],
            "options": ["`<numeric>`", "`<limit>`", "`<limits>`", "`<implementation>`"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fbf2fcb03d651062b522774e",
            "question": "Cos'è un costruttore predefinito?",
            "answer": "un costruttore che può essere utilizzato senza argomenti",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["un costruttore che può essere utilizzato senza argomenti"],
            "options": [
              "un costruttore che può essere utilizzato senza argomenti",
              "un costruttore che non ha un valore di ritorno",
              "un costruttore utilizzato da più classi",
              "un costruttore che inizializza tutti i membri di una classe"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9fd4bf71e302abe11c40e3b9",
            "question": "Quando si protegge un file di intestazione, perché si userebbe '#pragma once' invece della guardia 'include'?",
            "answer": "Una guardia include usa una macro per ottenere l'inclusione singola, ma il compilatore non può impedire al programmatore di definire quella macro altrove, il che risulterebbe in nessuna inclusione",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Una guardia include usa una macro per ottenere l'inclusione singola, ma il compilatore non può impedire al programmatore di definire quella macro altrove, il che risulterebbe in nessuna inclusione"
            ],
            "options": [
              "Non c'è motivo di scegliere perché servono scopi diversi",
              "Una guardia include usa una macro per ottenere l'inclusione singola, ma il compilatore non può impedire al programmatore di definire quella macro altrove, il che risulterebbe in nessuna inclusione",
              "'#pragma once' garantisce che il codice dell'intestazione non verrà mai modificato perché è imposto dal compilatore",
              "Le guardie include si riferiscono al file di intestazione nel file system, non al codice, quindi non sono utili se il file di intestazione esiste più di una volta in un progetto. Questo non è un problema con '#pragma once'"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "dcb3ebc3f94e4991ffe7769a",
            "question": "Quale delle seguenti affermazioni è valida?",
            "answer": "Non possiamo cambiare i template degli operatori.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Non possiamo cambiare i template degli operatori."],
            "options": [
              "Possiamo creare un nuovo operatore C++.",
              "Possiamo cambiare la precedenza dell'operatore C++.",
              "Non possiamo cambiare i template degli operatori.",
              "Possiamo cambiare l'associatività degli operatori C++."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4a44b7f9e3920d1d053daf15",
            "question": "Quale dei seguenti viene/vengono automaticamente aggiunto/i a ogni classe, se non scriviamo il nostro?",
            "answer": "Tutti i precedenti",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Tutti i precedenti"],
            "options": [
              "Costruttore di copia",
              "Operatore di assegnazione",
              "Un costruttore senza parametri",
              "Tutti i precedenti"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "836d7e94de89c781fc2b6efe",
            "question": "L'istruzione if-else può essere sostituita da quale operatore?",
            "answer": "struttura selettiva",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["struttura selettiva"],
            "options": [
              "struttura certa",
              "struttura di scelta",
              "struttura selettiva",
              "Nessuna delle precedenti"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "134ee9655259eef27e369d24",
            "question": "Quale scelta sarebbe una soluzione ricorsiva al problema del fattoriale n!?",
            "answer": "&shy;",
            "explanation": "```cpp\nvoid fact(int n) {\nif (n <= 0)\nreturn 0;\nelse\nreturn 1;\n}\n```\n```cpp\nint fact(int n) {\nif (n <= 0)\nreturn 1;\nelse\nreturn (fact(n) * (n-1));\n}\n```\n```cpp\nint fact(int n) {\nif (n >= 0)\nreturn 1;\nelse\nreturn (fact(n-1) * n);\n}\n```\n```cpp\nint fact(int n) {\nif (n <= 0)\nreturn 1;\nelse\nreturn (fact(n-1) * n);\n}\n```",
            "hint": null,
            "correctAnswer": ["&shy;"],
            "options": ["&shy;", "&shy;", "&shy;", "&shy;"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5a23694e9b72bc2aefaf7322",
            "question": "Un distruttore di classe può essere chiamato quando si verificano una varietà di situazioni. Quale scelta NON è una di quelle situazioni?",
            "answer": "Il garbage collector rileva che un oggetto non verrà più utilizzato.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Il garbage collector rileva che un oggetto non verrà più utilizzato."
            ],
            "options": [
              "Il programma viene terminato. Questo chiama il distruttore degli oggetti di durata statica.",
              "La funzione delete() viene chiamata per un puntatore a oggetto assegnato con l'operatore new.",
              "Il garbage collector rileva che un oggetto non verrà più utilizzato.",
              "Un oggetto di durata di archiviazione automatica esce dallo scope."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "12634689af103cd395e318a0",
            "question": "Stai progettando un sistema di pagamenti in valuta estera in C++. Devi modellare una transazione di una valuta che ha un intero come quantità e un float come prezzo. Vuoi quindi dichiarare un oggetto effettivo di questo tipo. Come lo otterrai?",
            "answer": "A",
            "explanation": "```cpp\nstruct currencyDeal {\nfloat price;\nint quantity;\n};\ncurrencyDeal firstDeal;\n```\n```cpp\nunion currencyDeal {\nfloat price;\nint quantity;\n};\ncurrencyDeal firstDeal;\n```\n```cpp\nstruct currencyDeal {\nfloat price;\nint quantity;\n};\n```\n```cpp\nunion currencyDeal {\nfloat price;\nint quantity;\n};\n```",
            "hint": null,
            "correctAnswer": ["A"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a3eb83a193d245c0db88e7a0",
            "question": "Cosa succederà se tenterai di chiamare questa funzione con checkConcatThreshold(\"a\");?\n```cpp\nint checkConcatThreshold(string a, string b) {\n    return (a + b).length () > 120;\n}\n```",
            "answer": "Si verificherà un errore di compilazione.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Si verificherà un errore di compilazione."],
            "options": [
              "Si verificherà un avviso di compilazione e il secondo argomento riceverà un valore predefinito di b.",
              "Si verificherà un avviso di compilazione e il secondo argomento riceverà un valore predefinito della stringa vuota.",
              "Si verificherà un errore di compilazione.",
              "Non si verificheranno errori di compilazione e nessun avviso di compilazione."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d840b0640920b42c64874e38",
            "question": "Devi definire una funzione lambda C++. Vuoi che la funzione abbia accesso solo alle variabili che le sono locali. La funzione dovrebbe ricevere un singolo parametro, un nome, e costruire un semplice saluto. Come lo otterrai?",
            "answer": "C",
            "explanation": "```cpp\nauto myVeryFirstLambda = [=] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nmyVeryFirstLambda = [&] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nauto myVeryFirstLambda = [] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n```cpp\nmyVeryFirstLambda = [] (string name) {\nreturn \"Hello \" + name + \"!\";\n};\n```\n[Riferimento](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=msvc-160)",
            "hint": null,
            "correctAnswer": ["C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6cbb579e2d083444892c51df",
            "question": "Qual è il valore di X dopo aver eseguito questo codice?\n```cpp\nint x=10, a=-3;\nX+=a;\n```",
            "answer": "7",
            "explanation": "**Spiegazione:** `+=` significa incremento del valore. Quindi `x += a` è equivalente a `x = x + a`",
            "hint": null,
            "correctAnswer": ["7"],
            "options": ["-3", "7", "13", "3"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9958fc89e09d169105fa80c2",
            "question": "Una volta terminata la scrittura su un file, quale metodo chiamerai su `ofstream` per notificare il sistema operativo?",
            "answer": "close()",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["close()"],
            "options": ["printout()", "close()", "destroy()", "flush()"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6df4c9bdab5caffbf90a707d",
            "question": "Quale scelta NON è una parola chiave C++?",
            "answer": "comPl",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["comPl"],
            "options": ["static_assert", "reinterpret_cast", "comPl", "alignas"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0936947d2b37d91204d7b6d3",
            "question": "La funzione size_in_bits sembra accettare qualsiasi tipo di parametro. Questo può essere fatto sovraccaricando la funzione, o lasciando che il compilatore se ne occupi scrivendo un template. Quale scelta è un'implementazione di quel template?\n```cpp\nint main()\n{\ncout « size_in_bits(21) « endl;\ncout « size_in_bits('f') « endl;\ncout « size_in_bits(32.1f) « endl;\ncout « size_in_bits(32.1) « endl;\nreturn 0;\n}\n```",
            "answer": "A; C",
            "explanation": "```cpp\ntemplate <typename T>\nsize_t size_in_bits(const T& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\ntemplate size_t size_in_bits(const {int,float,double,char,long}& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\ntemplate <typename T {int,float,double,char,long>\nsize_t size_in_bits(const T& a){\nreturn sizeof(a)*8;\n}\n```\n```cpp\nsize_t size_in_bits(void * a){\nreturn sizeof(a)*8;\n}\n```",
            "hint": null,
            "correctAnswer": ["A", "C"],
            "options": ["A", "B", "C", "D"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "01c736e47d17409cc8267ddd",
            "question": "Per utilizzare la tastiera come input viene inclusa la libreria iostream. Per leggere l'input da file come input quale libreria è necessaria?",
            "answer": "fstream",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["fstream"],
            "options": ["fstream", "cstdlib", "filestream", "iostream"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6158c4375c15ba11151a5d94",
            "question": "Cosa stamperà questo programma orientato agli oggetti?\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nclass Vehicle {\npublic:\n\tstring fuel = \"none\";\n};\nclass MotorizedVehicle : public Vehicle {\npublic:\n\tstring fuel = \"fossil\";\n};\nclass NextgenMotorizedVehicle : public MotorizedVehicle {\npublic:\n\tstring fuel = \"hydrogen\";\n};\nint main() {\n\tMotorizedVehicle aCar;\n\tcout << aCar.fuel;\n\treturn 0;\n}\n```",
            "answer": "fossil",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["fossil"],
            "options": ["fossil", "fossil none", "hydrogen", "none"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b2a419cb803f916bf11f426e",
            "question": "Il programma seguente gestisce un contenitore stack. Qual è l'output dell'esecuzione del programma?\n```cpp\n#include <iostream>\n#include <stack>\nint main()\n{\n\tstd::stack<int> stack;\n\tstack.push(1);\n\tstack.push(2);\n\tstack.push(3);\n\tstack.pop();\n\tstack.push(4);\n\tstack.top();\n\tstack.pop();\n\tstd::cout << stack.top();\n}\n```",
            "answer": "2",
            "explanation": "#Spiegazione dettagliata:\nQui dovremmo implementare una struttura dati stack che segue il principio **FILO** o (First IN Last Out),\n_stack.push()_ -> inserisce un elemento dalla fine dell'array.\n_stack.pop()_ -> rimuove un elemento dalla fine dell'array.\n_stack.top()_ -> Ci dà solo l'elemento in cima all'array.\nOra seguendo le sequenze di push e pop: **[1,2,3]** poi viene usata la funzione pop,\nL'array appena formato è: **[1,2,4]** poi il top viene usato per recuperare l'elemento in cima '4' poi di nuovo viene usata la funzione pop che rimuove 4.\nquindi, l'array risultante è: 1,2.\nPoi stampa l'elemento in cima (cioè: 2).",
            "hint": null,
            "correctAnswer": ["2"],
            "options": ["1", "2", "3", "4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fbedf84f0cc8b0ebf7dbdb9e",
            "question": "Quale scelta è un modo valido per sovraccaricare l'operatore condizionale ternario?",
            "answer": "`L'operatore ternario non è sovraccaricabile.`",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/language/operators)",
            "hint": null,
            "correctAnswer": ["`L'operatore ternario non è sovraccaricabile.`"],
            "options": [
              "`void& operator ?:(const bool cond, const void& iftrue, const void& iffalse);`",
              "`L'operatore ternario non è sovraccaricabile.`",
              "`void& operator conditional(const bool cond, const void& iftrue, const void& iffalse);`",
              "`void* operator ?:(const bool cond, const void* iftrue, const void* iffalse);`"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d1f7c12e29a163dcb638a8f1",
            "question": "Quale gerarchia di classi rappresenta un esempio di ereditarietà multilivello?",
            "answer": "Nello stesso programma, in punti diversi, una data classe deriva individualmente da più di due classi diverse.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Nello stesso programma, in punti diversi, una data classe deriva individualmente da più di due classi diverse."
            ],
            "options": [
              "Nello stesso programma, in punti diversi, una data classe deriva individualmente da più di una classe diversa.",
              "Una prima classe deriva direttamente, allo stesso tempo, da una seconda e terza classe.",
              "Nello stesso programma, in punti diversi, una data classe deriva individualmente da più di due classi diverse.",
              "Una prima classe deriva da una seconda classe, e quella seconda classe è già derivata da una terza classe"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b9db717e5f2952b09c4bc78a",
            "question": "Qual è la sintassi corretta per stampare il messaggio in linguaggio C++?",
            "answer": "cout <<\"Hello world!\";",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/io/cout)",
            "hint": null,
            "correctAnswer": ["cout <<\"Hello world!\";"],
            "options": [
              "Out <<\"Hello world!",
              "Cout << Hello world! ;",
              "cout <<\"Hello world!\";",
              "Nessuna delle precedenti"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c56c8ba9d41e109a22fa0bb2",
            "question": "Considera il seguente programma. Quale sarà l'output/errore?\n```cpp\n#include<iostream>\n#include<algorithm>\n#include<string.h>\nusing namespace std;\nbool compare(char c1, char c2){\nreturn tolower(c1) > tolower(c2);    //LINE-1\n}\nint main(){\nchar arr1[20] = \"C++ Program\", arr2[20] = \"C Program\";\ncout << lexicographical_compare(arr1, arr1+strlen(arr1), arr2, arr2+strlen(arr2),\ncompare);\nreturn 0;\n}\n```",
            "answer": "1",
            "explanation": "[Riferimento](https://www.geeksforgeeks.org/tolower-function-in-cpp/)",
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["1", "0", "-1", "Errore di compilazione: funzione non definita"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d2a05525dd87b45dcd66decc",
            "question": "Considera il seguente segmento di codice. Riempi lo spazio vuoto alla RIGA-1 in modo che il programma stampi \"not found\"?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint data[] = {1,2,3,4,5};\nint key = 5;\nif(binary_search(__________))    //LINE-1\ncout << \"found\";\nelse\ncout << \"not found\";\nreturn 0;\n}\n```",
            "answer": "&data[0], &data[4], key; data+1, data+4, key",
            "explanation": "[Riferimento](https://www.geeksforgeeks.org/binary-search-algorithms-the-c-standard-template-library-stl/)",
            "hint": null,
            "correctAnswer": ["&data[0], &data[4], key", "data+1, data+4, key"],
            "options": [
              "&data[0], &data[5], key",
              "data, data+5, key",
              "&data[0], &data[4], key",
              "data+1, data+4, key"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b69bc26fa505825085da3375",
            "question": "Considera il seguente segmento di codice. Quale sarà l'output?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main () {\nint data[] = {50, 30, 40, 10, 20};\nsort (&data[1], &data[4]);\nfor (int i = 0; i < 5; i++)\ncout << data[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "50 10 30 40 20",
            "explanation": "[Riferimento](https://cplusplus.com/reference/algorithm/sort/)",
            "hint": null,
            "correctAnswer": ["50 10 30 40 20"],
            "options": ["10 20 30 40 50", "10 30 40 50 20", "50 10 30 40 20", "50 10 20 30 40"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "dca623a53ce7d4dd21861180",
            "question": "Considera il seguente segmento di codice. Quale sarà l'output?\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint element[5];\nfor(int i = 1; i <= 5; i++)\n*(element + i - 1) = i * 5;\nrotate(element, element + 4, element + 5);\nrotate(element, element + 1, element + 4);\nfor (int i = 0; i < 5; ++i)\ncout << element[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "5 10 15 25 20",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/algorithm/rotate)",
            "hint": null,
            "correctAnswer": ["5 10 15 25 20"],
            "options": ["5 10 15 20 25", "5 10 15 25 20", "20 10 15 25 5", "25 5 10 15 20"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "550cfb5b34db781ed2dc5b08",
            "question": "Considera il seguente segmento di codice. Quale sarà l'output?\n```cpp\n#include <iostream>\n#include <vector>\nusing namespace std;\nint main() {\nconst int size = 3, c = 65;\nvector<char> vc(size, 'A');\nfor (int i = 1; i <= 2; i++)\nvc.push_back(65 + i);\nvc.resize(10, 90);\nvc.resize(8);\nfor (int i = 0; i < vc.size(); i++)\ncout << vc[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "A A A B C Z Z Z",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/container/vector)",
            "hint": null,
            "correctAnswer": ["A A A B C Z Z Z"],
            "options": ["A A A B C Z Z Z", "A A B B C Z Z Z", "A A A B C Z Z", "A A A B C Z Z Z Z"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d1fece91fc8709ff4088e091",
            "question": "Considera il seguente segmento di codice. Scegli l'opzione appropriata per riempire lo spazio vuoto alla RIGA-1, in modo che l'output del codice sia: a C++ Program.\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\nint main(void) {\nstring s1 = \"C++ \";\nstring s2 = \"Program\";\n__________________;    //LINE-1\ncout << s1;\nreturn 0;\n}\n```",
            "answer": "s1 += s2; s1.append(s2)",
            "explanation": "[Riferimento](https://www.geeksforgeeks.org/stdstringappend-in-c/)",
            "hint": null,
            "correctAnswer": ["s1 += s2", "s1.append(s2)"],
            "options": ["s1 += s2", "strcat(s1, s2)", "s1.append(s2)", "s1.insert(s2)"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "282c1bf756f5bce89cebe458",
            "question": "Considera il seguente segmento di codice. Riempi lo spazio vuoto alla RIGA-1 in modo che l'output sia 5 2 3 4 5\n```cpp\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\nint data[] = { 1, 2, 3, 4, 5 };\nfor (int i = 0; i < 1; i++) {\nint j = data[i];\nreplace(data, data + 5, j, *(_________________));    //LINE-1\n}\nfor (int i = 0; i < 5; ++i)\ncout << data[i] << \" \";\nreturn 0;\n}\n```",
            "answer": "data + 4 - i",
            "explanation": "[Riferimento](https://www.geeksforgeeks.org/stdstringreplace-stdstringreplace_if-c/)",
            "hint": null,
            "correctAnswer": ["data + 4 - i"],
            "options": ["data + 4 - i", "data + 5 - i", "data + i - 4", "data + i - 5"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "679e7e91c972cddd98fe83db",
            "question": "Considera il seguente segmento di codice. Quale sarà l'output?\n```cpp\n#include <iostream>\n#include <cstring>\n#include <stack>\nusing namespace std;\nint main(){\nchar str[10] = \"123456789\";\nstack<char> s1, s2;\nint i;\nfor(i = 0; i < strlen(str)/2; i++)\ns1.push(str[i]);\nfor(i=i-1; i < strlen(str); i++)\ns2.push(str[i]);\nwhile (!s1.empty()) {\ns2.push(s1.top()); s1.pop();\n}\nwhile (!s2.empty()) {\ncout << s2.top(); s2.pop();\n}\nreturn 0;\n}\n```",
            "answer": "1234987654",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/container/stack)",
            "hint": null,
            "correctAnswer": ["1234987654"],
            "options": ["1234987654", "123498765", "1234897654", "123459876"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fda903a8b9c152b1ffdb87cc",
            "question": "Considera il seguente segmento di codice. Quale/i istruzione/i è/sono corretta/e?\n```cpp\nint i = 5;\nconst int *p = &i;\nint * const q = &i;\nint const *r = &i;\nint const * const s = &i;\n*p = 10; //STMT-1\n*q = 10; //STMT-2\n*r = 10; //STMT-3\n*s = 10; //STMT-4\n```",
            "answer": "STMT-2",
            "explanation": "[Riferimento](https://www.geeksforgeeks.org/const-keyword-in-cpp/)",
            "hint": null,
            "correctAnswer": ["STMT-2"],
            "options": ["STMT-1", "STMT-2", "STMT-3", "STMT-4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "aafd5df5a7bea6146f7c9f39",
            "question": "Considera il seguente programma. Quale sarà l'output/errore(i)?\n```cpp\n#include <iostream>\nusing namespace std;\nchar add(char c1 = 'a') { return c1; }\nchar add(char c1 = 'a', char c2 = 'b') { return c1 + c2 - 'a';}\nchar add(char c1 = 'a', int d1 = 100){ return c1 + d1 - 'a'; }\nchar add(char c1 = 'a', char c2 = 'b', char c3) { return c1 + c2 + c3 - 'a'; }\nint main() {\nchar c = add('o', 'k');\ncout << c << endl;\nreturn 0;\n}\n```",
            "answer": "Errore di compilazione: argomento predefinito mancante per \"char add(char, char, char)\"; Errore di compilazione: chiamata di sovraccarico \"add(char, char)\" è ambigua",
            "explanation": "[Riferimento](https://learn.microsoft.com/en-us/cpp/cpp/function-overloading?view=msvc-170)",
            "hint": null,
            "correctAnswer": [
              "Errore di compilazione: argomento predefinito mancante per \"char add(char, char, char)\"",
              "Errore di compilazione: chiamata di sovraccarico \"add(char, char)\" è ambigua"
            ],
            "options": [
              "y",
              "z",
              "Errore di compilazione: argomento predefinito mancante per \"char add(char, char, char)\"",
              "Errore di compilazione: chiamata di sovraccarico \"add(char, char)\" è ambigua"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7d0d9919c7721df0936595ae",
            "question": "Considera il seguente segmento di codice. Quale sarà l'output?\n```cpp\n#include <iostream>\nusing namespace std;\n#define SQR(x) (x)*(x)\nint main() {\nint a=3;\ncout << SQR(a++) << endl;\nreturn 0;\n}\n```",
            "answer": "12",
            "explanation": "[Riferimento](https://www.geeksforgeeks.org/output-of-the-program-use-macros-carefully/)",
            "hint": null,
            "correctAnswer": ["12"],
            "options": ["12", "25", "9", "16"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6dcb7096c3391a9718408426",
            "question": "Considera il seguente segmento di codice. Quale/i riga/righe darà/daranno un errore?\n```cpp\n#include<iostream>\n#define X 1\nusing namespace std;\nint main(){\nint i;\nconst int i1 = 2;\nconst int i2 = i1; //LINE-1\ni2 = X;\ni = i1;\ni1 = i;\nreturn 0;\n//LINE-2\n//LINE-3\n//LINE-4\n}\n```",
            "answer": "LINE-2; LINE-4",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["LINE-2", "LINE-4"],
            "options": ["LINE-1", "LINE-2", "LINE-3", "LINE-4"],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c8cfee50c895248b8ff6a56d",
            "question": "Considera il seguente segmento di codice. Quale sarà l'output/errore?\n```cpp\n#include<iostream>\nusing namespace std;\nint main(){\nint a = 5;\nint &b = a+1;\na = a*b;\ncout << a << \" \" << b;\nreturn 0;\n}\n```",
            "answer": "Errore di compilazione: inizializzazione non valida di riferimento non const",
            "explanation": "#Spiegazione dettagliata:\nL'errore si verifica perché sta cercando di creare un riferimento a un valore temporaneo. Nella riga int &b = a+1; stiamo tentando di creare un riferimento b al risultato dell'espressione a + 1, che è un valore temporaneo. I riferimenti devono essere legati a un oggetto effettivo, non a un valore temporaneo o a un'espressione che non ha una posizione di memoria.",
            "hint": null,
            "correctAnswer": [
              "Errore di compilazione: inizializzazione non valida di riferimento non const"
            ],
            "options": [
              "36",
              "30",
              "25",
              "Errore di compilazione: inizializzazione non valida di riferimento non const"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3d7ba1de81dce0c3cabe7f2d",
            "question": "Considera il seguente segmento di codice. Quale sarà l'output?\n```cpp\n#include <iostream>\nusing namespace std;\nint& func(int& i) {     //LINE-1\nreturn i = i+5;\n}\nint main() {\nint x = 1, y = 2;\nint& z = func(x);\ncout << x << \" \" << z << \" \";\nfunc(x) = y;\ncout << x << \" \" << z;\nreturn 0;\n}\n```",
            "answer": "6 6 2 2",
            "explanation": "[Riferimento](https://www.ibm.com/docs/en/zos/2.4.0?topic=calls-pass-by-reference-c-only)",
            "hint": null,
            "correctAnswer": ["6 6 2 2"],
            "options": ["6 6 2 2", "6 6 7 7", "1 1 2 2", "1 1 7 7"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4b7d6b85294fcc2fe917521f",
            "question": "Considera il seguente segmento di codice. Scegli l'opzione appropriata per riempire gli spazi vuoti alla RIGA-1, in modo che l'output del codice sia: 300 20000.\n```cpp\n#include <iostream>\nusing namespace std;\nvoid compute(int n1, int n2, ________, ________){ //LINE-1\nn3 = n1 + n2;\n*n4 = n1 * n2;\n}\nint main(){\nint a = 100, b = 200, c = 0, d = 0;\ncompute(a, b, c, &d); //LINE-2\ncout << c << \", \";\ncout << d;\nreturn 0;\n}\n```",
            "answer": "int& n3, int \\*n4",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["int& n3, int \\*n4"],
            "options": [
              "int n3, int\\* n4",
              "int& n3, int \\*n4",
              "int* n3, int* n4",
              "int& n3, int& n4"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f20393e68ca48be9cf6c526d",
            "question": "Considera il seguente segmento di codice. Quale sarà l'output/errore?\n```cpp\n#include <iostream>\nusing namespace std;\nint main() {\nint a = 2, *b;\n*b = 5;\nint * const ptr;    // LINE-1\n// LINE-2\nptr = b;\ncout << *ptr;\nreturn 0;\n}\n```",
            "answer": "Errore di compilazione alla RIGA-1: 'ptr' const non inizializzato; Errore di compilazione alla RIGA-2: assegnazione della variabile di sola lettura 'ptr'",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Errore di compilazione alla RIGA-1: 'ptr' const non inizializzato",
              "Errore di compilazione alla RIGA-2: assegnazione della variabile di sola lettura 'ptr'"
            ],
            "options": [
              "`<valore spazzatura>`",
              "5",
              "Errore di compilazione alla RIGA-1: 'ptr' const non inizializzato",
              "Errore di compilazione alla RIGA-2: assegnazione della variabile di sola lettura 'ptr'"
            ],
            "nature": "ChooseMany",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "19e66be1b81ae96501422ea8",
            "question": "Considera il seguente segmento di codice. Quale sarà l'output/errore?\n```cpp\n#include <iostream>\nusing namespace std;\nvoid fun(int a = 5) { cout << a << endl; }\n//LINE-1\nint fun(int x = 10) { cout << x << endl; return 0; }    //LINE-2\nint main() {\nfun();\nreturn 0;\n}\n```",
            "answer": "Errore di compilazione alla RIGA-2: dichiarazione ambigua di 'int fun(int)'",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Errore di compilazione alla RIGA-2: dichiarazione ambigua di 'int fun(int)'"
            ],
            "options": [
              "5",
              "10",
              "5",
              "Errore di compilazione alla RIGA-2: dichiarazione ambigua di 'int fun(int)'"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8e4f878522139fd70ad59363",
            "question": "Considera il seguente segmento di codice. Riempi lo spazio vuoto alla RIGA-1 in modo che il programma stampi 5 + i3\n```cpp\n#include<iostream>\nusing namespace std;\nstruct complex{\nint re, im;\nvoid show(){ cout << re << \" + i\" << im; }\n};\n______________________________________{ //Line-1\nc2.re = c1.re+c2.re;\nc2.im = c1.im+c2.im;\nreturn c2;\n}\nint main(){\nstruct complex c1={2,5},c2{3,-2};\nstruct complex t = c1 + c2;\nt.show();\nreturn 0;\n}\n```",
            "answer": "complex operator+(complex &c1, complex &c2)",
            "explanation": "[Riferimento](https://www.w3schools.com/cpp/cpp_structs.asp)",
            "hint": null,
            "correctAnswer": ["complex operator+(complex &c1, complex &c2)"],
            "options": [
              "complex operator+(complex &c1, complex &c2)",
              "complex operator+(const complex &c1, const complex &c2)",
              "operator+(complex &c1, complex &c2)",
              "complex +(complex &c1, complex &c2)"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b33bfe15f10f9c08ebbde9f7",
            "question": "Considera il seguente programma. Quale/i riga/righe genererà/genereranno un errore?\n```cpp\n#include<iostream>\nusing namespace std;\nclass myClass{\nint pra = 5;\npublic:\nint pub = 10;\nvoid set_pr(int x){ pra = x; }\nvoid set_pu(int x){ pub = x; }\n};\nint main(){\nmyClass m;\nint a, b;\na = m.pra; //LINE-1\nb = m.pub; //LINE-2\nm.set_pr(100); //LINE-3\nm.set_pu(200); //LINE-4\nreturn 0;\n}\n```",
            "answer": "LINE-1",
            "explanation": "[Riferimento](https://stackoverflow.com/questions/4855422/c-classes-public-private-and-protected)",
            "hint": null,
            "correctAnswer": ["LINE-1"],
            "options": ["LINE-1", "LINE-2", "LINE-3", "LINE-4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a787abd42a32aa825b2f20a8",
            "question": "Considera la seguente classe. Riempi gli spazi vuoti con gli specificatori di accesso appropriati in modo che il membro y possa essere accessibile dall'esterno della classe ma il membro x non possa essere accessibile.\n```cpp\nclass Test{\n________:\nint x;\n________:\nint y;\n/* Altro codice */\n};\n```",
            "answer": "private, public",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["private, public"],
            "options": ["public, public", "public, private", "private, public", "private, private"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d8848fdcfd0e075012288aae",
            "question": "Quale standard C++ ha aggiunto gli inizializzatori di membri predefiniti in-class?",
            "answer": "C++11",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C++11"],
            "options": ["C++98", "C++11", "C++14", "C++17."],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e35b693e92c3cd2dc40358bf",
            "question": "Puoi usare la deduzione del tipo auto per i membri dati non statici?",
            "answer": "No",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["No"],
            "options": ["Sì, da C++11", "No", "Sì, da C++20"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "77e8f5e7b86fe261e3d83714",
            "question": "Devi definire un membro dati static inline in un file cpp?",
            "answer": "No, la definizione avviene nello stesso punto in cui viene dichiarato un membro static inline.",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/language/bit_field)",
            "hint": null,
            "correctAnswer": [
              "No, la definizione avviene nello stesso punto in cui viene dichiarato un membro static inline."
            ],
            "options": [
              "No, la definizione avviene nello stesso punto in cui viene dichiarato un membro static inline.",
              "Sì, il compilatore ha bisogno della definizione in un file cpp.",
              "Sì, il compilatore ha bisogno di una definizione in tutte le unità di traduzione che usano questa variabile."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "52861ba0cb8c85b491ee3155",
            "question": "Qual è l'output del seguente codice:\n```cpp\nstruct S {\n    int a { 10 };\n    int b { 42 };\n};\nS s { 1 };\nstd::cout << s.a << \", \" << s.b;\n```",
            "answer": "L'output è: 1, 42",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["L'output è: 1, 42"],
            "options": ["L'output è: 1, 0", "L'output è: 10, 42", "L'output è: 1, 42"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b91394b32f1473a82a78c06e",
            "question": "Una variabile static inline può essere non costante?",
            "answer": "Sì, è solo una variabile normale.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Sì, è solo una variabile normale."],
            "options": [
              "Sì, è solo una variabile normale.",
              "No, le variabili inline devono essere costanti."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a2045d17a4d35f7544ff0535",
            "question": "Considera il seguente codice:\n```cpp\nstruct C {\n    C(int x) : a(x) { }\n    int a { 10 };\n    int b { 42 };\n};\nC c(0);\n```",
            "answer": "C::a viene inizializzato solo una volta con 0 nel costruttore.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["C::a viene inizializzato solo una volta con 0 nel costruttore."],
            "options": [
              "C::a viene inizializzato due volte. La prima volta, viene inizializzato con 10, e poi la seconda volta con 0 nel costruttore.",
              "C::a viene inizializzato solo una volta con 0 nel costruttore.",
              "Il codice non compila perché il compilatore non può decidere come inizializzare il membro C::a.",
              "2 byte"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2063936d230a07a871802968",
            "question": "Cosa succede quando lanci un'eccezione da un costruttore?",
            "answer": "L'oggetto è considerato \"parzialmente creato\", e quindi il compilatore non chiamerà il suo distruttore.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "L'oggetto è considerato \"parzialmente creato\", e quindi il compilatore non chiamerà il suo distruttore."
            ],
            "options": [
              "L'oggetto è considerato \"creato\" quindi seguirà il ciclo di vita regolare di un oggetto.",
              "L'oggetto è considerato \"parzialmente creato\", e quindi il compilatore non chiamerà il suo distruttore.",
              "Il compilatore chiama std::terminate poiché non puoi lanciare eccezioni dai costruttori."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9be25523c14eef356594faed",
            "question": "Cosa succede quando compili questo codice?\n```cpp\nstruct Point { int x; int y; };\nPoint pt {.y = 10, .x = 11 };\nstd::cout << pt.x << \", \" << pt.y;\n```",
            "answer": "Il codice non compila. I designatori devono essere nello stesso ordine dei membri dati nella classe Point.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Il codice non compila. I designatori devono essere nello stesso ordine dei membri dati nella classe Point."
            ],
            "options": [
              "Il codice non compila. I designatori devono essere nello stesso ordine dei membri dati nella classe Point.",
              "Il codice compila e stampa 11, 10.",
              "Il codice compila e stampa 10, 11."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "12c22a82ec5a891c9cf2a754",
            "question": "Questo codice funzionerà in C++11?\n```cpp\nstruct User { std::string name = \"unknown\"; unsigned age { 0 }; };\nUser u { \"John\", 101 };\n```",
            "answer": "Il codice compila a partire dalla modalità C++14.",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Il codice compila a partire dalla modalità C++14."],
            "options": [
              "Sì, il codice compila in modalità C++11.",
              "Il codice compila a partire dalla modalità C++14.",
              "Il codice non compila nemmeno in C++20."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b9bf2f699284ae872e43a396",
            "question": "Supponi di avere un std::map<string, int> m;. Seleziona l'unica affermazione vera sul seguente ciclo:\n```cpp\nfor (const pair<string, int>& elem : m)\n```",
            "answer": "A Il ciclo itera correttamente sulla mappa, non creando copie extra.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "A Il ciclo itera correttamente sulla mappa, non creando copie extra."
            ],
            "options": [
              "A Il ciclo itera correttamente sulla mappa, non creando copie extra.",
              "B Il ciclo creerà una copia di ogni elemento nella mappa poiché il tipo di elem non corrisponde.",
              "C Il codice non compilerà poiché una coppia const non può essere vincolata a una mappa."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ae289c3411685603712c6a71",
            "question": "Identifica l'estensione corretta del file di intestazione definito dall'utente in C++.",
            "answer": ".h",
            "explanation": null,
            "hint": null,
            "correctAnswer": [".h"],
            "options": [".cpp", ".hg", ".h", ".hf"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "3abe9fdc53d901b51505f9a6",
            "question": "Identifica il tipo di costruttore errato.\n```cpp\nauto x = 4000.22;\n```",
            "answer": "Costruttore Friend",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Costruttore Friend"],
            "options": [
              "Costruttore Friend",
              "Costruttore predefinito",
              "Costruttore parametrizzato",
              "Costruttore di copia"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d257e9ccf946307c32f1f94e",
            "question": "Quale dei seguenti tipi di dati è supportato in C++ ma non in C?",
            "answer": "bool",
            "explanation": "[Riferimento]: https://stackoverflow.com/questions/1608318/is-bool-a-native-c-type",
            "hint": null,
            "correctAnswer": ["bool"],
            "options": ["bool", "int", "double", "float"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "11d1c98058c6f3e56616dbeb",
            "question": "Identifica la sintassi corretta per dichiarare array in C++.",
            "answer": "int arr[10]",
            "explanation": "[Riferimento]: (https://en.cppreference.com/w/cpp/language/array)",
            "hint": null,
            "correctAnswer": ["int arr[10]"],
            "options": ["int arr[10]", "array arr[10]", "array{10}", "int arr"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "344b558cb149f17205dcd47a",
            "question": "La dimensione di wchat_t è.",
            "answer": "Dipende dal numero di bit nel sistema",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Dipende dal numero di bit nel sistema"],
            "options": ["2", "4", "2 o 4", "Dipende dal numero di bit nel sistema"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7fe729dd1cc2bb9d3a1b758f",
            "question": "Quale dei seguenti cicli è migliore quando conosciamo il numero di iterazioni?",
            "answer": "for",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["for"],
            "options": ["while", "for", "do", "Tutti i precedenti"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "360e4470c84f28b8986a0410",
            "question": "Quale parola chiave viene utilizzata per definire le macro in C++?",
            "answer": "#define",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["#define"],
            "options": ["#macro", "#define", "macro", "keyword"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "32bb7282c617c78ec79a9800",
            "question": "Quale dei seguenti operatori dovrebbe essere preferibilmente sovraccaricato come funzione globale piuttosto che come metodo membro?",
            "answer": "Operatore di confronto",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Operatore di confronto"],
            "options": [
              "Postfisso ++",
              "Operatore di confronto",
              "Operatore di inserimento <<",
              "Prefisso++"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "69c5413442da2162cb6b5e5e",
            "question": "Come possiamo limitare l'allocazione dinamica di oggetti di una classe usando new?",
            "answer": "Rendendo privati operatori new e new[] vuoti",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Rendendo privati operatori new e new[] vuoti"],
            "options": [
              "Sovraccaricando l'operatore new",
              "Rendendo privato un operatore new vuoto.",
              "Rendendo privati operatori new e new[] vuoti",
              "Sovraccaricando gli operatori new e new[]"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9145b7ca9b2002eb8fbecea3",
            "question": "Qual è la complessità temporale del codice seguente?\n```cpp\nfor(int i=0;i<n;i++){\n   for(int j=0;j<n;j++){\n       cout<<\"hello\";\n    }\n}\n```",
            "answer": "O(n^2)",
            "explanation": "[Riferimento](<https://medium.com/enjoy-algorithm/analysis-of-loop-in-programming-cc9a644ef8cd#:~:text=At%20each%20step%20of%20the%20iteration%2C%20the%20nested%20loop%20is,%20%3D%20O(n%C2%B2)>)",
            "hint": null,
            "correctAnswer": ["O(n^2)"],
            "options": ["O(n^3)", "O(n^2)", "O(n)", "O(1)"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "64e49dd15cefa2387afec56d",
            "question": "Qual è l'output del codice fornito qui sotto?\n```cpp\nint a=10;\nint k=++a;\nint m=a++;\ncout<<k+m;\n```",
            "answer": "22",
            "explanation": "Sia **++a** che **a++** aumentano il valore di a di 1 (cioè: 11) e quindi k+m diventa 22.",
            "hint": null,
            "correctAnswer": ["22"],
            "options": ["20", "21", "22", "23"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "646b874c7789525e061269d8",
            "question": "Quale costrutto C++ viene utilizzato per la gestione delle eccezioni?",
            "answer": "try-catch",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["try-catch"],
            "options": ["try-catch", "if-else", "ciclo for", "switch-case"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "87c74b044d6a60929681ec3b",
            "question": "Qual è lo scopo dell'istruzione `break` in un ciclo in C++?",
            "answer": "Terminare il ciclo",
            "explanation": "[Riferimento]: (https://www.tutorialspoint.com/cprogramming/c_break_statement.htm)",
            "hint": null,
            "correctAnswer": ["Terminare il ciclo"],
            "options": [
              "Uscire dal programma",
              "Saltare l'iterazione corrente e continuare con la successiva",
              "Terminare il ciclo",
              "Restituire un valore"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "da599f080f59f3a47c0f8263",
            "question": "In C++, qual è lo scopo della parola chiave `const` quando usata con una variabile?",
            "answer": "Rende la variabile immutabile",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Rende la variabile immutabile"],
            "options": [
              "Rende la variabile immutabile",
              "Cambia il tipo di dato",
              "Definisce una funzione costante",
              "Rende la variabile un puntatore"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "2770abc63d23ea3155fda5fd",
            "question": "Quale è più efficace durante la chiamata di funzioni C++?",
            "answer": "Chiamata per riferimento",
            "explanation": "[Riferimento]: (https://www.algbly.com/More/MCQs/Cpp-mcq/Cpp-functions.html)",
            "hint": null,
            "correctAnswer": ["Chiamata per riferimento"],
            "options": [
              "Chiamata per riferimento",
              "Chiamata per valore",
              "Chiamata per puntatore",
              "Chiamata per oggetto"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8b2bfad9e660f14aedbf08c9",
            "question": "Quale sarà l'output del seguente programma C++?\n```cpp\n#include <iostream>\nusing namespace std;\nclass A{\npublic:\n\tA(){\n\t\tcout<<\"Constructor called\\n\";\n\t   }\n\t~A(){\n\t\tcout<<\"Destructor called\\n\";\n\t    }\n};\nint main(int argc, char const *argv[])\n{\n\tA *a = new A[5];\n\tdelete[] a;\n\treturn 0;\n}\n```",
            "answer": "\"Constructor called\" cinque volte e poi \"Destructor called\" cinque volte",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "\"Constructor called\" cinque volte e poi \"Destructor called\" cinque volte"
            ],
            "options": [
              "Segmentation fault",
              "\"Constructor called\" cinque volte e poi \"Destructor called\" cinque volte",
              "\"Constructor called\" cinque volte e poi \"Destructor called\" una volta",
              "Errore"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "67dbbf58c0534a1ff2234b01",
            "question": "Quale scelta NON è correlata alla dichiarazione della variabile membro count come statica in my_class?\n```cpp\nclass my_class{\n    public: static int count;\n}\n```",
            "answer": "La variabile non può essere modificata da nessuna parte del codice nella stessa applicazione o thread. Tuttavia, altri thread possono modificarla.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "La variabile non può essere modificata da nessuna parte del codice nella stessa applicazione o thread. Tuttavia, altri thread possono modificarla."
            ],
            "options": [
              "Tutti gli oggetti che cercano di accedere alla loro variabile membro count in realtà si riferiscono all'unica variabile statica count legata alla classe.",
              "La variabile esiste anche quando non sono stati definiti oggetti della classe, quindi può essere modificata in qualsiasi punto del codice sorgente.",
              "La variabile non può essere modificata da nessuna parte del codice nella stessa applicazione o thread. Tuttavia, altri thread possono modificarla.",
              "La variabile viene allocata una sola volta, indipendentemente da quanti oggetti vengono istanziati, perché è legata alla classe stessa, non alle sue istanze."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b0e1c61ee1a7ac8df87caf07",
            "question": "Qual è lo scopo della parola chiave `constexpr` in C++?",
            "answer": "`constexpr` viene utilizzata per indicare che un'espressione può essere valutata in fase di compilazione, rendendola adatta per l'uso in espressioni costanti.",
            "explanation": "[Rif](https://learn.microsoft.com/en-us/cpp/cpp/constexpr-cpp?view=msvc-170#:~:text=constexpr%20indicates%20that%20the%20value,template%20arguments%20and%20array%20declarations.)",
            "hint": null,
            "correctAnswer": [
              "`constexpr` viene utilizzata per indicare che un'espressione può essere valutata in fase di compilazione, rendendola adatta per l'uso in espressioni costanti."
            ],
            "options": [
              "Viene utilizzata per definire costanti in C++.",
              "`constexpr` viene utilizzata per specificare che una variabile è un puntatore costante.",
              "`constexpr` viene utilizzata per indicare che un'espressione può essere valutata in fase di compilazione, rendendola adatta per l'uso in espressioni costanti.",
              "È una parola chiave utilizzata per creare funzioni asincrone."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5601f1404f2901a2355b5bbd",
            "question": "Cos'è un metaprogramma template in C++?\n- Rif(https://www.geeksforgeeks.org/template-metaprogramming-in-c/)",
            "answer": "Un metaprogramma template è un calcolo in fase di compilazione, dove i template e la specializzazione dei template vengono utilizzati per eseguire calcoli in fase di compilazione.",
            "explanation": null,
            "hint": null,
            "correctAnswer": [
              "Un metaprogramma template è un calcolo in fase di compilazione, dove i template e la specializzazione dei template vengono utilizzati per eseguire calcoli in fase di compilazione."
            ],
            "options": [
              "Un metaprogramma template è un linguaggio di programmazione di alto livello.",
              "Si riferisce alla metaprogrammazione che usa template in C++.",
              "È un tipo di pattern di design dell'interfaccia utente.",
              "Un metaprogramma template è un calcolo in fase di compilazione, dove i template e la specializzazione dei template vengono utilizzati per eseguire calcoli in fase di compilazione."
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ae0f8ca77994844526d1342f",
            "question": "Identifica l'esempio corretto per un operatore di pre-incremento.",
            "answer": "++i",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["++i"],
            "options": ["++i", "i++", "--i", "+i"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "755fab2e76cab2fd299a6314",
            "question": "Quale sarà l'output del seguente codice?\n```cpp\n{% raw %}\nint matrix[3][3] = {{1, 2, 3},{4, 5, 6},{7, 8, 9}};\nfor(int i=0;i<3;i++){\n    for(int j=0;j<3;j++){\n        int a = matrix[i][j];\n        matrix[i][j] = matrix[j][i];\n        matrix[j][i] = a;\n    }\n}\n{% endraw %}\n```",
            "answer": "Stessa matrice",
            "explanation": null,
            "hint": null,
            "correctAnswer": ["Stessa matrice"],
            "options": [
              "Trasposta della matrice",
              "Stessa matrice",
              "Immagine speculare della matrice",
              "Matrice invertita"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7d11fe0a1f7ec1a0dfe67d85",
            "question": "Cos'è una race condition in C++?",
            "answer": "Una condizione in cui più thread accedono a dati condivisi contemporaneamente, e il risultato dipende dalla tempistica della loro esecuzione",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/language/memory_model)",
            "hint": null,
            "correctAnswer": [
              "Una condizione in cui più thread accedono a dati condivisi contemporaneamente, e il risultato dipende dalla tempistica della loro esecuzione"
            ],
            "options": [
              "Una condizione in cui il programma viene eseguito più velocemente del previsto",
              "Una condizione in cui più thread accedono a dati condivisi contemporaneamente, e il risultato dipende dalla tempistica della loro esecuzione",
              "Una condizione in cui due thread competono per il tempo della CPU",
              "Una condizione in cui un ciclo viene eseguito troppo rapidamente e deve essere rallentato"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0c6e7b7775dfbab4bf309f50",
            "question": "Considera il seguente codice che ha una race condition. Qual è il modo corretto per risolverlo?\n```cpp\n#include <thread>\n#include <vector>\nint counter = 0;\nvoid incrementCounter() {\n    for(int i = 0; i < 1000; i++) {\n        counter++;\n    }\n}\nint main() {\n    std::vector<std::thread> threads;\n    for(int i = 0; i < 10; i++) {\n        threads.push_back(std::thread(incrementCounter));\n    }\n    for(auto& t : threads) {\n        t.join();\n    }\n    return 0;\n}\n```",
            "answer": "Usare `std::mutex` per bloccare/sbloccare intorno a `counter++` nella sezione critica",
            "explanation": "[Riferimento](https://en.cppreference.com/w/cpp/thread/mutex)",
            "hint": null,
            "correctAnswer": [
              "Usare `std::mutex` per bloccare/sbloccare intorno a `counter++` nella sezione critica"
            ],
            "options": [
              "Aggiungere la parola chiave `volatile`: `volatile int counter = 0;`",
              "Usare `std::mutex` per bloccare/sbloccare intorno a `counter++` nella sezione critica",
              "Usare `std::this_thread::sleep_for()` per ritardare ogni incremento",
              "Cambiare `counter++` in `++counter` per un'operazione atomica"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a707d60d47f5b94f1bd8a9c0",
            "question": "Qual è lo scopo di `std::move` in C++11?",
            "answer": "Convertire un oggetto in un riferimento rvalue, abilitando la semantica di spostamento",
            "explanation": "**Spiegazione:**\n`std::move` è un cast che produce un riferimento rvalue al suo argomento, permettendo alle risorse di essere spostate anziché copiate. Non sposta effettivamente nulla da solo, ma abilita la chiamata di costruttori di spostamento e operatori di assegnazione di spostamento.\n[Riferimento](https://en.cppreference.com/w/cpp/utility/move)",
            "hint": null,
            "correctAnswer": [
              "Convertire un oggetto in un riferimento rvalue, abilitando la semantica di spostamento"
            ],
            "options": [
              "Copiare un oggetto in una nuova posizione",
              "Convertire un oggetto in un riferimento rvalue, abilitando la semantica di spostamento",
              "Spostare fisicamente la memoria da un indirizzo a un altro",
              "Eliminare un oggetto e crearne uno nuovo"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "b8f233df811c2da3e3a491af",
            "question": "Qual è l'output di questo codice?\n```cpp\n#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v1 = {1, 2, 3};\n    std::vector<int> v2 = std::move(v1);\n    std::cout << v1.size() << \" \" << v2.size();\n    return 0;\n}\n```",
            "answer": "0 3",
            "explanation": "**Spiegazione:**\nDopo `std::move(v1)`, v1 è in uno stato valido ma non specificato. Tipicamente, diventa vuoto (size 0) e v2 assume la proprietà degli elementi.\n[Riferimento](https://en.cppreference.com/w/cpp/utility/move)",
            "hint": null,
            "correctAnswer": ["0 3"],
            "options": ["3 3", "0 3", "3 0", "Errore di compilazione"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "88afbaa678fe13e2d87e3928",
            "question": "Cos'è un'espressione lambda in C++?",
            "answer": "Un oggetto funzione anonimo che può catturare variabili dal suo ambito contenitore",
            "explanation": "**Spiegazione:**\nLe espressioni lambda, introdotte in C++11, permettono di scrivere funzioni anonime inline. Possono catturare variabili dall'ambito circostante e sono spesso usate con gli algoritmi STL.\n[Riferimento](https://en.cppreference.com/w/cpp/language/lambda)",
            "hint": null,
            "correctAnswer": [
              "Un oggetto funzione anonimo che può catturare variabili dal suo ambito contenitore"
            ],
            "options": [
              "Una funzione matematica",
              "Un oggetto funzione anonimo che può catturare variabili dal suo ambito contenitore",
              "Una funzione template",
              "Una definizione di macro"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "fa24e15f2579a42212467e47",
            "question": "Cosa fa la parola chiave `auto` in C++11?",
            "answer": "Deduce automaticamente il tipo di una variabile dal suo inizializzatore",
            "explanation": "**Spiegazione:**\nLa parola chiave `auto` in C++11 abilita la deduzione automatica del tipo dall'inizializzatore, rendendo il codice più conciso e facile da mantenere.\n[Riferimento](https://en.cppreference.com/w/cpp/language/auto)",
            "hint": null,
            "correctAnswer": [
              "Deduce automaticamente il tipo di una variabile dal suo inizializzatore"
            ],
            "options": [
              "Rende una variabile con durata di archiviazione automatica",
              "Deduce automaticamente il tipo di una variabile dal suo inizializzatore",
              "Rende una funzione inline",
              "Dichiara una variabile globale"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6678dc129896161f76eae581",
            "question": "Qual è la differenza tra `std::unique_ptr` e `std::shared_ptr`?",
            "answer": "unique_ptr ha proprietà esclusiva, shared_ptr permette proprietari multipli",
            "explanation": "**Spiegazione:**\n`std::unique_ptr` fornisce proprietà esclusiva - solo un unique_ptr può possedere una risorsa. `std::shared_ptr` usa il conteggio dei riferimenti per permettere a più shared_ptr di possedere la stessa risorsa.\n[Riferimento](https://en.cppreference.com/w/cpp/memory/unique_ptr)",
            "hint": null,
            "correctAnswer": [
              "unique_ptr ha proprietà esclusiva, shared_ptr permette proprietari multipli"
            ],
            "options": [
              "unique_ptr ha proprietà esclusiva, shared_ptr permette proprietari multipli",
              "unique_ptr è più veloce ma meno sicuro",
              "shared_ptr può essere usato solo con le classi",
              "Non c'è differenza"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c91d7b03a8f7eae16a07121d",
            "question": "Cos'è RAII in C++?",
            "answer": "Resource Acquisition Is Initialization (Acquisizione della Risorsa è Inizializzazione)",
            "explanation": "**Spiegazione:**\nRAII è un idioma di programmazione C++ dove l'acquisizione delle risorse è legata alla vita dell'oggetto. Le risorse vengono acquisite nei costruttori e rilasciate nei distruttori, garantendo una pulizia corretta.\n[Riferimento](https://en.cppreference.com/w/cpp/language/raii)",
            "hint": null,
            "correctAnswer": [
              "Resource Acquisition Is Initialization (Acquisizione della Risorsa è Inizializzazione)"
            ],
            "options": [
              "Random Access Iterator Interface",
              "Resource Acquisition Is Initialization (Acquisizione della Risorsa è Inizializzazione)",
              "Recursive Algorithm Implementation Interface",
              "Runtime Allocation and Initialization"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "057cbddd9de563833d5ceb81",
            "question": "Qual è l'output di questo codice?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    auto lambda = [x]() mutable { x += 10; return x; };\n    std::cout << lambda() << \" \" << x;\n    return 0;\n}\n```",
            "answer": "15 5",
            "explanation": "**Spiegazione:**\nLa lambda cattura x per valore. La parola chiave `mutable` permette la modifica della copia catturata. L'x originale rimane invariato.\n[Riferimento](https://en.cppreference.com/w/cpp/language/lambda)",
            "hint": null,
            "correctAnswer": ["15 5"],
            "options": ["5 5", "15 5", "15 15", "5 15"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d60f11e10552e189bedae19d",
            "question": "Cos'è `constexpr` in C++11?",
            "answer": "Specifica che una funzione o variabile può essere valutata a tempo di compilazione",
            "explanation": "**Spiegazione:**\n`constexpr` indica che un valore o una funzione può essere valutato a tempo di compilazione, abilitando calcoli e ottimizzazioni a tempo di compilazione.\n[Riferimento](https://en.cppreference.com/w/cpp/language/constexpr)",
            "hint": null,
            "correctAnswer": [
              "Specifica che una funzione o variabile può essere valutata a tempo di compilazione"
            ],
            "options": [
              "Un'espressione costante che può essere usata solo con interi",
              "Specifica che una funzione o variabile può essere valutata a tempo di compilazione",
              "Una macro per definire costanti",
              "Una parola chiave per dichiarare puntatori const"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "60071ae3232df2c479c6e034",
            "question": "Qual è lo scopo di `std::forward`?",
            "answer": "Preservare la categoria di valore (lvalue/rvalue) di un argomento inoltrato",
            "explanation": "**Spiegazione:**\n`std::forward` è usato nelle funzioni template per inoltrare perfettamente gli argomenti preservando la loro categoria di valore, essenziale per implementare l'inoltro perfetto.\n[Riferimento](https://en.cppreference.com/w/cpp/utility/forward)",
            "hint": null,
            "correctAnswer": [
              "Preservare la categoria di valore (lvalue/rvalue) di un argomento inoltrato"
            ],
            "options": [
              "Spostare un oggetto in avanti nella memoria",
              "Preservare la categoria di valore (lvalue/rvalue) di un argomento inoltrato",
              "Iterare in avanti attraverso un contenitore",
              "Dichiarare una dichiarazione anticipata"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5078a6cbd2975fffb4a9dd9e",
            "question": "Cos'è un template variadico?",
            "answer": "Un template che accetta un numero variabile di parametri template",
            "explanation": "**Spiegazione:**\nI template variadici, introdotti in C++11, permettono ai template di accettare qualsiasi numero di argomenti template, abilitando una programmazione generica flessibile.\n[Riferimento](https://en.cppreference.com/w/cpp/language/parameter_pack)",
            "hint": null,
            "correctAnswer": ["Un template che accetta un numero variabile di parametri template"],
            "options": [
              "Un template con tipi di ritorno variabili",
              "Un template che accetta un numero variabile di parametri template",
              "Un template che può essere istanziato più volte",
              "Un template con parametri opzionali"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "50a395a23e7f9d65b77df415",
            "question": "Cosa rappresenta `nullptr`?",
            "answer": "Una costante puntatore nullo con tipo std::nullptr_t",
            "explanation": "**Spiegazione:**\n`nullptr` è una parola chiave introdotta in C++11 che rappresenta un puntatore nullo. È type-safe a differenza di NULL o 0.\n[Riferimento](https://en.cppreference.com/w/cpp/language/nullptr)",
            "hint": null,
            "correctAnswer": ["Una costante puntatore nullo con tipo std::nullptr_t"],
            "options": [
              "Un carattere nullo",
              "Una costante puntatore nullo con tipo std::nullptr_t",
              "Una stringa vuota",
              "Valore zero"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d41c8d82a1bf55d73d16a8ec",
            "question": "Qual è l'output di questo codice?\n```cpp\n#include <iostream>\n#include <memory>\nint main() {\n    std::shared_ptr<int> p1 = std::make_shared<int>(42);\n    std::shared_ptr<int> p2 = p1;\n    std::cout << p1.use_count();\n    return 0;\n}\n```",
            "answer": "2",
            "explanation": "**Spiegazione:**\nSia p1 che p2 condividono la proprietà dello stesso intero, quindi il conteggio dei riferimenti è 2.\n[Riferimento](https://en.cppreference.com/w/cpp/memory/shared_ptr)",
            "hint": null,
            "correctAnswer": ["2"],
            "options": ["1", "2", "42", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "36b00c5f9925a9467707911d",
            "question": "Cos'è `std::optional` in C++17?",
            "answer": "Un wrapper che può contenere o meno un valore",
            "explanation": "**Spiegazione:**\n`std::optional` è una classe template che rappresenta un valore opzionale - contiene un valore oppure è vuoto, fornendo un modo type-safe per rappresentare \"nessun valore\".\n[Riferimento](https://en.cppreference.com/w/cpp/utility/optional)",
            "hint": null,
            "correctAnswer": ["Un wrapper che può contenere o meno un valore"],
            "options": [
              "Un parametro opzionale in una funzione",
              "Un wrapper che può contenere o meno un valore",
              "Un template per la compilazione opzionale",
              "Una parola chiave per tipi opzionali"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "64f2a655fd956610ef29cc8f",
            "question": "Cos'è il binding strutturato in C++17?\n```cpp\nauto [x, y, z] = std::make_tuple(1, 2, 3);\n```",
            "answer": "Una funzionalità che spacchetta oggetti simili a tuple in variabili individuali",
            "explanation": "**Spiegazione:**\nI binding strutturati permettono di decomporre oggetti nei loro elementi costituenti, rendendo il codice più leggibile quando si lavora con tuple, coppie o struct.\n[Riferimento](https://en.cppreference.com/w/cpp/language/structured_binding)",
            "hint": null,
            "correctAnswer": [
              "Una funzionalità che spacchetta oggetti simili a tuple in variabili individuali"
            ],
            "options": [
              "Un modo per legare le strutture insieme",
              "Una funzionalità che spacchetta oggetti simili a tuple in variabili individuali",
              "Un metodo per creare dati strutturati",
              "Un binding per membri struct"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8072ebb64ee8607845606896",
            "question": "Cos'è `std::string_view` in C++17?",
            "answer": "Un riferimento non proprietario a una stringa che evita la copia",
            "explanation": "**Spiegazione:**\n`std::string_view` fornisce un riferimento leggero e non proprietario a una stringa, evitando copie non necessarie e migliorando le prestazioni.\n[Riferimento](https://en.cppreference.com/w/cpp/string/basic_string_view)",
            "hint": null,
            "correctAnswer": ["Un riferimento non proprietario a una stringa che evita la copia"],
            "options": [
              "Una vista di una stringa in un'interfaccia grafica",
              "Un riferimento non proprietario a una stringa che evita la copia",
              "Una stringa che può solo essere visualizzata, non modificata",
              "Una classe view per visualizzare stringhe"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1817ad7c517c39c48411da10",
            "question": "Cosa sono i concepts in C++20?",
            "answer": "Insiemi nominati di requisiti per i parametri template",
            "explanation": "**Spiegazione:**\nI concepts sono una funzionalità di C++20 che permette di specificare vincoli sui parametri template, rendendo il codice template più leggibile e fornendo messaggi di errore migliori.\n[Riferimento](https://en.cppreference.com/w/cpp/language/constraints)",
            "hint": null,
            "correctAnswer": ["Insiemi nominati di requisiti per i parametri template"],
            "options": [
              "Idee astratte nella programmazione",
              "Insiemi nominati di requisiti per i parametri template",
              "Pattern di progettazione concettuali",
              "Commenti di documentazione"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a6e6ac5e1675f6f3d098e297",
            "question": "Cos'è l'operatore di confronto a tre vie (<=>) in C++20?",
            "answer": "Un operatore che restituisce informazioni sull'ordinamento (minore, uguale, maggiore)",
            "explanation": "**Spiegazione:**\nL'operatore spaceship (<=>) esegue un confronto a tre vie e restituisce una categoria di ordinamento, semplificando le definizioni degli operatori di confronto.\n[Riferimento](https://en.cppreference.com/w/cpp/language/operator_comparison)",
            "hint": null,
            "correctAnswer": [
              "Un operatore che restituisce informazioni sull'ordinamento (minore, uguale, maggiore)"
            ],
            "options": [
              "Un confronto di tre valori",
              "Un operatore che restituisce informazioni sull'ordinamento (minore, uguale, maggiore)",
              "Tre operatori di confronto separati",
              "Un confronto ternario"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6557e7a78cc1a4e11e7e1bb8",
            "question": "Cos'è `std::span` in C++20?",
            "answer": "Una vista non proprietaria su una sequenza contigua di oggetti",
            "explanation": "**Spiegazione:**\n`std::span` fornisce una vista su una sequenza contigua di oggetti senza possederli, utile per passare dati simili ad array senza copiarli.\n[Riferimento](https://en.cppreference.com/w/cpp/container/span)",
            "hint": null,
            "correctAnswer": ["Una vista non proprietaria su una sequenza contigua di oggetti"],
            "options": [
              "Una misurazione dell'intervallo di tempo",
              "Una vista non proprietaria su una sequenza contigua di oggetti",
              "Una struttura dati ad albero ricoprente",
              "Un elemento span in HTML"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "822db5d94f6b83cbdc2780e1",
            "question": "Qual è l'output di questo codice?\n```cpp\n#include <iostream>\n#include <vector>\nint main() {\n    std::vector<int> v = {1, 2, 3, 4, 5};\n    for (auto& x : v) {\n        x *= 2;\n    }\n    std::cout << v[2];\n    return 0;\n}\n```",
            "answer": "6",
            "explanation": "**Spiegazione:**\nIl ciclo for basato su range con `auto&` modifica ogni elemento sul posto. v[2] (originariamente 3) diventa 6.\n[Riferimento](https://en.cppreference.com/w/cpp/language/range-for)",
            "hint": null,
            "correctAnswer": ["6"],
            "options": ["3", "6", "2", "12"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "faaf7ae5cf39e5a8f3420493",
            "question": "Cos'è `std::variant` in C++17?",
            "answer": "Un'unione type-safe che può contenere uno di diversi tipi",
            "explanation": "**Spiegazione:**\n`std::variant` è un'unione type-safe che può contenere un valore di uno tra diversi tipi specificati, fornendo un'alternativa più sicura alle union C.\n[Riferimento](https://en.cppreference.com/w/cpp/utility/variant)",
            "hint": null,
            "correctAnswer": ["Un'unione type-safe che può contenere uno di diversi tipi"],
            "options": [
              "Una variabile che può variare",
              "Un'unione type-safe che può contenere uno di diversi tipi",
              "Una variante di una classe",
              "Un template variabile"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1ba89cb78189ca819f91a78d",
            "question": "Cos'è `std::any` in C++17?",
            "answer": "Un contenitore type-safe per singoli valori di qualsiasi tipo",
            "explanation": "**Spiegazione:**\n`std::any` può memorizzare un singolo valore di qualsiasi tipo copy-constructible, fornendo archiviazione type-safe con controllo del tipo a runtime.\n[Riferimento](https://en.cppreference.com/w/cpp/utility/any)",
            "hint": null,
            "correctAnswer": ["Un contenitore type-safe per singoli valori di qualsiasi tipo"],
            "options": [
              "Qualsiasi tipo di variabile",
              "Un contenitore type-safe per singoli valori di qualsiasi tipo",
              "Un tipo jolly",
              "Un tipo opzionale"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "625a38b9ba37f9fad9f0339b",
            "question": "Qual è la differenza tra `std::array` e gli array in stile C?",
            "answer": "std::array conosce la sua dimensione e fornisce funzioni membro",
            "explanation": "**Spiegazione:**\n`std::array` è un contenitore che incapsula array a dimensione fissa, fornendo informazioni sulla dimensione e l'interfaccia del contenitore STL mantenendo le prestazioni degli array in stile C.\n[Riferimento](https://en.cppreference.com/w/cpp/container/array)",
            "hint": null,
            "correctAnswer": ["std::array conosce la sua dimensione e fornisce funzioni membro"],
            "options": [
              "std::array conosce la sua dimensione e fornisce funzioni membro",
              "std::array è più lento",
              "Gli array in stile C sono più sicuri",
              "Non c'è differenza"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "d7e78549f3c0c54e367ee2b5",
            "question": "Cos'è l'inoltro perfetto?",
            "answer": "Preservare la categoria di valore degli argomenti quando vengono passati a un'altra funzione",
            "explanation": "**Spiegazione:**\nL'inoltro perfetto usa `std::forward` e riferimenti universali per passare argomenti a un'altra funzione preservando la loro categoria di valore (lvalue o rvalue).\n[Riferimento](https://en.cppreference.com/w/cpp/utility/forward)",
            "hint": null,
            "correctAnswer": [
              "Preservare la categoria di valore degli argomenti quando vengono passati a un'altra funzione"
            ],
            "options": [
              "Inoltro senza errori",
              "Preservare la categoria di valore degli argomenti quando vengono passati a un'altra funzione",
              "Passaggio veloce dei parametri",
              "Dichiarazione anticipata di funzioni"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4168524405d0a5c436457d13",
            "question": "Qual è l'output di questo codice?\n```cpp\n#include <iostream>\ntemplate<typename T>\nvoid func(T&& x) {\n    std::cout << std::is_lvalue_reference<T>::value;\n}\nint main() {\n    int a = 5;\n    func(a);\n    return 0;\n}\n```",
            "answer": "1",
            "explanation": "**Spiegazione:**\nQuando un lvalue viene passato a un riferimento universale, T viene dedotto come un riferimento lvalue, quindi `std::is_lvalue_reference<T>::value` è true (1).\n[Riferimento](https://en.cppreference.com/w/cpp/language/reference)",
            "hint": null,
            "correctAnswer": ["1"],
            "options": ["1", "0", "5", "Errore di compilazione"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5994b92fbe8e999d79952dfd",
            "question": "Cos'è `std::invoke` in C++17?",
            "answer": "Un'utilità per chiamare qualsiasi oggetto chiamabile con argomenti dati",
            "explanation": "**Spiegazione:**\n`std::invoke` fornisce un modo uniforme per chiamare qualsiasi chiamabile (funzione, puntatore a funzione, funzione membro, funtore) con argomenti.\n[Riferimento](https://en.cppreference.com/w/cpp/utility/functional/invoke)",
            "hint": null,
            "correctAnswer": [
              "Un'utilità per chiamare qualsiasi oggetto chiamabile con argomenti dati"
            ],
            "options": [
              "Una funzione per invocare programmi",
              "Un'utilità per chiamare qualsiasi oggetto chiamabile con argomenti dati",
              "Un operatore di invocazione del metodo",
              "Un invocatore per costruttori"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "9ffda3d0f2e17566f9c48ff7",
            "question": "Cos'è `if constexpr` in C++17?",
            "answer": "Un condizionale a tempo di compilazione che scarta i rami a tempo di compilazione",
            "explanation": "**Spiegazione:**\n`if constexpr` valuta la condizione a tempo di compilazione e istanzia solo il ramo preso, utile nella metaprogrammazione template.\n[Riferimento](https://en.cppreference.com/w/cpp/language/if)",
            "hint": null,
            "correctAnswer": [
              "Un condizionale a tempo di compilazione che scarta i rami a tempo di compilazione"
            ],
            "options": [
              "Un'istruzione if costante",
              "Un condizionale a tempo di compilazione che scarta i rami a tempo di compilazione",
              "Un'istruzione if che deve essere costante",
              "Una funzione constexpr con if"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "4445a64f7921ef6edf0322dc",
            "question": "Cos'è un'espressione fold in C++17?",
            "answer": "Un modo per applicare un operatore binario a tutti gli elementi di un parameter pack",
            "explanation": "**Spiegazione:**\nLe espressioni fold forniscono una sintassi concisa per applicare operatori binari ai parameter pack nei template variadici.\n[Riferimento](https://en.cppreference.com/w/cpp/language/fold)",
            "hint": null,
            "correctAnswer": [
              "Un modo per applicare un operatore binario a tutti gli elementi di un parameter pack"
            ],
            "options": [
              "Un'espressione che piega il codice",
              "Un modo per applicare un operatore binario a tutti gli elementi di un parameter pack",
              "Un algoritmo di piegatura",
              "Un'espressione per piegare contenitori"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "aa82d996e40005e693cdd877",
            "question": "Qual è l'output di questo codice?\n```cpp\n#include <iostream>\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    int* p = arr;\n    std::cout << *(p + 3);\n    return 0;\n}\n```",
            "answer": "4",
            "explanation": "**Spiegazione:**\nAritmetica dei puntatori: p + 3 punta al 4° elemento (indice 3), che è 4.\n[Riferimento](https://en.cppreference.com/w/cpp/language/operator_arithmetic)",
            "hint": null,
            "correctAnswer": ["4"],
            "options": ["1", "2", "3", "4"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6d0fbc8a469c48361f25871c",
            "question": "Cos'è `std::filesystem` in C++17?",
            "answer": "Una libreria per eseguire operazioni su file system e percorsi",
            "explanation": "**Spiegazione:**\n`std::filesystem` fornisce funzionalità per eseguire operazioni su file system e i loro componenti, come percorsi, file regolari e directory.\n[Riferimento](https://en.cppreference.com/w/cpp/filesystem)",
            "hint": null,
            "correctAnswer": ["Una libreria per eseguire operazioni su file system e percorsi"],
            "options": [
              "Un driver del file system",
              "Una libreria per eseguire operazioni su file system e percorsi",
              "Un file system virtuale",
              "Una classe di flusso di file"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "06b1f414ee537c3bc46c1de3",
            "question": "Per cosa viene usato `std::atomic`?",
            "answer": "Operazioni thread-safe su variabili condivise senza lock",
            "explanation": "**Spiegazione:**\n`std::atomic` fornisce operazioni atomiche su variabili condivise, garantendo accesso thread-safe senza locking esplicito.\n[Riferimento](https://en.cppreference.com/w/cpp/atomic/atomic)",
            "hint": null,
            "correctAnswer": ["Operazioni thread-safe su variabili condivise senza lock"],
            "options": [
              "Calcoli di energia atomica",
              "Operazioni thread-safe su variabili condivise senza lock",
              "Tipi di dati atomici",
              "Operazioni indivisibili su atomi"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "31f6a7564e5ea58fe95d238a",
            "question": "Qual è la differenza tra `std::mutex` e `std::recursive_mutex`?",
            "answer": "recursive_mutex può essere bloccato più volte dallo stesso thread",
            "explanation": "**Spiegazione:**\n`std::recursive_mutex` permette allo stesso thread di bloccarlo più volte, mentre `std::mutex` andrebbe in deadlock se lo stesso thread tentasse di bloccarlo due volte.\n[Riferimento](https://en.cppreference.com/w/cpp/thread/recursive_mutex)",
            "hint": null,
            "correctAnswer": ["recursive_mutex può essere bloccato più volte dallo stesso thread"],
            "options": [
              "recursive_mutex può essere bloccato più volte dallo stesso thread",
              "mutex è più veloce",
              "recursive_mutex è deprecato",
              "Non c'è differenza"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "31735a67be3cea0d819b1e07",
            "question": "Cos'è `std::future` in C++11?",
            "answer": "Un oggetto che fornisce accesso al risultato di un'operazione asincrona",
            "explanation": "**Spiegazione:**\n`std::future` viene usato per recuperare il risultato di un'operazione asincrona avviata con `std::async` o `std::promise`.\n[Riferimento](https://en.cppreference.com/w/cpp/thread/future)",
            "hint": null,
            "correctAnswer": [
              "Un oggetto che fornisce accesso al risultato di un'operazione asincrona"
            ],
            "options": [
              "Una versione futura di C++",
              "Un oggetto che fornisce accesso al risultato di un'operazione asincrona",
              "Una classe basata sul tempo",
              "Una dichiarazione futura"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5c1ab333eaec35368426daef",
            "question": "Qual è l'output di questo codice?\n```cpp\n#include <iostream>\nclass Base {\npublic:\n    virtual void show() { std::cout << \"Base\"; }\n};\nclass Derived : public Base {\npublic:\n    void show() override { std::cout << \"Derived\"; }\n};\nint main() {\n    Base* b = new Derived();\n    b->show();\n    delete b;\n    return 0;\n}\n```",
            "answer": "Derived",
            "explanation": "**Spiegazione:**\nGrazie al polimorfismo delle funzioni virtuali, viene chiamato show() della classe Derived anche se il puntatore è di tipo Base\\*.\n[Riferimento](https://en.cppreference.com/w/cpp/language/virtual)",
            "hint": null,
            "correctAnswer": ["Derived"],
            "options": ["Base", "Derived", "Errore di compilazione", "Comportamento indefinito"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a6e463243e57041b2c79dd51",
            "question": "Per cosa viene usato `std::enable_if`?",
            "answer": "Per l'istanziazione condizionale di template basata su SFINAE",
            "explanation": "**Spiegazione:**\n`std::enable_if` viene usato per SFINAE (Substitution Failure Is Not An Error) per abilitare o disabilitare condizionalmente specializzazioni di template.\n[Riferimento](https://en.cppreference.com/w/cpp/types/enable_if)",
            "hint": null,
            "correctAnswer": ["Per l'istanziazione condizionale di template basata su SFINAE"],
            "options": [
              "Per abilitare istruzioni if",
              "Per l'istanziazione condizionale di template basata su SFINAE",
              "Per abilitare funzionalità",
              "Per verificare se qualcosa è abilitato"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e0942170017876609bb65809",
            "question": "Cos'è `std::tuple` in C++11?",
            "answer": "Una collezione a dimensione fissa di valori eterogenei",
            "explanation": "**Spiegazione:**\n`std::tuple` è una collezione a dimensione fissa che può contenere elementi di tipi diversi, generalizzando `std::pair` a qualsiasi numero di elementi.\n[Riferimento](https://en.cppreference.com/w/cpp/utility/tuple)",
            "hint": null,
            "correctAnswer": ["Una collezione a dimensione fissa di valori eterogenei"],
            "options": [
              "Una coppia di due elementi",
              "Una collezione a dimensione fissa di valori eterogenei",
              "Una tripla di valori",
              "Una tupla in matematica"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "0a2b97627cb7b50a68585f80",
            "question": "Qual è l'output di questo codice?\n```cpp\n#include <iostream>\nint main() {\n    int x = 10;\n    int& ref = x;\n    ref = 20;\n    std::cout << x;\n    return 0;\n}\n```",
            "answer": "20",
            "explanation": "**Spiegazione:**\nref è un riferimento a x. Modificare ref modifica direttamente x, quindi x diventa 20.\n[Riferimento](https://en.cppreference.com/w/cpp/language/reference)",
            "hint": null,
            "correctAnswer": ["20"],
            "options": ["10", "20", "Errore di compilazione", "Indefinito"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "161be836e588054094a63f7e",
            "question": "Per cosa viene usato `std::chrono`?",
            "answer": "Utilità per il tempo che includono orologi, punti temporali e durate",
            "explanation": "**Spiegazione:**\n`std::chrono` è una libreria per operazioni relative al tempo, fornendo orologi, punti temporali e durate con type safety.\n[Riferimento](https://en.cppreference.com/w/cpp/chrono)",
            "hint": null,
            "correctAnswer": [
              "Utilità per il tempo che includono orologi, punti temporali e durate"
            ],
            "options": [
              "Ordinamento cronologico",
              "Utilità per il tempo che includono orologi, punti temporali e durate",
              "Funzioni cronometro",
              "Gestione di malattie croniche"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6d5a8f6227fbeb2db1266f37",
            "question": "Cos'è `std::regex` in C++11?",
            "answer": "Una libreria per il pattern matching con espressioni regolari",
            "explanation": "**Spiegazione:**\n`std::regex` fornisce supporto per espressioni regolari per il pattern matching e l'elaborazione del testo in C++.\n[Riferimento](https://en.cppreference.com/w/cpp/regex)",
            "hint": null,
            "correctAnswer": ["Una libreria per il pattern matching con espressioni regolari"],
            "options": [
              "Un motore di espressioni regolari",
              "Una libreria per il pattern matching con espressioni regolari",
              "Uno strumento di sostituzione testo",
              "Un formattatore di stringhe"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "c8d3dfe36a50adf04b8fc9df",
            "question": "Cos'è `std::initializer_list`?",
            "answer": "Un oggetto proxy leggero per accedere ad array di const T",
            "explanation": "**Spiegazione:**\n`std::initializer_list` permette alle funzioni di accettare liste di valori racchiuse tra parentesi graffe, abilitando la sintassi di inizializzazione uniforme.\n[Riferimento](https://en.cppreference.com/w/cpp/utility/initializer_list)",
            "hint": null,
            "correctAnswer": ["Un oggetto proxy leggero per accedere ad array di const T"],
            "options": [
              "Una lista di inizializzatori",
              "Un oggetto proxy leggero per accedere ad array di const T",
              "Una funzione di inizializzazione",
              "Un costruttore di lista"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "925cfd491ed3485991f95acd",
            "question": "Qual è l'output di questo codice?\n```cpp\n#include <iostream>\nint main() {\n    const int x = 10;\n    int* p = const_cast<int*>(&x);\n    *p = 20;\n    std::cout << x;\n    return 0;\n}\n```",
            "answer": "10 (comportamento indefinito)",
            "explanation": "**Spiegazione:**\nQuesto è un comportamento indefinito. Modificare un oggetto const attraverso const_cast porta a risultati imprevedibili. Il compilatore può ottimizzare basandosi sull'assunzione di const.\n[Riferimento](https://en.cppreference.com/w/cpp/language/const_cast)",
            "hint": null,
            "correctAnswer": ["10 (comportamento indefinito)"],
            "options": ["10 (comportamento indefinito)", "20", "Errore di compilazione", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8921e0a7670bfb3544db8ab0",
            "question": "Cos'è `std::function` in C++11?",
            "answer": "Un wrapper di funzione polimorfico general-purpose",
            "explanation": "**Spiegazione:**\n`std::function` è un wrapper type-erased che può memorizzare qualsiasi oggetto chiamabile (funzione, lambda, funtore) con una firma specifica.\n[Riferimento](https://en.cppreference.com/w/cpp/utility/functional/function)",
            "hint": null,
            "correctAnswer": ["Un wrapper di funzione polimorfico general-purpose"],
            "options": [
              "Una dichiarazione di funzione",
              "Un wrapper di funzione polimorfico general-purpose",
              "Un puntatore a funzione",
              "Una libreria di programmazione funzionale"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "1144260fa9b77fca04710d40",
            "question": "Per cosa viene usato `std::bind`?",
            "answer": "Per creare un nuovo chiamabile legando argomenti a una funzione",
            "explanation": "**Spiegazione:**\n`std::bind` crea un nuovo oggetto funzione legando alcuni argomenti a una funzione, utile per l'applicazione parziale di funzioni.\n[Riferimento](https://en.cppreference.com/w/cpp/utility/functional/bind)",
            "hint": null,
            "correctAnswer": ["Per creare un nuovo chiamabile legando argomenti a una funzione"],
            "options": [
              "Per legare variabili insieme",
              "Per creare un nuovo chiamabile legando argomenti a una funzione",
              "Per legare classi",
              "Per legare memoria"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7cfdc2f81ce0f23e8d95cef3",
            "question": "Su cosa si basa `std::unordered_map`?",
            "answer": "Tabella hash",
            "explanation": "**Spiegazione:**\n`std::unordered_map` è implementato usando una tabella hash, fornendo un tempo di ricerca medio O(1) rispetto a O(log n) per `std::map`.\n[Riferimento](https://en.cppreference.com/w/cpp/container/unordered_map)",
            "hint": null,
            "correctAnswer": ["Tabella hash"],
            "options": ["Albero di ricerca binario", "Tabella hash", "Lista concatenata", "Array"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "796374b5ffc3d936783b5c2c",
            "question": "Qual è l'output di questo codice?\n```cpp\n#include <iostream>\nint main() {\n    int arr[] = {1, 2, 3, 4, 5};\n    std::cout << sizeof(arr) / sizeof(arr[0]);\n    return 0;\n}\n```",
            "answer": "5",
            "explanation": "**Spiegazione:**\nsizeof(arr) dà i byte totali, sizeof(arr[0]) dà i byte per elemento. La divisione dà il numero di elementi: 5.\n[Riferimento](https://en.cppreference.com/w/cpp/language/sizeof)",
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["4", "5", "20", "1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a58243e9a9fa9d972630615e",
            "question": "Cos'è `std::make_unique` in C++14?",
            "answer": "Una funzione per creare oggetti std::unique_ptr",
            "explanation": "**Spiegazione:**\n`std::make_unique` è una funzione di utilità che crea e restituisce un `std::unique_ptr`, fornendo sicurezza dalle eccezioni e una sintassi più pulita.\n[Riferimento](https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique)",
            "hint": null,
            "correctAnswer": ["Una funzione per creare oggetti std::unique_ptr"],
            "options": [
              "Un generatore di identificatori unici",
              "Una funzione per creare oggetti std::unique_ptr",
              "Un verificatore di unicità",
              "Un creatore di valori unici"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "51bbb2ebf004f45dc1b1cc4a",
            "question": "Cos'è `std::exchange` in C++14?",
            "answer": "Sostituisce un valore e restituisce il vecchio valore atomicamente",
            "explanation": "**Spiegazione:**\n`std::exchange` sostituisce il valore di un oggetto e restituisce il suo vecchio valore in una singola operazione.\n[Riferimento](https://en.cppreference.com/w/cpp/utility/exchange)",
            "hint": null,
            "correctAnswer": ["Sostituisce un valore e restituisce il vecchio valore atomicamente"],
            "options": [
              "Un programma di scambio di valori",
              "Sostituisce un valore e restituisce il vecchio valore atomicamente",
              "Un operatore di scambio",
              "Una funzione swap"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "7ae7cf2438f8992bf58f11e2",
            "question": "Cos'è `std::apply` in C++17?",
            "answer": "Invoca un chiamabile con una tupla di argomenti",
            "explanation": "**Spiegazione:**\n`std::apply` invoca un oggetto chiamabile con una tupla di argomenti, spacchettando la tupla come argomenti della funzione.\n[Riferimento](https://en.cppreference.com/w/cpp/utility/apply)",
            "hint": null,
            "correctAnswer": ["Invoca un chiamabile con una tupla di argomenti"],
            "options": [
              "Un lanciatore di applicazioni",
              "Invoca un chiamabile con una tupla di argomenti",
              "Una funzione apply",
              "Un applicatore di funzioni"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "97029215536f2281306effb0",
            "question": "Qual è l'output di questo codice?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    int y = ++x + x++;\n    std::cout << y;\n    return 0;\n}\n```",
            "answer": "Comportamento indefinito",
            "explanation": "**Spiegazione:**\nModificare x più volte tra punti di sequenza porta a comportamento indefinito. Il risultato è imprevedibile.\n[Riferimento](https://en.cppreference.com/w/cpp/language/eval_order)",
            "hint": null,
            "correctAnswer": ["Comportamento indefinito"],
            "options": ["11", "12", "Comportamento indefinito", "13"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e86e7b2ce9cce3ef0ed170d8",
            "question": "Cos'è `std::decay` in C++11?",
            "answer": "Applica array-to-pointer, function-to-pointer e rimuove i qualificatori cv",
            "explanation": "**Spiegazione:**\n`std::decay` applica trasformazioni di tipo simili a ciò che accade quando si passano argomenti per valore.\n[Riferimento](https://en.cppreference.com/w/cpp/types/decay)",
            "hint": null,
            "correctAnswer": [
              "Applica array-to-pointer, function-to-pointer e rimuove i qualificatori cv"
            ],
            "options": [
              "Una funzione di decadimento",
              "Applica array-to-pointer, function-to-pointer e rimuove i qualificatori cv",
              "Un marcatore di deprecazione",
              "Una costante di decadimento"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "f0b3273b29b4b5bcd6de5a74",
            "question": "Cos'è `std::conditional` in C++11?",
            "answer": "Sceglie un tipo o un altro basandosi su un booleano a tempo di compilazione",
            "explanation": "**Spiegazione:**\n`std::conditional` è una metafunzione che seleziona uno di due tipi basandosi su una condizione booleana a tempo di compilazione.\n[Riferimento](https://en.cppreference.com/w/cpp/types/conditional)",
            "hint": null,
            "correctAnswer": [
              "Sceglie un tipo o un altro basandosi su un booleano a tempo di compilazione"
            ],
            "options": [
              "Un'istruzione condizionale",
              "Sceglie un tipo o un altro basandosi su un booleano a tempo di compilazione",
              "Un operatore condizionale",
              "Un verificatore di condizioni"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ad2684296eb165aa3ebafa3a",
            "question": "Per cosa viene usato `std::is_same`?",
            "answer": "Per verificare se due tipi sono uguali a tempo di compilazione",
            "explanation": "**Spiegazione:**\n`std::is_same` è un type trait che verifica se due tipi sono identici a tempo di compilazione.\n[Riferimento](https://en.cppreference.com/w/cpp/types/is_same)",
            "hint": null,
            "correctAnswer": ["Per verificare se due tipi sono uguali a tempo di compilazione"],
            "options": [
              "Per verificare se i valori sono uguali",
              "Per verificare se due tipi sono uguali a tempo di compilazione",
              "Per confrontare oggetti",
              "Per verificare l'uguaglianza"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "99010de768bf7bcddf4ac6d4",
            "question": "Qual è l'output di questo codice?\n```cpp\n#include <iostream>\nint main() {\n    int x = 10;\n    int* p = &x;\n    int** pp = &p;\n    std::cout << **pp;\n    return 0;\n}\n```",
            "answer": "10",
            "explanation": "**Spiegazione:**\npp è un puntatore a puntatore. \\*\\*pp dereferenzia due volte per ottenere il valore di x, che è 10.\n[Riferimento](https://en.cppreference.com/w/cpp/language/pointer)",
            "hint": null,
            "correctAnswer": ["10"],
            "options": ["10", "Indirizzo di x", "Indirizzo di p", "Errore di compilazione"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "a04a02c2d0237f74de89d43f",
            "question": "Per cosa viene usato `std::remove_if`?",
            "answer": "Per rimuovere elementi da un range che soddisfano un predicato",
            "explanation": "**Spiegazione:**\n`std::remove_if` rimuove elementi da un range che soddisfano un predicato dato, usato con erase per l'eliminazione effettiva.\n[Riferimento](https://en.cppreference.com/w/cpp/algorithm/remove)",
            "hint": null,
            "correctAnswer": ["Per rimuovere elementi da un range che soddisfano un predicato"],
            "options": [
              "Per rimuovere istruzioni if",
              "Per rimuovere elementi da un range che soddisfano un predicato",
              "Per rimuovere condizionalmente file",
              "Per rimuovere condizioni"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "6769dd306987ddcde6755111",
            "question": "Per cosa viene usato `std::transform`?",
            "answer": "Per applicare una funzione a un range e memorizzare i risultati in un altro range",
            "explanation": "**Spiegazione:**\n`std::transform` applica una funzione data a un range di elementi e memorizza il risultato in un altro range.\n[Riferimento](https://en.cppreference.com/w/cpp/algorithm/transform)",
            "hint": null,
            "correctAnswer": [
              "Per applicare una funzione a un range e memorizzare i risultati in un altro range"
            ],
            "options": [
              "Per trasformare il codice",
              "Per applicare una funzione a un range e memorizzare i risultati in un altro range",
              "Per trasformare tipi",
              "Per eseguire trasformazioni"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "37becf94d563bb27542b29be",
            "question": "Per cosa viene usato `std::accumulate`?",
            "answer": "Per calcolare la somma o piegare un range di elementi",
            "explanation": "**Spiegazione:**\n`std::accumulate` calcola la somma di un range di elementi o applica un'operazione binaria per piegare il range.\n[Riferimento](https://en.cppreference.com/w/cpp/algorithm/accumulate)",
            "hint": null,
            "correctAnswer": ["Per calcolare la somma o piegare un range di elementi"],
            "options": [
              "Per accumulare errori",
              "Per calcolare la somma o piegare un range di elementi",
              "Per accumulare dati",
              "Per sommare numeri"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "93638d21c0435ac83635100c",
            "question": "Qual è l'output di questo codice?\n```cpp\n#include <iostream>\nint main() {\n    int x = 5;\n    int y = 10;\n    int z = x > y ? x : y;\n    std::cout << z;\n    return 0;\n}\n```",
            "answer": "10",
            "explanation": "**Spiegazione:**\nL'operatore ternario verifica se x > y. Poiché è falso, z viene assegnato y, che è 10.\n[Riferimento](https://en.cppreference.com/w/cpp/language/operator_other)",
            "hint": null,
            "correctAnswer": ["10"],
            "options": ["5", "10", "1", "0"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "5c059951127365d4f72891d0",
            "question": "Per cosa viene usato `std::copy`?",
            "answer": "Per copiare elementi da un range a un altro",
            "explanation": "**Spiegazione:**\n`std::copy` copia elementi da un range sorgente a un range destinazione.\n[Riferimento](https://en.cppreference.com/w/cpp/algorithm/copy)",
            "hint": null,
            "correctAnswer": ["Per copiare elementi da un range a un altro"],
            "options": [
              "Per copiare file",
              "Per copiare elementi da un range a un altro",
              "Per duplicare oggetti",
              "Per copiare memoria"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "8429a3d349af15e4263ba437",
            "question": "Per cosa viene usato `std::find`?",
            "answer": "Per trovare la prima occorrenza di un valore in un range",
            "explanation": "**Spiegazione:**\n`std::find` cerca la prima occorrenza di un valore in un range e restituisce un iteratore ad esso.\n[Riferimento](https://en.cppreference.com/w/cpp/algorithm/find)",
            "hint": null,
            "correctAnswer": ["Per trovare la prima occorrenza di un valore in un range"],
            "options": [
              "Per trovare file",
              "Per trovare la prima occorrenza di un valore in un range",
              "Per cercare pattern",
              "Per localizzare oggetti"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "e47bd331f5fbe28b81aec416",
            "question": "Su cosa si basa `std::sort`?",
            "answer": "Introsort (ibrido di quicksort, heapsort e insertion sort)",
            "explanation": "**Spiegazione:**\n`std::sort` tipicamente usa introsort, che combina quicksort, heapsort e insertion sort per prestazioni ottimali.\n[Riferimento](https://en.cppreference.com/w/cpp/algorithm/sort)",
            "hint": null,
            "correctAnswer": ["Introsort (ibrido di quicksort, heapsort e insertion sort)"],
            "options": [
              "Bubble sort",
              "Introsort (ibrido di quicksort, heapsort e insertion sort)",
              "Solo merge sort",
              "Selection sort"
            ],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          },
          {
            "id": "ef06b64617d4fd896cab9ead",
            "question": "Qual è l'output di questo codice?\n```cpp\n#include <iostream>\n#include <algorithm>\n#include <vector>\nint main() {\n    std::vector<int> v = {5, 2, 8, 1, 9};\n    std::sort(v.begin(), v.end());\n    std::cout << v[2];\n    return 0;\n}\n```",
            "answer": "5",
            "explanation": "**Spiegazione:**\nDopo l'ordinamento, il vettore diventa {1, 2, 5, 8, 9}. v[2] è il terzo elemento, che è 5.\n[Riferimento](https://en.cppreference.com/w/cpp/algorithm/sort)",
            "hint": null,
            "correctAnswer": ["5"],
            "options": ["8", "2", "5", "1"],
            "nature": "ChooseOne",
            "attachments": [],
            "setId": "72f5aa2d090f4b90bc8be471-it",
            "quizzId": "72f5aa2d090f4b90bc8be471"
          }
        ]
      }
    ]
  },
  "meta": {
    "languages": ["ch", "de", "en", "es", "fr", "it"],
    "sources": [
      "c++/c++-quiz-ch.md",
      "c++/c++-quiz-de.md",
      "c++/c++-quiz.md",
      "c++/c++-quiz-es.md",
      "c++/c++-quiz-fr.md",
      "c++/c++-quiz-it.md"
    ],
    "generatedAt": "2025-12-09T22:59:14.444Z",
    "warnings": [
      "Question 42 has no marked correct answers",
      "Question 42 has no options",
      "Question 42 has no marked correct answers",
      "Question 42 has no options",
      "Question 42 has no marked correct answers",
      "Question 42 has no options",
      "Question 42 has no marked correct answers",
      "Question 42 has no options",
      "Question 42 has no marked correct answers",
      "Question 42 has no options",
      "Question 42 has no marked correct answers",
      "Question 42 has no options"
    ]
  }
}
